<polymer-element name="ui-button" attributes="enabled icon label" on-mousedown="{{pointerdown}}" on-mouseup="{{pointerup}}" on-mouseenter="{{pointerenter}}" on-mouseleave="{{pointerleave}}">
<template>
  <style>.fa {
  display: inline-block;
  font-family: FontAwesome;
  font-style: normal;
  font-weight: normal;
  line-height: 1;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
/* makes the font 33% larger relative to the icon container */
.fa-lg {
  font-size: 1.33333333em;
  line-height: 0.75em;
  vertical-align: -15%;
}
.fa-2x {
  font-size: 2em;
}
.fa-3x {
  font-size: 3em;
}
.fa-4x {
  font-size: 4em;
}
.fa-5x {
  font-size: 5em;
}
.fa-fw {
  width: 1.28571429em;
  text-align: center;
}
.fa-ul {
  padding-left: 0;
  margin-left: 2.14285714em;
  list-style-type: none;
}
.fa-ul > li {
  position: relative;
}
.fa-li {
  position: absolute;
  left: -2.14285714em;
  width: 2.14285714em;
  top: 0.14285714em;
  text-align: center;
}
.fa-li.fa-lg {
  left: -1.85714286em;
}
.fa-border {
  padding: .2em .25em .15em;
  border: solid 0.08em #eeeeee;
  border-radius: .1em;
}
.pull-right {
  float: right;
}
.pull-left {
  float: left;
}
.fa.pull-left {
  margin-right: .3em;
}
.fa.pull-right {
  margin-left: .3em;
}
.fa-spin {
  -webkit-animation: spin 2s infinite linear;
  -moz-animation: spin 2s infinite linear;
  -o-animation: spin 2s infinite linear;
  animation: spin 2s infinite linear;
}
@-moz-keyframes spin {
  0% {
    -moz-transform: rotate(0deg);
  }
  100% {
    -moz-transform: rotate(359deg);
  }
}
@-webkit-keyframes spin {
  0% {
    -webkit-transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(359deg);
  }
}
@-o-keyframes spin {
  0% {
    -o-transform: rotate(0deg);
  }
  100% {
    -o-transform: rotate(359deg);
  }
}
@keyframes spin {
  0% {
    -webkit-transform: rotate(0deg);
    transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(359deg);
    transform: rotate(359deg);
  }
}
.fa-rotate-90 {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=1);
  -webkit-transform: rotate(90deg);
  -moz-transform: rotate(90deg);
  -ms-transform: rotate(90deg);
  -o-transform: rotate(90deg);
  transform: rotate(90deg);
}
.fa-rotate-180 {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=2);
  -webkit-transform: rotate(180deg);
  -moz-transform: rotate(180deg);
  -ms-transform: rotate(180deg);
  -o-transform: rotate(180deg);
  transform: rotate(180deg);
}
.fa-rotate-270 {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=3);
  -webkit-transform: rotate(270deg);
  -moz-transform: rotate(270deg);
  -ms-transform: rotate(270deg);
  -o-transform: rotate(270deg);
  transform: rotate(270deg);
}
.fa-flip-horizontal {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1);
  -webkit-transform: scale(-1, 1);
  -moz-transform: scale(-1, 1);
  -ms-transform: scale(-1, 1);
  -o-transform: scale(-1, 1);
  transform: scale(-1, 1);
}
.fa-flip-vertical {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1);
  -webkit-transform: scale(1, -1);
  -moz-transform: scale(1, -1);
  -ms-transform: scale(1, -1);
  -o-transform: scale(1, -1);
  transform: scale(1, -1);
}
.fa-stack {
  position: relative;
  display: inline-block;
  width: 2em;
  height: 2em;
  line-height: 2em;
  vertical-align: middle;
}
.fa-stack-1x,
.fa-stack-2x {
  position: absolute;
  left: 0;
  width: 100%;
  text-align: center;
}
.fa-stack-1x {
  line-height: inherit;
}
.fa-stack-2x {
  font-size: 2em;
}
.fa-inverse {
  color: #ffffff;
}
/* Font Awesome uses the Unicode Private Use Area (PUA) to ensure screen
   readers do not read off random characters that represent icons */
.fa-glass:before {
  content: "\f000";
}
.fa-music:before {
  content: "\f001";
}
.fa-search:before {
  content: "\f002";
}
.fa-envelope-o:before {
  content: "\f003";
}
.fa-heart:before {
  content: "\f004";
}
.fa-star:before {
  content: "\f005";
}
.fa-star-o:before {
  content: "\f006";
}
.fa-user:before {
  content: "\f007";
}
.fa-film:before {
  content: "\f008";
}
.fa-th-large:before {
  content: "\f009";
}
.fa-th:before {
  content: "\f00a";
}
.fa-th-list:before {
  content: "\f00b";
}
.fa-check:before {
  content: "\f00c";
}
.fa-times:before {
  content: "\f00d";
}
.fa-search-plus:before {
  content: "\f00e";
}
.fa-search-minus:before {
  content: "\f010";
}
.fa-power-off:before {
  content: "\f011";
}
.fa-signal:before {
  content: "\f012";
}
.fa-gear:before,
.fa-cog:before {
  content: "\f013";
}
.fa-trash-o:before {
  content: "\f014";
}
.fa-home:before {
  content: "\f015";
}
.fa-file-o:before {
  content: "\f016";
}
.fa-clock-o:before {
  content: "\f017";
}
.fa-road:before {
  content: "\f018";
}
.fa-download:before {
  content: "\f019";
}
.fa-arrow-circle-o-down:before {
  content: "\f01a";
}
.fa-arrow-circle-o-up:before {
  content: "\f01b";
}
.fa-inbox:before {
  content: "\f01c";
}
.fa-play-circle-o:before {
  content: "\f01d";
}
.fa-rotate-right:before,
.fa-repeat:before {
  content: "\f01e";
}
.fa-refresh:before {
  content: "\f021";
}
.fa-list-alt:before {
  content: "\f022";
}
.fa-lock:before {
  content: "\f023";
}
.fa-flag:before {
  content: "\f024";
}
.fa-headphones:before {
  content: "\f025";
}
.fa-volume-off:before {
  content: "\f026";
}
.fa-volume-down:before {
  content: "\f027";
}
.fa-volume-up:before {
  content: "\f028";
}
.fa-qrcode:before {
  content: "\f029";
}
.fa-barcode:before {
  content: "\f02a";
}
.fa-tag:before {
  content: "\f02b";
}
.fa-tags:before {
  content: "\f02c";
}
.fa-book:before {
  content: "\f02d";
}
.fa-bookmark:before {
  content: "\f02e";
}
.fa-print:before {
  content: "\f02f";
}
.fa-camera:before {
  content: "\f030";
}
.fa-font:before {
  content: "\f031";
}
.fa-bold:before {
  content: "\f032";
}
.fa-italic:before {
  content: "\f033";
}
.fa-text-height:before {
  content: "\f034";
}
.fa-text-width:before {
  content: "\f035";
}
.fa-align-left:before {
  content: "\f036";
}
.fa-align-center:before {
  content: "\f037";
}
.fa-align-right:before {
  content: "\f038";
}
.fa-align-justify:before {
  content: "\f039";
}
.fa-list:before {
  content: "\f03a";
}
.fa-dedent:before,
.fa-outdent:before {
  content: "\f03b";
}
.fa-indent:before {
  content: "\f03c";
}
.fa-video-camera:before {
  content: "\f03d";
}
.fa-photo:before,
.fa-image:before,
.fa-picture-o:before {
  content: "\f03e";
}
.fa-pencil:before {
  content: "\f040";
}
.fa-map-marker:before {
  content: "\f041";
}
.fa-adjust:before {
  content: "\f042";
}
.fa-tint:before {
  content: "\f043";
}
.fa-edit:before,
.fa-pencil-square-o:before {
  content: "\f044";
}
.fa-share-square-o:before {
  content: "\f045";
}
.fa-check-square-o:before {
  content: "\f046";
}
.fa-arrows:before {
  content: "\f047";
}
.fa-step-backward:before {
  content: "\f048";
}
.fa-fast-backward:before {
  content: "\f049";
}
.fa-backward:before {
  content: "\f04a";
}
.fa-play:before {
  content: "\f04b";
}
.fa-pause:before {
  content: "\f04c";
}
.fa-stop:before {
  content: "\f04d";
}
.fa-forward:before {
  content: "\f04e";
}
.fa-fast-forward:before {
  content: "\f050";
}
.fa-step-forward:before {
  content: "\f051";
}
.fa-eject:before {
  content: "\f052";
}
.fa-chevron-left:before {
  content: "\f053";
}
.fa-chevron-right:before {
  content: "\f054";
}
.fa-plus-circle:before {
  content: "\f055";
}
.fa-minus-circle:before {
  content: "\f056";
}
.fa-times-circle:before {
  content: "\f057";
}
.fa-check-circle:before {
  content: "\f058";
}
.fa-question-circle:before {
  content: "\f059";
}
.fa-info-circle:before {
  content: "\f05a";
}
.fa-crosshairs:before {
  content: "\f05b";
}
.fa-times-circle-o:before {
  content: "\f05c";
}
.fa-check-circle-o:before {
  content: "\f05d";
}
.fa-ban:before {
  content: "\f05e";
}
.fa-arrow-left:before {
  content: "\f060";
}
.fa-arrow-right:before {
  content: "\f061";
}
.fa-arrow-up:before {
  content: "\f062";
}
.fa-arrow-down:before {
  content: "\f063";
}
.fa-mail-forward:before,
.fa-share:before {
  content: "\f064";
}
.fa-expand:before {
  content: "\f065";
}
.fa-compress:before {
  content: "\f066";
}
.fa-plus:before {
  content: "\f067";
}
.fa-minus:before {
  content: "\f068";
}
.fa-asterisk:before {
  content: "\f069";
}
.fa-exclamation-circle:before {
  content: "\f06a";
}
.fa-gift:before {
  content: "\f06b";
}
.fa-leaf:before {
  content: "\f06c";
}
.fa-fire:before {
  content: "\f06d";
}
.fa-eye:before {
  content: "\f06e";
}
.fa-eye-slash:before {
  content: "\f070";
}
.fa-warning:before,
.fa-exclamation-triangle:before {
  content: "\f071";
}
.fa-plane:before {
  content: "\f072";
}
.fa-calendar:before {
  content: "\f073";
}
.fa-random:before {
  content: "\f074";
}
.fa-comment:before {
  content: "\f075";
}
.fa-magnet:before {
  content: "\f076";
}
.fa-chevron-up:before {
  content: "\f077";
}
.fa-chevron-down:before {
  content: "\f078";
}
.fa-retweet:before {
  content: "\f079";
}
.fa-shopping-cart:before {
  content: "\f07a";
}
.fa-folder:before {
  content: "\f07b";
}
.fa-folder-open:before {
  content: "\f07c";
}
.fa-arrows-v:before {
  content: "\f07d";
}
.fa-arrows-h:before {
  content: "\f07e";
}
.fa-bar-chart-o:before {
  content: "\f080";
}
.fa-twitter-square:before {
  content: "\f081";
}
.fa-facebook-square:before {
  content: "\f082";
}
.fa-camera-retro:before {
  content: "\f083";
}
.fa-key:before {
  content: "\f084";
}
.fa-gears:before,
.fa-cogs:before {
  content: "\f085";
}
.fa-comments:before {
  content: "\f086";
}
.fa-thumbs-o-up:before {
  content: "\f087";
}
.fa-thumbs-o-down:before {
  content: "\f088";
}
.fa-star-half:before {
  content: "\f089";
}
.fa-heart-o:before {
  content: "\f08a";
}
.fa-sign-out:before {
  content: "\f08b";
}
.fa-linkedin-square:before {
  content: "\f08c";
}
.fa-thumb-tack:before {
  content: "\f08d";
}
.fa-external-link:before {
  content: "\f08e";
}
.fa-sign-in:before {
  content: "\f090";
}
.fa-trophy:before {
  content: "\f091";
}
.fa-github-square:before {
  content: "\f092";
}
.fa-upload:before {
  content: "\f093";
}
.fa-lemon-o:before {
  content: "\f094";
}
.fa-phone:before {
  content: "\f095";
}
.fa-square-o:before {
  content: "\f096";
}
.fa-bookmark-o:before {
  content: "\f097";
}
.fa-phone-square:before {
  content: "\f098";
}
.fa-twitter:before {
  content: "\f099";
}
.fa-facebook:before {
  content: "\f09a";
}
.fa-github:before {
  content: "\f09b";
}
.fa-unlock:before {
  content: "\f09c";
}
.fa-credit-card:before {
  content: "\f09d";
}
.fa-rss:before {
  content: "\f09e";
}
.fa-hdd-o:before {
  content: "\f0a0";
}
.fa-bullhorn:before {
  content: "\f0a1";
}
.fa-bell:before {
  content: "\f0f3";
}
.fa-certificate:before {
  content: "\f0a3";
}
.fa-hand-o-right:before {
  content: "\f0a4";
}
.fa-hand-o-left:before {
  content: "\f0a5";
}
.fa-hand-o-up:before {
  content: "\f0a6";
}
.fa-hand-o-down:before {
  content: "\f0a7";
}
.fa-arrow-circle-left:before {
  content: "\f0a8";
}
.fa-arrow-circle-right:before {
  content: "\f0a9";
}
.fa-arrow-circle-up:before {
  content: "\f0aa";
}
.fa-arrow-circle-down:before {
  content: "\f0ab";
}
.fa-globe:before {
  content: "\f0ac";
}
.fa-wrench:before {
  content: "\f0ad";
}
.fa-tasks:before {
  content: "\f0ae";
}
.fa-filter:before {
  content: "\f0b0";
}
.fa-briefcase:before {
  content: "\f0b1";
}
.fa-arrows-alt:before {
  content: "\f0b2";
}
.fa-group:before,
.fa-users:before {
  content: "\f0c0";
}
.fa-chain:before,
.fa-link:before {
  content: "\f0c1";
}
.fa-cloud:before {
  content: "\f0c2";
}
.fa-flask:before {
  content: "\f0c3";
}
.fa-cut:before,
.fa-scissors:before {
  content: "\f0c4";
}
.fa-copy:before,
.fa-files-o:before {
  content: "\f0c5";
}
.fa-paperclip:before {
  content: "\f0c6";
}
.fa-save:before,
.fa-floppy-o:before {
  content: "\f0c7";
}
.fa-square:before {
  content: "\f0c8";
}
.fa-navicon:before,
.fa-reorder:before,
.fa-bars:before {
  content: "\f0c9";
}
.fa-list-ul:before {
  content: "\f0ca";
}
.fa-list-ol:before {
  content: "\f0cb";
}
.fa-strikethrough:before {
  content: "\f0cc";
}
.fa-underline:before {
  content: "\f0cd";
}
.fa-table:before {
  content: "\f0ce";
}
.fa-magic:before {
  content: "\f0d0";
}
.fa-truck:before {
  content: "\f0d1";
}
.fa-pinterest:before {
  content: "\f0d2";
}
.fa-pinterest-square:before {
  content: "\f0d3";
}
.fa-google-plus-square:before {
  content: "\f0d4";
}
.fa-google-plus:before {
  content: "\f0d5";
}
.fa-money:before {
  content: "\f0d6";
}
.fa-caret-down:before {
  content: "\f0d7";
}
.fa-caret-up:before {
  content: "\f0d8";
}
.fa-caret-left:before {
  content: "\f0d9";
}
.fa-caret-right:before {
  content: "\f0da";
}
.fa-columns:before {
  content: "\f0db";
}
.fa-unsorted:before,
.fa-sort:before {
  content: "\f0dc";
}
.fa-sort-down:before,
.fa-sort-desc:before {
  content: "\f0dd";
}
.fa-sort-up:before,
.fa-sort-asc:before {
  content: "\f0de";
}
.fa-envelope:before {
  content: "\f0e0";
}
.fa-linkedin:before {
  content: "\f0e1";
}
.fa-rotate-left:before,
.fa-undo:before {
  content: "\f0e2";
}
.fa-legal:before,
.fa-gavel:before {
  content: "\f0e3";
}
.fa-dashboard:before,
.fa-tachometer:before {
  content: "\f0e4";
}
.fa-comment-o:before {
  content: "\f0e5";
}
.fa-comments-o:before {
  content: "\f0e6";
}
.fa-flash:before,
.fa-bolt:before {
  content: "\f0e7";
}
.fa-sitemap:before {
  content: "\f0e8";
}
.fa-umbrella:before {
  content: "\f0e9";
}
.fa-paste:before,
.fa-clipboard:before {
  content: "\f0ea";
}
.fa-lightbulb-o:before {
  content: "\f0eb";
}
.fa-exchange:before {
  content: "\f0ec";
}
.fa-cloud-download:before {
  content: "\f0ed";
}
.fa-cloud-upload:before {
  content: "\f0ee";
}
.fa-user-md:before {
  content: "\f0f0";
}
.fa-stethoscope:before {
  content: "\f0f1";
}
.fa-suitcase:before {
  content: "\f0f2";
}
.fa-bell-o:before {
  content: "\f0a2";
}
.fa-coffee:before {
  content: "\f0f4";
}
.fa-cutlery:before {
  content: "\f0f5";
}
.fa-file-text-o:before {
  content: "\f0f6";
}
.fa-building-o:before {
  content: "\f0f7";
}
.fa-hospital-o:before {
  content: "\f0f8";
}
.fa-ambulance:before {
  content: "\f0f9";
}
.fa-medkit:before {
  content: "\f0fa";
}
.fa-fighter-jet:before {
  content: "\f0fb";
}
.fa-beer:before {
  content: "\f0fc";
}
.fa-h-square:before {
  content: "\f0fd";
}
.fa-plus-square:before {
  content: "\f0fe";
}
.fa-angle-double-left:before {
  content: "\f100";
}
.fa-angle-double-right:before {
  content: "\f101";
}
.fa-angle-double-up:before {
  content: "\f102";
}
.fa-angle-double-down:before {
  content: "\f103";
}
.fa-angle-left:before {
  content: "\f104";
}
.fa-angle-right:before {
  content: "\f105";
}
.fa-angle-up:before {
  content: "\f106";
}
.fa-angle-down:before {
  content: "\f107";
}
.fa-desktop:before {
  content: "\f108";
}
.fa-laptop:before {
  content: "\f109";
}
.fa-tablet:before {
  content: "\f10a";
}
.fa-mobile-phone:before,
.fa-mobile:before {
  content: "\f10b";
}
.fa-circle-o:before {
  content: "\f10c";
}
.fa-quote-left:before {
  content: "\f10d";
}
.fa-quote-right:before {
  content: "\f10e";
}
.fa-spinner:before {
  content: "\f110";
}
.fa-circle:before {
  content: "\f111";
}
.fa-mail-reply:before,
.fa-reply:before {
  content: "\f112";
}
.fa-github-alt:before {
  content: "\f113";
}
.fa-folder-o:before {
  content: "\f114";
}
.fa-folder-open-o:before {
  content: "\f115";
}
.fa-smile-o:before {
  content: "\f118";
}
.fa-frown-o:before {
  content: "\f119";
}
.fa-meh-o:before {
  content: "\f11a";
}
.fa-gamepad:before {
  content: "\f11b";
}
.fa-keyboard-o:before {
  content: "\f11c";
}
.fa-flag-o:before {
  content: "\f11d";
}
.fa-flag-checkered:before {
  content: "\f11e";
}
.fa-terminal:before {
  content: "\f120";
}
.fa-code:before {
  content: "\f121";
}
.fa-mail-reply-all:before,
.fa-reply-all:before {
  content: "\f122";
}
.fa-star-half-empty:before,
.fa-star-half-full:before,
.fa-star-half-o:before {
  content: "\f123";
}
.fa-location-arrow:before {
  content: "\f124";
}
.fa-crop:before {
  content: "\f125";
}
.fa-code-fork:before {
  content: "\f126";
}
.fa-unlink:before,
.fa-chain-broken:before {
  content: "\f127";
}
.fa-question:before {
  content: "\f128";
}
.fa-info:before {
  content: "\f129";
}
.fa-exclamation:before {
  content: "\f12a";
}
.fa-superscript:before {
  content: "\f12b";
}
.fa-subscript:before {
  content: "\f12c";
}
.fa-eraser:before {
  content: "\f12d";
}
.fa-puzzle-piece:before {
  content: "\f12e";
}
.fa-microphone:before {
  content: "\f130";
}
.fa-microphone-slash:before {
  content: "\f131";
}
.fa-shield:before {
  content: "\f132";
}
.fa-calendar-o:before {
  content: "\f133";
}
.fa-fire-extinguisher:before {
  content: "\f134";
}
.fa-rocket:before {
  content: "\f135";
}
.fa-maxcdn:before {
  content: "\f136";
}
.fa-chevron-circle-left:before {
  content: "\f137";
}
.fa-chevron-circle-right:before {
  content: "\f138";
}
.fa-chevron-circle-up:before {
  content: "\f139";
}
.fa-chevron-circle-down:before {
  content: "\f13a";
}
.fa-html5:before {
  content: "\f13b";
}
.fa-css3:before {
  content: "\f13c";
}
.fa-anchor:before {
  content: "\f13d";
}
.fa-unlock-alt:before {
  content: "\f13e";
}
.fa-bullseye:before {
  content: "\f140";
}
.fa-ellipsis-h:before {
  content: "\f141";
}
.fa-ellipsis-v:before {
  content: "\f142";
}
.fa-rss-square:before {
  content: "\f143";
}
.fa-play-circle:before {
  content: "\f144";
}
.fa-ticket:before {
  content: "\f145";
}
.fa-minus-square:before {
  content: "\f146";
}
.fa-minus-square-o:before {
  content: "\f147";
}
.fa-level-up:before {
  content: "\f148";
}
.fa-level-down:before {
  content: "\f149";
}
.fa-check-square:before {
  content: "\f14a";
}
.fa-pencil-square:before {
  content: "\f14b";
}
.fa-external-link-square:before {
  content: "\f14c";
}
.fa-share-square:before {
  content: "\f14d";
}
.fa-compass:before {
  content: "\f14e";
}
.fa-toggle-down:before,
.fa-caret-square-o-down:before {
  content: "\f150";
}
.fa-toggle-up:before,
.fa-caret-square-o-up:before {
  content: "\f151";
}
.fa-toggle-right:before,
.fa-caret-square-o-right:before {
  content: "\f152";
}
.fa-euro:before,
.fa-eur:before {
  content: "\f153";
}
.fa-gbp:before {
  content: "\f154";
}
.fa-dollar:before,
.fa-usd:before {
  content: "\f155";
}
.fa-rupee:before,
.fa-inr:before {
  content: "\f156";
}
.fa-cny:before,
.fa-rmb:before,
.fa-yen:before,
.fa-jpy:before {
  content: "\f157";
}
.fa-ruble:before,
.fa-rouble:before,
.fa-rub:before {
  content: "\f158";
}
.fa-won:before,
.fa-krw:before {
  content: "\f159";
}
.fa-bitcoin:before,
.fa-btc:before {
  content: "\f15a";
}
.fa-file:before {
  content: "\f15b";
}
.fa-file-text:before {
  content: "\f15c";
}
.fa-sort-alpha-asc:before {
  content: "\f15d";
}
.fa-sort-alpha-desc:before {
  content: "\f15e";
}
.fa-sort-amount-asc:before {
  content: "\f160";
}
.fa-sort-amount-desc:before {
  content: "\f161";
}
.fa-sort-numeric-asc:before {
  content: "\f162";
}
.fa-sort-numeric-desc:before {
  content: "\f163";
}
.fa-thumbs-up:before {
  content: "\f164";
}
.fa-thumbs-down:before {
  content: "\f165";
}
.fa-youtube-square:before {
  content: "\f166";
}
.fa-youtube:before {
  content: "\f167";
}
.fa-xing:before {
  content: "\f168";
}
.fa-xing-square:before {
  content: "\f169";
}
.fa-youtube-play:before {
  content: "\f16a";
}
.fa-dropbox:before {
  content: "\f16b";
}
.fa-stack-overflow:before {
  content: "\f16c";
}
.fa-instagram:before {
  content: "\f16d";
}
.fa-flickr:before {
  content: "\f16e";
}
.fa-adn:before {
  content: "\f170";
}
.fa-bitbucket:before {
  content: "\f171";
}
.fa-bitbucket-square:before {
  content: "\f172";
}
.fa-tumblr:before {
  content: "\f173";
}
.fa-tumblr-square:before {
  content: "\f174";
}
.fa-long-arrow-down:before {
  content: "\f175";
}
.fa-long-arrow-up:before {
  content: "\f176";
}
.fa-long-arrow-left:before {
  content: "\f177";
}
.fa-long-arrow-right:before {
  content: "\f178";
}
.fa-apple:before {
  content: "\f179";
}
.fa-windows:before {
  content: "\f17a";
}
.fa-android:before {
  content: "\f17b";
}
.fa-linux:before {
  content: "\f17c";
}
.fa-dribbble:before {
  content: "\f17d";
}
.fa-skype:before {
  content: "\f17e";
}
.fa-foursquare:before {
  content: "\f180";
}
.fa-trello:before {
  content: "\f181";
}
.fa-female:before {
  content: "\f182";
}
.fa-male:before {
  content: "\f183";
}
.fa-gittip:before {
  content: "\f184";
}
.fa-sun-o:before {
  content: "\f185";
}
.fa-moon-o:before {
  content: "\f186";
}
.fa-archive:before {
  content: "\f187";
}
.fa-bug:before {
  content: "\f188";
}
.fa-vk:before {
  content: "\f189";
}
.fa-weibo:before {
  content: "\f18a";
}
.fa-renren:before {
  content: "\f18b";
}
.fa-pagelines:before {
  content: "\f18c";
}
.fa-stack-exchange:before {
  content: "\f18d";
}
.fa-arrow-circle-o-right:before {
  content: "\f18e";
}
.fa-arrow-circle-o-left:before {
  content: "\f190";
}
.fa-toggle-left:before,
.fa-caret-square-o-left:before {
  content: "\f191";
}
.fa-dot-circle-o:before {
  content: "\f192";
}
.fa-wheelchair:before {
  content: "\f193";
}
.fa-vimeo-square:before {
  content: "\f194";
}
.fa-turkish-lira:before,
.fa-try:before {
  content: "\f195";
}
.fa-plus-square-o:before {
  content: "\f196";
}
.fa-space-shuttle:before {
  content: "\f197";
}
.fa-slack:before {
  content: "\f198";
}
.fa-envelope-square:before {
  content: "\f199";
}
.fa-wordpress:before {
  content: "\f19a";
}
.fa-openid:before {
  content: "\f19b";
}
.fa-institution:before,
.fa-bank:before,
.fa-university:before {
  content: "\f19c";
}
.fa-mortar-board:before,
.fa-graduation-cap:before {
  content: "\f19d";
}
.fa-yahoo:before {
  content: "\f19e";
}
.fa-google:before {
  content: "\f1a0";
}
.fa-reddit:before {
  content: "\f1a1";
}
.fa-reddit-square:before {
  content: "\f1a2";
}
.fa-stumbleupon-circle:before {
  content: "\f1a3";
}
.fa-stumbleupon:before {
  content: "\f1a4";
}
.fa-delicious:before {
  content: "\f1a5";
}
.fa-digg:before {
  content: "\f1a6";
}
.fa-pied-piper-square:before,
.fa-pied-piper:before {
  content: "\f1a7";
}
.fa-pied-piper-alt:before {
  content: "\f1a8";
}
.fa-drupal:before {
  content: "\f1a9";
}
.fa-joomla:before {
  content: "\f1aa";
}
.fa-language:before {
  content: "\f1ab";
}
.fa-fax:before {
  content: "\f1ac";
}
.fa-building:before {
  content: "\f1ad";
}
.fa-child:before {
  content: "\f1ae";
}
.fa-paw:before {
  content: "\f1b0";
}
.fa-spoon:before {
  content: "\f1b1";
}
.fa-cube:before {
  content: "\f1b2";
}
.fa-cubes:before {
  content: "\f1b3";
}
.fa-behance:before {
  content: "\f1b4";
}
.fa-behance-square:before {
  content: "\f1b5";
}
.fa-steam:before {
  content: "\f1b6";
}
.fa-steam-square:before {
  content: "\f1b7";
}
.fa-recycle:before {
  content: "\f1b8";
}
.fa-automobile:before,
.fa-car:before {
  content: "\f1b9";
}
.fa-cab:before,
.fa-taxi:before {
  content: "\f1ba";
}
.fa-tree:before {
  content: "\f1bb";
}
.fa-spotify:before {
  content: "\f1bc";
}
.fa-deviantart:before {
  content: "\f1bd";
}
.fa-soundcloud:before {
  content: "\f1be";
}
.fa-database:before {
  content: "\f1c0";
}
.fa-file-pdf-o:before {
  content: "\f1c1";
}
.fa-file-word-o:before {
  content: "\f1c2";
}
.fa-file-excel-o:before {
  content: "\f1c3";
}
.fa-file-powerpoint-o:before {
  content: "\f1c4";
}
.fa-file-photo-o:before,
.fa-file-picture-o:before,
.fa-file-image-o:before {
  content: "\f1c5";
}
.fa-file-zip-o:before,
.fa-file-archive-o:before {
  content: "\f1c6";
}
.fa-file-sound-o:before,
.fa-file-audio-o:before {
  content: "\f1c7";
}
.fa-file-movie-o:before,
.fa-file-video-o:before {
  content: "\f1c8";
}
.fa-file-code-o:before {
  content: "\f1c9";
}
.fa-vine:before {
  content: "\f1ca";
}
.fa-codepen:before {
  content: "\f1cb";
}
.fa-jsfiddle:before {
  content: "\f1cc";
}
.fa-life-bouy:before,
.fa-life-saver:before,
.fa-support:before,
.fa-life-ring:before {
  content: "\f1cd";
}
.fa-circle-o-notch:before {
  content: "\f1ce";
}
.fa-ra:before,
.fa-rebel:before {
  content: "\f1d0";
}
.fa-ge:before,
.fa-empire:before {
  content: "\f1d1";
}
.fa-git-square:before {
  content: "\f1d2";
}
.fa-git:before {
  content: "\f1d3";
}
.fa-hacker-news:before {
  content: "\f1d4";
}
.fa-tencent-weibo:before {
  content: "\f1d5";
}
.fa-qq:before {
  content: "\f1d6";
}
.fa-wechat:before,
.fa-weixin:before {
  content: "\f1d7";
}
.fa-send:before,
.fa-paper-plane:before {
  content: "\f1d8";
}
.fa-send-o:before,
.fa-paper-plane-o:before {
  content: "\f1d9";
}
.fa-history:before {
  content: "\f1da";
}
.fa-circle-thin:before {
  content: "\f1db";
}
.fa-header:before {
  content: "\f1dc";
}
.fa-paragraph:before {
  content: "\f1dd";
}
.fa-sliders:before {
  content: "\f1de";
}
.fa-share-alt:before {
  content: "\f1e0";
}
.fa-share-alt-square:before {
  content: "\f1e1";
}
.fa-bomb:before {
  content: "\f1e2";
}
.hide {
  display: none !important;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(0, 0, 0, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease;
  -webkit-transition: opacity 0.2s ease;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease, opacity 0.2s ease;
  -webkit-transition: height 0.2s ease, opacity 0.2s ease;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
.sheen {
  background-image: linear-gradient(rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.1));
}
:host {
  display: inline-block;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
:host #button {
  overflow: hidden;
  align-items: center;
  border: none;
  outline: none;
  margin: 0;
  padding: 0.65em 0.65em;
  font-weight: 200;
  background-color: rgba(0, 0, 0, 0.1);
  background-image: linear-gradient(rgba(0, 0, 0, 0.01), rgba(255, 255, 255, 0.1));
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1) inset;
  transition: 0.2s ease;
  -webkit-transition: 0.2s ease;
  color: rgba(69, 69, 69, 0.33);
  cursor: default;
  white-space: nowrap;
  text-overflow: ellipsis;
}
:host #button.enabled {
  color: #454545;
  cursor: pointer;
}
:host #button.pressed {
  transform: scale(0.95, 0.95);
  -webkit-transform: scale(0.95, 0.95);
}
:host #icon {
  padding-right: 0.35em;
}
:host([inverted]) #button {
  color: rgba(255, 255, 255, 0.33);
  background-color: #333333;
  background-image: linear-gradient(rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.1));
}
:host([inverted]) #button.enabled {
  color: #ffffff;
  cursor: pointer;
}
</style>
  <section id="button" class="{{ {enabled: enabled} | tokenList }}" on-click="{{click}}" title="{{label}}">
    <template if="{{icon}}">
      <i id="icon" class="fa {{icon}}"></i>
    </template>
    <template if="{{label}}">
      <span id="label">{{label}}</span>
    </template>
  </section>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-button/src/ui-button.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        Polymer("ui-button", {
            pointerdown: function() {
                if (this.enabled) {
                    return this.$.button.classList.add("pressed");
                }
            },
            pointerup: function() {
                return this.$.button.classList.remove("pressed");
            },
            click: function(evt) {
                if (!this.enabled) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    evt.stopImmediatePropagation();
                    return false;
                }
            },
            pointerenter: function() {},
            pointerleave: function() {},
            created: function() {
                return this.enabled = true;
            },
            ready: function() {},
            attached: function() {},
            domReady: function() {},
            detached: function() {}
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>

<polymer-element name="ui-switch" attributes="">
<template>
  <section>
    <style>.hide {
  display: none !important;
}
.border {
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1) inset;
}
.focused-border {
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.33) inset;
}
.cannot-select-text {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(0, 0, 0, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease;
  -webkit-transition: opacity 0.2s ease;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease, opacity 0.2s ease;
  -webkit-transition: height 0.2s ease, opacity 0.2s ease;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
.sheen {
  background-image: linear-gradient(rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.1));
}
:host {
  display: inline-block;
  box-model: border-box;
  position: relative;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
:host #switch {
  box-sizing: content-box;
  display: inline-block;
  width: 2.5em;
  height: 1em;
  background-color: rgba(0, 0, 0, 0.1);
  background-image: linear-gradient(rgba(0, 0, 0, 0.01), rgba(0, 0, 0, 0.02));
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1) inset;
  margin-right: 0.5em;
  padding: 0.2em;
  transition: 0.2s ease;
  -webkit-transition: 0.2s ease;
}
:host #switchhandle {
  box-sizing: border-box;
  display: inline-block;
  background-image: linear-gradient(rgba(0, 0, 0, 0.01), rgba(0, 0, 0, 0.02));
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1) inset;
  width: 1em;
  height: 1em;
  transition: 0.1s ease-out;
  -webkit-transition: 0.1s ease-out;
  margin-left: 0;
  background-color: #ffffff;
  background-color: rgba(0, 0, 0, 0.1);
}
:host input {
  position: absolute;
  opacity: 0;
}
:host([checked]) #switchhandle {
  margin-left: 1.5em;
}
:host([checked]) #switch {
  background-color: #c8ed8d;
}
:host([focused]) #switch {
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.33) inset;
}
</style>
    <input type="checkbox" id="check" on-change="{{onChange}}" on-focus="{{onFocus}}" on-blur="{{onBlur}}">
    <label id="checklabel" for="check" horizontal="" layout="" center="">
      <section id="switch">
        <span id="switchhandle"></span>
      </section>
      <content on-click="{{onContentClick}}"></content>
    </label>
</section>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-switch/src/ui-switch.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        Polymer("ui-switch", {
            onChange: function() {
                if (this.$.check.checked) {
                    return this.setAttribute("checked", "");
                } else {
                    return this.removeAttribute("checked");
                }
            },
            onFocus: function() {
                return this.setAttribute("focused", "");
            },
            onBlur: function() {
                return this.removeAttribute("focused");
            },
            onContentClick: function() {
                return console.log("aaa");
            },
            created: function() {},
            ready: function() {},
            attached: function() {},
            domReady: function() {},
            detached: function() {}
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>

<polymer-element name="ui-hotkey" attributes="key">
  <template> </template>
  <script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-hotkey/src/ui-hotkey.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        "use strict";
        module.exports = {
            48: "0",
            49: "1",
            50: "2",
            51: "3",
            52: "4",
            53: "5",
            54: "6",
            55: "7",
            56: "8",
            57: "9",
            59: ";",
            61: "=",
            65: "a",
            66: "b",
            67: "c",
            68: "d",
            69: "e",
            70: "f",
            71: "g",
            72: "h",
            73: "i",
            74: "j",
            75: "k",
            76: "l",
            77: "m",
            78: "n",
            79: "o",
            80: "p",
            81: "q",
            82: "r",
            83: "s",
            84: "t",
            85: "u",
            86: "v",
            87: "w",
            88: "x",
            89: "y",
            90: "z",
            107: "+",
            109: "-",
            110: ".",
            188: ",",
            190: ".",
            191: "/",
            192: "`",
            219: "[",
            220: "\\",
            221: "]",
            222: '"',
            8: "backspace",
            9: "tab",
            13: "return",
            16: "shift",
            17: "control",
            18: "alt",
            19: "pause",
            27: "escape",
            32: "space",
            33: "pageup",
            34: "pagedown",
            35: "end",
            36: "home",
            37: "left",
            38: "up",
            39: "right",
            40: "down",
            44: "printscreen",
            45: "insert",
            46: "delete",
            112: "f1",
            113: "f2",
            114: "f3",
            115: "f4",
            116: "f5",
            117: "f6",
            118: "f7",
            119: "f8",
            120: "f9",
            121: "f10",
            122: "f11",
            123: "f12",
            144: "numlock",
            145: "scrolllock",
            91: "command"
        };
    }, {} ],
    2: [ function(require, module, exports) {
        var getAction, keyCodes;
        keyCodes = require("./key-codes");
        getAction = function(e) {
            var action, which;
            action = [];
            if (e.ctrlKey) {
                action.push("control");
            }
            if (e.altKey) {
                action.push("alt");
            }
            if (e.shiftKey) {
                action.push("shift");
            }
            which = keyCodes[e.which];
            if (action.indexOf(which) === -1) {
                action.push(which);
            }
            return action.join("+");
        };
        Polymer("ui-hotkey", {
            myListener: function(e) {
                var action, _ref;
                action = getAction(e);
                if (action === ((_ref = this.key) != null ? _ref.toLowerCase() : void 0)) {
                    return this.click();
                }
            },
            attached: function() {
                return document.addEventListener("keyup", function(_this) {
                    return function(e) {
                        return _this.myListener(e);
                    };
                }(this));
            },
            detached: function() {
                return document.removeEventListener("keyup", function(_this) {
                    return function(e) {
                        return _this.myListener(e);
                    };
                }(this));
            }
        });
    }, {
        "./key-codes": 1
    } ]
}, {}, [ 2 ]);</script>
</polymer-element>

<polymer-element name="ui-fast-picker" attributes="selected radius startangle endangle" on-select="{{selectHandler}}">
<template>
  <style>[hide] {
  visibility: hidden;
  opacity: 0;
}
:host {
  display: inline-block;
  position: relative;
  box-sizing: border-box;
  vertical-align: baseline;
}
background {
  display: block;
  position: absolute;
  z-index: 1;
}
</style>
  <background></background>
  <content>
  </content>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-fast-picker/src/ui-fast-picker.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        (function(global) {
            (function() {
                var undefined;
                var arrayPool = [], objectPool = [];
                var idCounter = 0;
                var keyPrefix = +new Date() + "";
                var largeArraySize = 75;
                var maxPoolSize = 40;
                var whitespace = " 	\f ﻿" + "\n\r\u2028\u2029" + " ᠎             　";
                var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
                var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
                var reFlags = /\w*$/;
                var reFuncName = /^\s*function[ \n\r\t]+\w/;
                var reInterpolate = /<%=([\s\S]+?)%>/g;
                var reLeadingSpacesAndZeros = RegExp("^[" + whitespace + "]*0+(?=.$)");
                var reNoMatch = /($^)/;
                var reThis = /\bthis\b/;
                var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
                var contextProps = [ "Array", "Boolean", "Date", "Function", "Math", "Number", "Object", "RegExp", "String", "_", "attachEvent", "clearTimeout", "isFinite", "isNaN", "parseInt", "setTimeout" ];
                var templateCounter = 0;
                var argsClass = "[object Arguments]", arrayClass = "[object Array]", boolClass = "[object Boolean]", dateClass = "[object Date]", funcClass = "[object Function]", numberClass = "[object Number]", objectClass = "[object Object]", regexpClass = "[object RegExp]", stringClass = "[object String]";
                var cloneableClasses = {};
                cloneableClasses[funcClass] = false;
                cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
                var debounceOptions = {
                    leading: false,
                    maxWait: 0,
                    trailing: false
                };
                var descriptor = {
                    configurable: false,
                    enumerable: false,
                    value: null,
                    writable: false
                };
                var objectTypes = {
                    "boolean": false,
                    "function": true,
                    object: true,
                    number: false,
                    string: false,
                    undefined: false
                };
                var stringEscapes = {
                    "\\": "\\",
                    "'": "'",
                    "\n": "n",
                    "\r": "r",
                    "	": "t",
                    "\u2028": "u2028",
                    "\u2029": "u2029"
                };
                var root = objectTypes[typeof window] && window || this;
                var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
                var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
                var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
                var freeGlobal = objectTypes[typeof global] && global;
                if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
                    root = freeGlobal;
                }
                function baseIndexOf(array, value, fromIndex) {
                    var index = (fromIndex || 0) - 1, length = array ? array.length : 0;
                    while (++index < length) {
                        if (array[index] === value) {
                            return index;
                        }
                    }
                    return -1;
                }
                function cacheIndexOf(cache, value) {
                    var type = typeof value;
                    cache = cache.cache;
                    if (type == "boolean" || value == null) {
                        return cache[value] ? 0 : -1;
                    }
                    if (type != "number" && type != "string") {
                        type = "object";
                    }
                    var key = type == "number" ? value : keyPrefix + value;
                    cache = (cache = cache[type]) && cache[key];
                    return type == "object" ? cache && baseIndexOf(cache, value) > -1 ? 0 : -1 : cache ? 0 : -1;
                }
                function cachePush(value) {
                    var cache = this.cache, type = typeof value;
                    if (type == "boolean" || value == null) {
                        cache[value] = true;
                    } else {
                        if (type != "number" && type != "string") {
                            type = "object";
                        }
                        var key = type == "number" ? value : keyPrefix + value, typeCache = cache[type] || (cache[type] = {});
                        if (type == "object") {
                            (typeCache[key] || (typeCache[key] = [])).push(value);
                        } else {
                            typeCache[key] = true;
                        }
                    }
                }
                function charAtCallback(value) {
                    return value.charCodeAt(0);
                }
                function compareAscending(a, b) {
                    var ac = a.criteria, bc = b.criteria, index = -1, length = ac.length;
                    while (++index < length) {
                        var value = ac[index], other = bc[index];
                        if (value !== other) {
                            if (value > other || typeof value == "undefined") {
                                return 1;
                            }
                            if (value < other || typeof other == "undefined") {
                                return -1;
                            }
                        }
                    }
                    return a.index - b.index;
                }
                function createCache(array) {
                    var index = -1, length = array.length, first = array[0], mid = array[length / 2 | 0], last = array[length - 1];
                    if (first && typeof first == "object" && mid && typeof mid == "object" && last && typeof last == "object") {
                        return false;
                    }
                    var cache = getObject();
                    cache["false"] = cache["null"] = cache["true"] = cache["undefined"] = false;
                    var result = getObject();
                    result.array = array;
                    result.cache = cache;
                    result.push = cachePush;
                    while (++index < length) {
                        result.push(array[index]);
                    }
                    return result;
                }
                function escapeStringChar(match) {
                    return "\\" + stringEscapes[match];
                }
                function getArray() {
                    return arrayPool.pop() || [];
                }
                function getObject() {
                    return objectPool.pop() || {
                        array: null,
                        cache: null,
                        criteria: null,
                        "false": false,
                        index: 0,
                        "null": false,
                        number: null,
                        object: null,
                        push: null,
                        string: null,
                        "true": false,
                        undefined: false,
                        value: null
                    };
                }
                function releaseArray(array) {
                    array.length = 0;
                    if (arrayPool.length < maxPoolSize) {
                        arrayPool.push(array);
                    }
                }
                function releaseObject(object) {
                    var cache = object.cache;
                    if (cache) {
                        releaseObject(cache);
                    }
                    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
                    if (objectPool.length < maxPoolSize) {
                        objectPool.push(object);
                    }
                }
                function slice(array, start, end) {
                    start || (start = 0);
                    if (typeof end == "undefined") {
                        end = array ? array.length : 0;
                    }
                    var index = -1, length = end - start || 0, result = Array(length < 0 ? 0 : length);
                    while (++index < length) {
                        result[index] = array[start + index];
                    }
                    return result;
                }
                function runInContext(context) {
                    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
                    var Array = context.Array, Boolean = context.Boolean, Date = context.Date, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
                    var arrayRef = [];
                    var objectProto = Object.prototype;
                    var oldDash = context._;
                    var toString = objectProto.toString;
                    var reNative = RegExp("^" + String(toString).replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/toString| for [^\]]+/g, ".*?") + "$");
                    var ceil = Math.ceil, clearTimeout = context.clearTimeout, floor = Math.floor, fnToString = Function.prototype.toString, getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, hasOwnProperty = objectProto.hasOwnProperty, push = arrayRef.push, setTimeout = context.setTimeout, splice = arrayRef.splice, unshift = arrayRef.unshift;
                    var defineProperty = function() {
                        try {
                            var o = {}, func = isNative(func = Object.defineProperty) && func, result = func(o, o, o) && func;
                        } catch (e) {}
                        return result;
                    }();
                    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate, nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray, nativeIsFinite = context.isFinite, nativeIsNaN = context.isNaN, nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeParseInt = context.parseInt, nativeRandom = Math.random;
                    var ctorByClass = {};
                    ctorByClass[arrayClass] = Array;
                    ctorByClass[boolClass] = Boolean;
                    ctorByClass[dateClass] = Date;
                    ctorByClass[funcClass] = Function;
                    ctorByClass[objectClass] = Object;
                    ctorByClass[numberClass] = Number;
                    ctorByClass[regexpClass] = RegExp;
                    ctorByClass[stringClass] = String;
                    function lodash(value) {
                        return value && typeof value == "object" && !isArray(value) && hasOwnProperty.call(value, "__wrapped__") ? value : new lodashWrapper(value);
                    }
                    function lodashWrapper(value, chainAll) {
                        this.__chain__ = !!chainAll;
                        this.__wrapped__ = value;
                    }
                    lodashWrapper.prototype = lodash.prototype;
                    var support = lodash.support = {};
                    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
                    support.funcNames = typeof Function.name == "string";
                    lodash.templateSettings = {
                        escape: /<%-([\s\S]+?)%>/g,
                        evaluate: /<%([\s\S]+?)%>/g,
                        interpolate: reInterpolate,
                        variable: "",
                        imports: {
                            _: lodash
                        }
                    };
                    function baseBind(bindData) {
                        var func = bindData[0], partialArgs = bindData[2], thisArg = bindData[4];
                        function bound() {
                            if (partialArgs) {
                                var args = slice(partialArgs);
                                push.apply(args, arguments);
                            }
                            if (this instanceof bound) {
                                var thisBinding = baseCreate(func.prototype), result = func.apply(thisBinding, args || arguments);
                                return isObject(result) ? result : thisBinding;
                            }
                            return func.apply(thisArg, args || arguments);
                        }
                        setBindData(bound, bindData);
                        return bound;
                    }
                    function baseClone(value, isDeep, callback, stackA, stackB) {
                        if (callback) {
                            var result = callback(value);
                            if (typeof result != "undefined") {
                                return result;
                            }
                        }
                        var isObj = isObject(value);
                        if (isObj) {
                            var className = toString.call(value);
                            if (!cloneableClasses[className]) {
                                return value;
                            }
                            var ctor = ctorByClass[className];
                            switch (className) {
                              case boolClass:
                              case dateClass:
                                return new ctor(+value);

                              case numberClass:
                              case stringClass:
                                return new ctor(value);

                              case regexpClass:
                                result = ctor(value.source, reFlags.exec(value));
                                result.lastIndex = value.lastIndex;
                                return result;
                            }
                        } else {
                            return value;
                        }
                        var isArr = isArray(value);
                        if (isDeep) {
                            var initedStack = !stackA;
                            stackA || (stackA = getArray());
                            stackB || (stackB = getArray());
                            var length = stackA.length;
                            while (length--) {
                                if (stackA[length] == value) {
                                    return stackB[length];
                                }
                            }
                            result = isArr ? ctor(value.length) : {};
                        } else {
                            result = isArr ? slice(value) : assign({}, value);
                        }
                        if (isArr) {
                            if (hasOwnProperty.call(value, "index")) {
                                result.index = value.index;
                            }
                            if (hasOwnProperty.call(value, "input")) {
                                result.input = value.input;
                            }
                        }
                        if (!isDeep) {
                            return result;
                        }
                        stackA.push(value);
                        stackB.push(result);
                        (isArr ? forEach : forOwn)(value, function(objValue, key) {
                            result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
                        });
                        if (initedStack) {
                            releaseArray(stackA);
                            releaseArray(stackB);
                        }
                        return result;
                    }
                    function baseCreate(prototype, properties) {
                        return isObject(prototype) ? nativeCreate(prototype) : {};
                    }
                    if (!nativeCreate) {
                        baseCreate = function() {
                            function Object() {}
                            return function(prototype) {
                                if (isObject(prototype)) {
                                    Object.prototype = prototype;
                                    var result = new Object();
                                    Object.prototype = null;
                                }
                                return result || context.Object();
                            };
                        }();
                    }
                    function baseCreateCallback(func, thisArg, argCount) {
                        if (typeof func != "function") {
                            return identity;
                        }
                        if (typeof thisArg == "undefined" || !("prototype" in func)) {
                            return func;
                        }
                        var bindData = func.__bindData__;
                        if (typeof bindData == "undefined") {
                            if (support.funcNames) {
                                bindData = !func.name;
                            }
                            bindData = bindData || !support.funcDecomp;
                            if (!bindData) {
                                var source = fnToString.call(func);
                                if (!support.funcNames) {
                                    bindData = !reFuncName.test(source);
                                }
                                if (!bindData) {
                                    bindData = reThis.test(source);
                                    setBindData(func, bindData);
                                }
                            }
                        }
                        if (bindData === false || bindData !== true && bindData[1] & 1) {
                            return func;
                        }
                        switch (argCount) {
                          case 1:
                            return function(value) {
                                return func.call(thisArg, value);
                            };

                          case 2:
                            return function(a, b) {
                                return func.call(thisArg, a, b);
                            };

                          case 3:
                            return function(value, index, collection) {
                                return func.call(thisArg, value, index, collection);
                            };

                          case 4:
                            return function(accumulator, value, index, collection) {
                                return func.call(thisArg, accumulator, value, index, collection);
                            };
                        }
                        return bind(func, thisArg);
                    }
                    function baseCreateWrapper(bindData) {
                        var func = bindData[0], bitmask = bindData[1], partialArgs = bindData[2], partialRightArgs = bindData[3], thisArg = bindData[4], arity = bindData[5];
                        var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, key = func;
                        function bound() {
                            var thisBinding = isBind ? thisArg : this;
                            if (partialArgs) {
                                var args = slice(partialArgs);
                                push.apply(args, arguments);
                            }
                            if (partialRightArgs || isCurry) {
                                args || (args = slice(arguments));
                                if (partialRightArgs) {
                                    push.apply(args, partialRightArgs);
                                }
                                if (isCurry && args.length < arity) {
                                    bitmask |= 16 & ~32;
                                    return baseCreateWrapper([ func, isCurryBound ? bitmask : bitmask & ~3, args, null, thisArg, arity ]);
                                }
                            }
                            args || (args = arguments);
                            if (isBindKey) {
                                func = thisBinding[key];
                            }
                            if (this instanceof bound) {
                                thisBinding = baseCreate(func.prototype);
                                var result = func.apply(thisBinding, args);
                                return isObject(result) ? result : thisBinding;
                            }
                            return func.apply(thisBinding, args);
                        }
                        setBindData(bound, bindData);
                        return bound;
                    }
                    function baseDifference(array, values) {
                        var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, isLarge = length >= largeArraySize && indexOf === baseIndexOf, result = [];
                        if (isLarge) {
                            var cache = createCache(values);
                            if (cache) {
                                indexOf = cacheIndexOf;
                                values = cache;
                            } else {
                                isLarge = false;
                            }
                        }
                        while (++index < length) {
                            var value = array[index];
                            if (indexOf(values, value) < 0) {
                                result.push(value);
                            }
                        }
                        if (isLarge) {
                            releaseObject(values);
                        }
                        return result;
                    }
                    function baseFlatten(array, isShallow, isStrict, fromIndex) {
                        var index = (fromIndex || 0) - 1, length = array ? array.length : 0, result = [];
                        while (++index < length) {
                            var value = array[index];
                            if (value && typeof value == "object" && typeof value.length == "number" && (isArray(value) || isArguments(value))) {
                                if (!isShallow) {
                                    value = baseFlatten(value, isShallow, isStrict);
                                }
                                var valIndex = -1, valLength = value.length, resIndex = result.length;
                                result.length += valLength;
                                while (++valIndex < valLength) {
                                    result[resIndex++] = value[valIndex];
                                }
                            } else if (!isStrict) {
                                result.push(value);
                            }
                        }
                        return result;
                    }
                    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
                        if (callback) {
                            var result = callback(a, b);
                            if (typeof result != "undefined") {
                                return !!result;
                            }
                        }
                        if (a === b) {
                            return a !== 0 || 1 / a == 1 / b;
                        }
                        var type = typeof a, otherType = typeof b;
                        if (a === a && !(a && objectTypes[type]) && !(b && objectTypes[otherType])) {
                            return false;
                        }
                        if (a == null || b == null) {
                            return a === b;
                        }
                        var className = toString.call(a), otherClass = toString.call(b);
                        if (className == argsClass) {
                            className = objectClass;
                        }
                        if (otherClass == argsClass) {
                            otherClass = objectClass;
                        }
                        if (className != otherClass) {
                            return false;
                        }
                        switch (className) {
                          case boolClass:
                          case dateClass:
                            return +a == +b;

                          case numberClass:
                            return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;

                          case regexpClass:
                          case stringClass:
                            return a == String(b);
                        }
                        var isArr = className == arrayClass;
                        if (!isArr) {
                            var aWrapped = hasOwnProperty.call(a, "__wrapped__"), bWrapped = hasOwnProperty.call(b, "__wrapped__");
                            if (aWrapped || bWrapped) {
                                return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
                            }
                            if (className != objectClass) {
                                return false;
                            }
                            var ctorA = a.constructor, ctorB = b.constructor;
                            if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ("constructor" in a && "constructor" in b)) {
                                return false;
                            }
                        }
                        var initedStack = !stackA;
                        stackA || (stackA = getArray());
                        stackB || (stackB = getArray());
                        var length = stackA.length;
                        while (length--) {
                            if (stackA[length] == a) {
                                return stackB[length] == b;
                            }
                        }
                        var size = 0;
                        result = true;
                        stackA.push(a);
                        stackB.push(b);
                        if (isArr) {
                            length = a.length;
                            size = b.length;
                            result = size == length;
                            if (result || isWhere) {
                                while (size--) {
                                    var index = length, value = b[size];
                                    if (isWhere) {
                                        while (index--) {
                                            if (result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB)) {
                                                break;
                                            }
                                        }
                                    } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
                                        break;
                                    }
                                }
                            }
                        } else {
                            forIn(b, function(value, key, b) {
                                if (hasOwnProperty.call(b, key)) {
                                    size++;
                                    return result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB);
                                }
                            });
                            if (result && !isWhere) {
                                forIn(a, function(value, key, a) {
                                    if (hasOwnProperty.call(a, key)) {
                                        return result = --size > -1;
                                    }
                                });
                            }
                        }
                        stackA.pop();
                        stackB.pop();
                        if (initedStack) {
                            releaseArray(stackA);
                            releaseArray(stackB);
                        }
                        return result;
                    }
                    function baseMerge(object, source, callback, stackA, stackB) {
                        (isArray(source) ? forEach : forOwn)(source, function(source, key) {
                            var found, isArr, result = source, value = object[key];
                            if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                                var stackLength = stackA.length;
                                while (stackLength--) {
                                    if (found = stackA[stackLength] == source) {
                                        value = stackB[stackLength];
                                        break;
                                    }
                                }
                                if (!found) {
                                    var isShallow;
                                    if (callback) {
                                        result = callback(value, source);
                                        if (isShallow = typeof result != "undefined") {
                                            value = result;
                                        }
                                    }
                                    if (!isShallow) {
                                        value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {};
                                    }
                                    stackA.push(source);
                                    stackB.push(value);
                                    if (!isShallow) {
                                        baseMerge(value, source, callback, stackA, stackB);
                                    }
                                }
                            } else {
                                if (callback) {
                                    result = callback(value, source);
                                    if (typeof result == "undefined") {
                                        result = source;
                                    }
                                }
                                if (typeof result != "undefined") {
                                    value = result;
                                }
                            }
                            object[key] = value;
                        });
                    }
                    function baseRandom(min, max) {
                        return min + floor(nativeRandom() * (max - min + 1));
                    }
                    function baseUniq(array, isSorted, callback) {
                        var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [];
                        var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf, seen = callback || isLarge ? getArray() : result;
                        if (isLarge) {
                            var cache = createCache(seen);
                            indexOf = cacheIndexOf;
                            seen = cache;
                        }
                        while (++index < length) {
                            var value = array[index], computed = callback ? callback(value, index, array) : value;
                            if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) {
                                if (callback || isLarge) {
                                    seen.push(computed);
                                }
                                result.push(value);
                            }
                        }
                        if (isLarge) {
                            releaseArray(seen.array);
                            releaseObject(seen);
                        } else if (callback) {
                            releaseArray(seen);
                        }
                        return result;
                    }
                    function createAggregator(setter) {
                        return function(collection, callback, thisArg) {
                            var result = {};
                            callback = lodash.createCallback(callback, thisArg, 3);
                            var index = -1, length = collection ? collection.length : 0;
                            if (typeof length == "number") {
                                while (++index < length) {
                                    var value = collection[index];
                                    setter(result, value, callback(value, index, collection), collection);
                                }
                            } else {
                                forOwn(collection, function(value, key, collection) {
                                    setter(result, value, callback(value, key, collection), collection);
                                });
                            }
                            return result;
                        };
                    }
                    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
                        var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, isPartial = bitmask & 16, isPartialRight = bitmask & 32;
                        if (!isBindKey && !isFunction(func)) {
                            throw new TypeError();
                        }
                        if (isPartial && !partialArgs.length) {
                            bitmask &= ~16;
                            isPartial = partialArgs = false;
                        }
                        if (isPartialRight && !partialRightArgs.length) {
                            bitmask &= ~32;
                            isPartialRight = partialRightArgs = false;
                        }
                        var bindData = func && func.__bindData__;
                        if (bindData && bindData !== true) {
                            bindData = slice(bindData);
                            if (bindData[2]) {
                                bindData[2] = slice(bindData[2]);
                            }
                            if (bindData[3]) {
                                bindData[3] = slice(bindData[3]);
                            }
                            if (isBind && !(bindData[1] & 1)) {
                                bindData[4] = thisArg;
                            }
                            if (!isBind && bindData[1] & 1) {
                                bitmask |= 8;
                            }
                            if (isCurry && !(bindData[1] & 4)) {
                                bindData[5] = arity;
                            }
                            if (isPartial) {
                                push.apply(bindData[2] || (bindData[2] = []), partialArgs);
                            }
                            if (isPartialRight) {
                                unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
                            }
                            bindData[1] |= bitmask;
                            return createWrapper.apply(null, bindData);
                        }
                        var creater = bitmask == 1 || bitmask === 17 ? baseBind : baseCreateWrapper;
                        return creater([ func, bitmask, partialArgs, partialRightArgs, thisArg, arity ]);
                    }
                    function escapeHtmlChar(match) {
                        return htmlEscapes[match];
                    }
                    function getIndexOf() {
                        var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
                        return result;
                    }
                    function isNative(value) {
                        return typeof value == "function" && reNative.test(value);
                    }
                    var setBindData = !defineProperty ? noop : function(func, value) {
                        descriptor.value = value;
                        defineProperty(func, "__bindData__", descriptor);
                    };
                    function shimIsPlainObject(value) {
                        var ctor, result;
                        if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, 
                        isFunction(ctor) && !(ctor instanceof ctor))) {
                            return false;
                        }
                        forIn(value, function(value, key) {
                            result = key;
                        });
                        return typeof result == "undefined" || hasOwnProperty.call(value, result);
                    }
                    function unescapeHtmlChar(match) {
                        return htmlUnescapes[match];
                    }
                    function isArguments(value) {
                        return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == argsClass || false;
                    }
                    var isArray = nativeIsArray || function(value) {
                        return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == arrayClass || false;
                    };
                    var shimKeys = function(object) {
                        var index, iterable = object, result = [];
                        if (!iterable) return result;
                        if (!objectTypes[typeof object]) return result;
                        for (index in iterable) {
                            if (hasOwnProperty.call(iterable, index)) {
                                result.push(index);
                            }
                        }
                        return result;
                    };
                    var keys = !nativeKeys ? shimKeys : function(object) {
                        if (!isObject(object)) {
                            return [];
                        }
                        return nativeKeys(object);
                    };
                    var htmlEscapes = {
                        "&": "&amp;",
                        "<": "&lt;",
                        ">": "&gt;",
                        '"': "&quot;",
                        "'": "&#39;"
                    };
                    var htmlUnescapes = invert(htmlEscapes);
                    var reEscapedHtml = RegExp("(" + keys(htmlUnescapes).join("|") + ")", "g"), reUnescapedHtml = RegExp("[" + keys(htmlEscapes).join("") + "]", "g");
                    var assign = function(object, source, guard) {
                        var index, iterable = object, result = iterable;
                        if (!iterable) return result;
                        var args = arguments, argsIndex = 0, argsLength = typeof guard == "number" ? 2 : args.length;
                        if (argsLength > 3 && typeof args[argsLength - 2] == "function") {
                            var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
                        } else if (argsLength > 2 && typeof args[argsLength - 1] == "function") {
                            callback = args[--argsLength];
                        }
                        while (++argsIndex < argsLength) {
                            iterable = args[argsIndex];
                            if (iterable && objectTypes[typeof iterable]) {
                                var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                                while (++ownIndex < length) {
                                    index = ownProps[ownIndex];
                                    result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
                                }
                            }
                        }
                        return result;
                    };
                    function clone(value, isDeep, callback, thisArg) {
                        if (typeof isDeep != "boolean" && isDeep != null) {
                            thisArg = callback;
                            callback = isDeep;
                            isDeep = false;
                        }
                        return baseClone(value, isDeep, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
                    }
                    function cloneDeep(value, callback, thisArg) {
                        return baseClone(value, true, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
                    }
                    function create(prototype, properties) {
                        var result = baseCreate(prototype);
                        return properties ? assign(result, properties) : result;
                    }
                    var defaults = function(object, source, guard) {
                        var index, iterable = object, result = iterable;
                        if (!iterable) return result;
                        var args = arguments, argsIndex = 0, argsLength = typeof guard == "number" ? 2 : args.length;
                        while (++argsIndex < argsLength) {
                            iterable = args[argsIndex];
                            if (iterable && objectTypes[typeof iterable]) {
                                var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                                while (++ownIndex < length) {
                                    index = ownProps[ownIndex];
                                    if (typeof result[index] == "undefined") result[index] = iterable[index];
                                }
                            }
                        }
                        return result;
                    };
                    function findKey(object, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwn(object, function(value, key, object) {
                            if (callback(value, key, object)) {
                                result = key;
                                return false;
                            }
                        });
                        return result;
                    }
                    function findLastKey(object, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwnRight(object, function(value, key, object) {
                            if (callback(value, key, object)) {
                                result = key;
                                return false;
                            }
                        });
                        return result;
                    }
                    var forIn = function(collection, callback, thisArg) {
                        var index, iterable = collection, result = iterable;
                        if (!iterable) return result;
                        if (!objectTypes[typeof iterable]) return result;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        for (index in iterable) {
                            if (callback(iterable[index], index, collection) === false) return result;
                        }
                        return result;
                    };
                    function forInRight(object, callback, thisArg) {
                        var pairs = [];
                        forIn(object, function(value, key) {
                            pairs.push(key, value);
                        });
                        var length = pairs.length;
                        callback = baseCreateCallback(callback, thisArg, 3);
                        while (length--) {
                            if (callback(pairs[length--], pairs[length], object) === false) {
                                break;
                            }
                        }
                        return object;
                    }
                    var forOwn = function(collection, callback, thisArg) {
                        var index, iterable = collection, result = iterable;
                        if (!iterable) return result;
                        if (!objectTypes[typeof iterable]) return result;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                        while (++ownIndex < length) {
                            index = ownProps[ownIndex];
                            if (callback(iterable[index], index, collection) === false) return result;
                        }
                        return result;
                    };
                    function forOwnRight(object, callback, thisArg) {
                        var props = keys(object), length = props.length;
                        callback = baseCreateCallback(callback, thisArg, 3);
                        while (length--) {
                            var key = props[length];
                            if (callback(object[key], key, object) === false) {
                                break;
                            }
                        }
                        return object;
                    }
                    function functions(object) {
                        var result = [];
                        forIn(object, function(value, key) {
                            if (isFunction(value)) {
                                result.push(key);
                            }
                        });
                        return result.sort();
                    }
                    function has(object, key) {
                        return object ? hasOwnProperty.call(object, key) : false;
                    }
                    function invert(object) {
                        var index = -1, props = keys(object), length = props.length, result = {};
                        while (++index < length) {
                            var key = props[index];
                            result[object[key]] = key;
                        }
                        return result;
                    }
                    function isBoolean(value) {
                        return value === true || value === false || value && typeof value == "object" && toString.call(value) == boolClass || false;
                    }
                    function isDate(value) {
                        return value && typeof value == "object" && toString.call(value) == dateClass || false;
                    }
                    function isElement(value) {
                        return value && value.nodeType === 1 || false;
                    }
                    function isEmpty(value) {
                        var result = true;
                        if (!value) {
                            return result;
                        }
                        var className = toString.call(value), length = value.length;
                        if (className == arrayClass || className == stringClass || className == argsClass || className == objectClass && typeof length == "number" && isFunction(value.splice)) {
                            return !length;
                        }
                        forOwn(value, function() {
                            return result = false;
                        });
                        return result;
                    }
                    function isEqual(a, b, callback, thisArg) {
                        return baseIsEqual(a, b, typeof callback == "function" && baseCreateCallback(callback, thisArg, 2));
                    }
                    function isFinite(value) {
                        return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
                    }
                    function isFunction(value) {
                        return typeof value == "function";
                    }
                    function isObject(value) {
                        return !!(value && objectTypes[typeof value]);
                    }
                    function isNaN(value) {
                        return isNumber(value) && value != +value;
                    }
                    function isNull(value) {
                        return value === null;
                    }
                    function isNumber(value) {
                        return typeof value == "number" || value && typeof value == "object" && toString.call(value) == numberClass || false;
                    }
                    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
                        if (!(value && toString.call(value) == objectClass)) {
                            return false;
                        }
                        var valueOf = value.valueOf, objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
                        return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
                    };
                    function isRegExp(value) {
                        return value && typeof value == "object" && toString.call(value) == regexpClass || false;
                    }
                    function isString(value) {
                        return typeof value == "string" || value && typeof value == "object" && toString.call(value) == stringClass || false;
                    }
                    function isUndefined(value) {
                        return typeof value == "undefined";
                    }
                    function mapValues(object, callback, thisArg) {
                        var result = {};
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwn(object, function(value, key, object) {
                            result[key] = callback(value, key, object);
                        });
                        return result;
                    }
                    function merge(object) {
                        var args = arguments, length = 2;
                        if (!isObject(object)) {
                            return object;
                        }
                        if (typeof args[2] != "number") {
                            length = args.length;
                        }
                        if (length > 3 && typeof args[length - 2] == "function") {
                            var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
                        } else if (length > 2 && typeof args[length - 1] == "function") {
                            callback = args[--length];
                        }
                        var sources = slice(arguments, 1, length), index = -1, stackA = getArray(), stackB = getArray();
                        while (++index < length) {
                            baseMerge(object, sources[index], callback, stackA, stackB);
                        }
                        releaseArray(stackA);
                        releaseArray(stackB);
                        return object;
                    }
                    function omit(object, callback, thisArg) {
                        var result = {};
                        if (typeof callback != "function") {
                            var props = [];
                            forIn(object, function(value, key) {
                                props.push(key);
                            });
                            props = baseDifference(props, baseFlatten(arguments, true, false, 1));
                            var index = -1, length = props.length;
                            while (++index < length) {
                                var key = props[index];
                                result[key] = object[key];
                            }
                        } else {
                            callback = lodash.createCallback(callback, thisArg, 3);
                            forIn(object, function(value, key, object) {
                                if (!callback(value, key, object)) {
                                    result[key] = value;
                                }
                            });
                        }
                        return result;
                    }
                    function pairs(object) {
                        var index = -1, props = keys(object), length = props.length, result = Array(length);
                        while (++index < length) {
                            var key = props[index];
                            result[index] = [ key, object[key] ];
                        }
                        return result;
                    }
                    function pick(object, callback, thisArg) {
                        var result = {};
                        if (typeof callback != "function") {
                            var index = -1, props = baseFlatten(arguments, true, false, 1), length = isObject(object) ? props.length : 0;
                            while (++index < length) {
                                var key = props[index];
                                if (key in object) {
                                    result[key] = object[key];
                                }
                            }
                        } else {
                            callback = lodash.createCallback(callback, thisArg, 3);
                            forIn(object, function(value, key, object) {
                                if (callback(value, key, object)) {
                                    result[key] = value;
                                }
                            });
                        }
                        return result;
                    }
                    function transform(object, callback, accumulator, thisArg) {
                        var isArr = isArray(object);
                        if (accumulator == null) {
                            if (isArr) {
                                accumulator = [];
                            } else {
                                var ctor = object && object.constructor, proto = ctor && ctor.prototype;
                                accumulator = baseCreate(proto);
                            }
                        }
                        if (callback) {
                            callback = lodash.createCallback(callback, thisArg, 4);
                            (isArr ? forEach : forOwn)(object, function(value, index, object) {
                                return callback(accumulator, value, index, object);
                            });
                        }
                        return accumulator;
                    }
                    function values(object) {
                        var index = -1, props = keys(object), length = props.length, result = Array(length);
                        while (++index < length) {
                            result[index] = object[props[index]];
                        }
                        return result;
                    }
                    function at(collection) {
                        var args = arguments, index = -1, props = baseFlatten(args, true, false, 1), length = args[2] && args[2][args[1]] === collection ? 1 : props.length, result = Array(length);
                        while (++index < length) {
                            result[index] = collection[props[index]];
                        }
                        return result;
                    }
                    function contains(collection, target, fromIndex) {
                        var index = -1, indexOf = getIndexOf(), length = collection ? collection.length : 0, result = false;
                        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
                        if (isArray(collection)) {
                            result = indexOf(collection, target, fromIndex) > -1;
                        } else if (typeof length == "number") {
                            result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
                        } else {
                            forOwn(collection, function(value) {
                                if (++index >= fromIndex) {
                                    return !(result = value === target);
                                }
                            });
                        }
                        return result;
                    }
                    var countBy = createAggregator(function(result, value, key) {
                        hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1;
                    });
                    function every(collection, callback, thisArg) {
                        var result = true;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                if (!(result = !!callback(collection[index], index, collection))) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                return result = !!callback(value, index, collection);
                            });
                        }
                        return result;
                    }
                    function filter(collection, callback, thisArg) {
                        var result = [];
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                var value = collection[index];
                                if (callback(value, index, collection)) {
                                    result.push(value);
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                if (callback(value, index, collection)) {
                                    result.push(value);
                                }
                            });
                        }
                        return result;
                    }
                    function find(collection, callback, thisArg) {
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                var value = collection[index];
                                if (callback(value, index, collection)) {
                                    return value;
                                }
                            }
                        } else {
                            var result;
                            forOwn(collection, function(value, index, collection) {
                                if (callback(value, index, collection)) {
                                    result = value;
                                    return false;
                                }
                            });
                            return result;
                        }
                    }
                    function findLast(collection, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forEachRight(collection, function(value, index, collection) {
                            if (callback(value, index, collection)) {
                                result = value;
                                return false;
                            }
                        });
                        return result;
                    }
                    function forEach(collection, callback, thisArg) {
                        var index = -1, length = collection ? collection.length : 0;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        if (typeof length == "number") {
                            while (++index < length) {
                                if (callback(collection[index], index, collection) === false) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, callback);
                        }
                        return collection;
                    }
                    function forEachRight(collection, callback, thisArg) {
                        var length = collection ? collection.length : 0;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        if (typeof length == "number") {
                            while (length--) {
                                if (callback(collection[length], length, collection) === false) {
                                    break;
                                }
                            }
                        } else {
                            var props = keys(collection);
                            length = props.length;
                            forOwn(collection, function(value, key, collection) {
                                key = props ? props[--length] : --length;
                                return callback(collection[key], key, collection);
                            });
                        }
                        return collection;
                    }
                    var groupBy = createAggregator(function(result, value, key) {
                        (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
                    });
                    var indexBy = createAggregator(function(result, value, key) {
                        result[key] = value;
                    });
                    function invoke(collection, methodName) {
                        var args = slice(arguments, 2), index = -1, isFunc = typeof methodName == "function", length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
                        forEach(collection, function(value) {
                            result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
                        });
                        return result;
                    }
                    function map(collection, callback, thisArg) {
                        var index = -1, length = collection ? collection.length : 0;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        if (typeof length == "number") {
                            var result = Array(length);
                            while (++index < length) {
                                result[index] = callback(collection[index], index, collection);
                            }
                        } else {
                            result = [];
                            forOwn(collection, function(value, key, collection) {
                                result[++index] = callback(value, key, collection);
                            });
                        }
                        return result;
                    }
                    function max(collection, callback, thisArg) {
                        var computed = -Infinity, result = computed;
                        if (typeof callback != "function" && thisArg && thisArg[callback] === collection) {
                            callback = null;
                        }
                        if (callback == null && isArray(collection)) {
                            var index = -1, length = collection.length;
                            while (++index < length) {
                                var value = collection[index];
                                if (value > result) {
                                    result = value;
                                }
                            }
                        } else {
                            callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                            forEach(collection, function(value, index, collection) {
                                var current = callback(value, index, collection);
                                if (current > computed) {
                                    computed = current;
                                    result = value;
                                }
                            });
                        }
                        return result;
                    }
                    function min(collection, callback, thisArg) {
                        var computed = Infinity, result = computed;
                        if (typeof callback != "function" && thisArg && thisArg[callback] === collection) {
                            callback = null;
                        }
                        if (callback == null && isArray(collection)) {
                            var index = -1, length = collection.length;
                            while (++index < length) {
                                var value = collection[index];
                                if (value < result) {
                                    result = value;
                                }
                            }
                        } else {
                            callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                            forEach(collection, function(value, index, collection) {
                                var current = callback(value, index, collection);
                                if (current < computed) {
                                    computed = current;
                                    result = value;
                                }
                            });
                        }
                        return result;
                    }
                    var pluck = map;
                    function reduce(collection, callback, accumulator, thisArg) {
                        if (!collection) return accumulator;
                        var noaccum = arguments.length < 3;
                        callback = lodash.createCallback(callback, thisArg, 4);
                        var index = -1, length = collection.length;
                        if (typeof length == "number") {
                            if (noaccum) {
                                accumulator = collection[++index];
                            }
                            while (++index < length) {
                                accumulator = callback(accumulator, collection[index], index, collection);
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
                            });
                        }
                        return accumulator;
                    }
                    function reduceRight(collection, callback, accumulator, thisArg) {
                        var noaccum = arguments.length < 3;
                        callback = lodash.createCallback(callback, thisArg, 4);
                        forEachRight(collection, function(value, index, collection) {
                            accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
                        });
                        return accumulator;
                    }
                    function reject(collection, callback, thisArg) {
                        callback = lodash.createCallback(callback, thisArg, 3);
                        return filter(collection, function(value, index, collection) {
                            return !callback(value, index, collection);
                        });
                    }
                    function sample(collection, n, guard) {
                        if (collection && typeof collection.length != "number") {
                            collection = values(collection);
                        }
                        if (n == null || guard) {
                            return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
                        }
                        var result = shuffle(collection);
                        result.length = nativeMin(nativeMax(0, n), result.length);
                        return result;
                    }
                    function shuffle(collection) {
                        var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
                        forEach(collection, function(value) {
                            var rand = baseRandom(0, ++index);
                            result[index] = result[rand];
                            result[rand] = value;
                        });
                        return result;
                    }
                    function size(collection) {
                        var length = collection ? collection.length : 0;
                        return typeof length == "number" ? length : keys(collection).length;
                    }
                    function some(collection, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                if (result = callback(collection[index], index, collection)) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                return !(result = callback(value, index, collection));
                            });
                        }
                        return !!result;
                    }
                    function sortBy(collection, callback, thisArg) {
                        var index = -1, isArr = isArray(callback), length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
                        if (!isArr) {
                            callback = lodash.createCallback(callback, thisArg, 3);
                        }
                        forEach(collection, function(value, key, collection) {
                            var object = result[++index] = getObject();
                            if (isArr) {
                                object.criteria = map(callback, function(key) {
                                    return value[key];
                                });
                            } else {
                                (object.criteria = getArray())[0] = callback(value, key, collection);
                            }
                            object.index = index;
                            object.value = value;
                        });
                        length = result.length;
                        result.sort(compareAscending);
                        while (length--) {
                            var object = result[length];
                            result[length] = object.value;
                            if (!isArr) {
                                releaseArray(object.criteria);
                            }
                            releaseObject(object);
                        }
                        return result;
                    }
                    function toArray(collection) {
                        if (collection && typeof collection.length == "number") {
                            return slice(collection);
                        }
                        return values(collection);
                    }
                    var where = filter;
                    function compact(array) {
                        var index = -1, length = array ? array.length : 0, result = [];
                        while (++index < length) {
                            var value = array[index];
                            if (value) {
                                result.push(value);
                            }
                        }
                        return result;
                    }
                    function difference(array) {
                        return baseDifference(array, baseFlatten(arguments, true, true, 1));
                    }
                    function findIndex(array, callback, thisArg) {
                        var index = -1, length = array ? array.length : 0;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (++index < length) {
                            if (callback(array[index], index, array)) {
                                return index;
                            }
                        }
                        return -1;
                    }
                    function findLastIndex(array, callback, thisArg) {
                        var length = array ? array.length : 0;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (length--) {
                            if (callback(array[length], length, array)) {
                                return length;
                            }
                        }
                        return -1;
                    }
                    function first(array, callback, thisArg) {
                        var n = 0, length = array ? array.length : 0;
                        if (typeof callback != "number" && callback != null) {
                            var index = -1;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (++index < length && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback;
                            if (n == null || thisArg) {
                                return array ? array[0] : undefined;
                            }
                        }
                        return slice(array, 0, nativeMin(nativeMax(0, n), length));
                    }
                    function flatten(array, isShallow, callback, thisArg) {
                        if (typeof isShallow != "boolean" && isShallow != null) {
                            thisArg = callback;
                            callback = typeof isShallow != "function" && thisArg && thisArg[isShallow] === array ? null : isShallow;
                            isShallow = false;
                        }
                        if (callback != null) {
                            array = map(array, callback, thisArg);
                        }
                        return baseFlatten(array, isShallow);
                    }
                    function indexOf(array, value, fromIndex) {
                        if (typeof fromIndex == "number") {
                            var length = array ? array.length : 0;
                            fromIndex = fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0;
                        } else if (fromIndex) {
                            var index = sortedIndex(array, value);
                            return array[index] === value ? index : -1;
                        }
                        return baseIndexOf(array, value, fromIndex);
                    }
                    function initial(array, callback, thisArg) {
                        var n = 0, length = array ? array.length : 0;
                        if (typeof callback != "number" && callback != null) {
                            var index = length;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (index-- && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback == null || thisArg ? 1 : callback || n;
                        }
                        return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
                    }
                    function intersection() {
                        var args = [], argsIndex = -1, argsLength = arguments.length, caches = getArray(), indexOf = getIndexOf(), trustIndexOf = indexOf === baseIndexOf, seen = getArray();
                        while (++argsIndex < argsLength) {
                            var value = arguments[argsIndex];
                            if (isArray(value) || isArguments(value)) {
                                args.push(value);
                                caches.push(trustIndexOf && value.length >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen));
                            }
                        }
                        var array = args[0], index = -1, length = array ? array.length : 0, result = [];
                        outer: while (++index < length) {
                            var cache = caches[0];
                            value = array[index];
                            if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                                argsIndex = argsLength;
                                (cache || seen).push(value);
                                while (--argsIndex) {
                                    cache = caches[argsIndex];
                                    if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                                        continue outer;
                                    }
                                }
                                result.push(value);
                            }
                        }
                        while (argsLength--) {
                            cache = caches[argsLength];
                            if (cache) {
                                releaseObject(cache);
                            }
                        }
                        releaseArray(caches);
                        releaseArray(seen);
                        return result;
                    }
                    function last(array, callback, thisArg) {
                        var n = 0, length = array ? array.length : 0;
                        if (typeof callback != "number" && callback != null) {
                            var index = length;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (index-- && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback;
                            if (n == null || thisArg) {
                                return array ? array[length - 1] : undefined;
                            }
                        }
                        return slice(array, nativeMax(0, length - n));
                    }
                    function lastIndexOf(array, value, fromIndex) {
                        var index = array ? array.length : 0;
                        if (typeof fromIndex == "number") {
                            index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
                        }
                        while (index--) {
                            if (array[index] === value) {
                                return index;
                            }
                        }
                        return -1;
                    }
                    function pull(array) {
                        var args = arguments, argsIndex = 0, argsLength = args.length, length = array ? array.length : 0;
                        while (++argsIndex < argsLength) {
                            var index = -1, value = args[argsIndex];
                            while (++index < length) {
                                if (array[index] === value) {
                                    splice.call(array, index--, 1);
                                    length--;
                                }
                            }
                        }
                        return array;
                    }
                    function range(start, end, step) {
                        start = +start || 0;
                        step = typeof step == "number" ? step : +step || 1;
                        if (end == null) {
                            end = start;
                            start = 0;
                        }
                        var index = -1, length = nativeMax(0, ceil((end - start) / (step || 1))), result = Array(length);
                        while (++index < length) {
                            result[index] = start;
                            start += step;
                        }
                        return result;
                    }
                    function remove(array, callback, thisArg) {
                        var index = -1, length = array ? array.length : 0, result = [];
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (++index < length) {
                            var value = array[index];
                            if (callback(value, index, array)) {
                                result.push(value);
                                splice.call(array, index--, 1);
                                length--;
                            }
                        }
                        return result;
                    }
                    function rest(array, callback, thisArg) {
                        if (typeof callback != "number" && callback != null) {
                            var n = 0, index = -1, length = array ? array.length : 0;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (++index < length && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback == null || thisArg ? 1 : nativeMax(0, callback);
                        }
                        return slice(array, n);
                    }
                    function sortedIndex(array, value, callback, thisArg) {
                        var low = 0, high = array ? array.length : low;
                        callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
                        value = callback(value);
                        while (low < high) {
                            var mid = low + high >>> 1;
                            callback(array[mid]) < value ? low = mid + 1 : high = mid;
                        }
                        return low;
                    }
                    function union() {
                        return baseUniq(baseFlatten(arguments, true, true));
                    }
                    function uniq(array, isSorted, callback, thisArg) {
                        if (typeof isSorted != "boolean" && isSorted != null) {
                            thisArg = callback;
                            callback = typeof isSorted != "function" && thisArg && thisArg[isSorted] === array ? null : isSorted;
                            isSorted = false;
                        }
                        if (callback != null) {
                            callback = lodash.createCallback(callback, thisArg, 3);
                        }
                        return baseUniq(array, isSorted, callback);
                    }
                    function without(array) {
                        return baseDifference(array, slice(arguments, 1));
                    }
                    function xor() {
                        var index = -1, length = arguments.length;
                        while (++index < length) {
                            var array = arguments[index];
                            if (isArray(array) || isArguments(array)) {
                                var result = result ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result))) : array;
                            }
                        }
                        return result || [];
                    }
                    function zip() {
                        var array = arguments.length > 1 ? arguments : arguments[0], index = -1, length = array ? max(pluck(array, "length")) : 0, result = Array(length < 0 ? 0 : length);
                        while (++index < length) {
                            result[index] = pluck(array, index);
                        }
                        return result;
                    }
                    function zipObject(keys, values) {
                        var index = -1, length = keys ? keys.length : 0, result = {};
                        if (!values && length && !isArray(keys[0])) {
                            values = [];
                        }
                        while (++index < length) {
                            var key = keys[index];
                            if (values) {
                                result[key] = values[index];
                            } else if (key) {
                                result[key[0]] = key[1];
                            }
                        }
                        return result;
                    }
                    function after(n, func) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        return function() {
                            if (--n < 1) {
                                return func.apply(this, arguments);
                            }
                        };
                    }
                    function bind(func, thisArg) {
                        return arguments.length > 2 ? createWrapper(func, 17, slice(arguments, 2), null, thisArg) : createWrapper(func, 1, null, null, thisArg);
                    }
                    function bindAll(object) {
                        var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object), index = -1, length = funcs.length;
                        while (++index < length) {
                            var key = funcs[index];
                            object[key] = createWrapper(object[key], 1, null, null, object);
                        }
                        return object;
                    }
                    function bindKey(object, key) {
                        return arguments.length > 2 ? createWrapper(key, 19, slice(arguments, 2), null, object) : createWrapper(key, 3, null, null, object);
                    }
                    function compose() {
                        var funcs = arguments, length = funcs.length;
                        while (length--) {
                            if (!isFunction(funcs[length])) {
                                throw new TypeError();
                            }
                        }
                        return function() {
                            var args = arguments, length = funcs.length;
                            while (length--) {
                                args = [ funcs[length].apply(this, args) ];
                            }
                            return args[0];
                        };
                    }
                    function curry(func, arity) {
                        arity = typeof arity == "number" ? arity : +arity || func.length;
                        return createWrapper(func, 4, null, null, null, arity);
                    }
                    function debounce(func, wait, options) {
                        var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = false, trailing = true;
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        wait = nativeMax(0, wait) || 0;
                        if (options === true) {
                            var leading = true;
                            trailing = false;
                        } else if (isObject(options)) {
                            leading = options.leading;
                            maxWait = "maxWait" in options && (nativeMax(wait, options.maxWait) || 0);
                            trailing = "trailing" in options ? options.trailing : trailing;
                        }
                        var delayed = function() {
                            var remaining = wait - (now() - stamp);
                            if (remaining <= 0) {
                                if (maxTimeoutId) {
                                    clearTimeout(maxTimeoutId);
                                }
                                var isCalled = trailingCall;
                                maxTimeoutId = timeoutId = trailingCall = undefined;
                                if (isCalled) {
                                    lastCalled = now();
                                    result = func.apply(thisArg, args);
                                    if (!timeoutId && !maxTimeoutId) {
                                        args = thisArg = null;
                                    }
                                }
                            } else {
                                timeoutId = setTimeout(delayed, remaining);
                            }
                        };
                        var maxDelayed = function() {
                            if (timeoutId) {
                                clearTimeout(timeoutId);
                            }
                            maxTimeoutId = timeoutId = trailingCall = undefined;
                            if (trailing || maxWait !== wait) {
                                lastCalled = now();
                                result = func.apply(thisArg, args);
                                if (!timeoutId && !maxTimeoutId) {
                                    args = thisArg = null;
                                }
                            }
                        };
                        return function() {
                            args = arguments;
                            stamp = now();
                            thisArg = this;
                            trailingCall = trailing && (timeoutId || !leading);
                            if (maxWait === false) {
                                var leadingCall = leading && !timeoutId;
                            } else {
                                if (!maxTimeoutId && !leading) {
                                    lastCalled = stamp;
                                }
                                var remaining = maxWait - (stamp - lastCalled), isCalled = remaining <= 0;
                                if (isCalled) {
                                    if (maxTimeoutId) {
                                        maxTimeoutId = clearTimeout(maxTimeoutId);
                                    }
                                    lastCalled = stamp;
                                    result = func.apply(thisArg, args);
                                } else if (!maxTimeoutId) {
                                    maxTimeoutId = setTimeout(maxDelayed, remaining);
                                }
                            }
                            if (isCalled && timeoutId) {
                                timeoutId = clearTimeout(timeoutId);
                            } else if (!timeoutId && wait !== maxWait) {
                                timeoutId = setTimeout(delayed, wait);
                            }
                            if (leadingCall) {
                                isCalled = true;
                                result = func.apply(thisArg, args);
                            }
                            if (isCalled && !timeoutId && !maxTimeoutId) {
                                args = thisArg = null;
                            }
                            return result;
                        };
                    }
                    function defer(func) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        var args = slice(arguments, 1);
                        return setTimeout(function() {
                            func.apply(undefined, args);
                        }, 1);
                    }
                    function delay(func, wait) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        var args = slice(arguments, 2);
                        return setTimeout(function() {
                            func.apply(undefined, args);
                        }, wait);
                    }
                    function memoize(func, resolver) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        var memoized = function() {
                            var cache = memoized.cache, key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
                            return hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = func.apply(this, arguments);
                        };
                        memoized.cache = {};
                        return memoized;
                    }
                    function once(func) {
                        var ran, result;
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        return function() {
                            if (ran) {
                                return result;
                            }
                            ran = true;
                            result = func.apply(this, arguments);
                            func = null;
                            return result;
                        };
                    }
                    function partial(func) {
                        return createWrapper(func, 16, slice(arguments, 1));
                    }
                    function partialRight(func) {
                        return createWrapper(func, 32, null, slice(arguments, 1));
                    }
                    function throttle(func, wait, options) {
                        var leading = true, trailing = true;
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        if (options === false) {
                            leading = false;
                        } else if (isObject(options)) {
                            leading = "leading" in options ? options.leading : leading;
                            trailing = "trailing" in options ? options.trailing : trailing;
                        }
                        debounceOptions.leading = leading;
                        debounceOptions.maxWait = wait;
                        debounceOptions.trailing = trailing;
                        return debounce(func, wait, debounceOptions);
                    }
                    function wrap(value, wrapper) {
                        return createWrapper(wrapper, 16, [ value ]);
                    }
                    function constant(value) {
                        return function() {
                            return value;
                        };
                    }
                    function createCallback(func, thisArg, argCount) {
                        var type = typeof func;
                        if (func == null || type == "function") {
                            return baseCreateCallback(func, thisArg, argCount);
                        }
                        if (type != "object") {
                            return property(func);
                        }
                        var props = keys(func), key = props[0], a = func[key];
                        if (props.length == 1 && a === a && !isObject(a)) {
                            return function(object) {
                                var b = object[key];
                                return a === b && (a !== 0 || 1 / a == 1 / b);
                            };
                        }
                        return function(object) {
                            var length = props.length, result = false;
                            while (length--) {
                                if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
                                    break;
                                }
                            }
                            return result;
                        };
                    }
                    function escape(string) {
                        return string == null ? "" : String(string).replace(reUnescapedHtml, escapeHtmlChar);
                    }
                    function identity(value) {
                        return value;
                    }
                    function mixin(object, source, options) {
                        var chain = true, methodNames = source && functions(source);
                        if (!source || !options && !methodNames.length) {
                            if (options == null) {
                                options = source;
                            }
                            ctor = lodashWrapper;
                            source = object;
                            object = lodash;
                            methodNames = functions(source);
                        }
                        if (options === false) {
                            chain = false;
                        } else if (isObject(options) && "chain" in options) {
                            chain = options.chain;
                        }
                        var ctor = object, isFunc = isFunction(ctor);
                        forEach(methodNames, function(methodName) {
                            var func = object[methodName] = source[methodName];
                            if (isFunc) {
                                ctor.prototype[methodName] = function() {
                                    var chainAll = this.__chain__, value = this.__wrapped__, args = [ value ];
                                    push.apply(args, arguments);
                                    var result = func.apply(object, args);
                                    if (chain || chainAll) {
                                        if (value === result && isObject(result)) {
                                            return this;
                                        }
                                        result = new ctor(result);
                                        result.__chain__ = chainAll;
                                    }
                                    return result;
                                };
                            }
                        });
                    }
                    function noConflict() {
                        context._ = oldDash;
                        return this;
                    }
                    function noop() {}
                    var now = isNative(now = Date.now) && now || function() {
                        return new Date().getTime();
                    };
                    var parseInt = nativeParseInt(whitespace + "08") == 8 ? nativeParseInt : function(value, radix) {
                        return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, "") : value, radix || 0);
                    };
                    function property(key) {
                        return function(object) {
                            return object[key];
                        };
                    }
                    function random(min, max, floating) {
                        var noMin = min == null, noMax = max == null;
                        if (floating == null) {
                            if (typeof min == "boolean" && noMax) {
                                floating = min;
                                min = 1;
                            } else if (!noMax && typeof max == "boolean") {
                                floating = max;
                                noMax = true;
                            }
                        }
                        if (noMin && noMax) {
                            max = 1;
                        }
                        min = +min || 0;
                        if (noMax) {
                            max = min;
                            min = 0;
                        } else {
                            max = +max || 0;
                        }
                        if (floating || min % 1 || max % 1) {
                            var rand = nativeRandom();
                            return nativeMin(min + rand * (max - min + parseFloat("1e-" + ((rand + "").length - 1))), max);
                        }
                        return baseRandom(min, max);
                    }
                    function result(object, key) {
                        if (object) {
                            var value = object[key];
                            return isFunction(value) ? object[key]() : value;
                        }
                    }
                    function template(text, data, options) {
                        var settings = lodash.templateSettings;
                        text = String(text || "");
                        options = defaults({}, options, settings);
                        var imports = defaults({}, options.imports, settings.imports), importsKeys = keys(imports), importsValues = values(imports);
                        var isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
                        var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
                        text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                            interpolateValue || (interpolateValue = esTemplateValue);
                            source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                            if (escapeValue) {
                                source += "' +\n__e(" + escapeValue + ") +\n'";
                            }
                            if (evaluateValue) {
                                isEvaluating = true;
                                source += "';\n" + evaluateValue + ";\n__p += '";
                            }
                            if (interpolateValue) {
                                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                            }
                            index = offset + match.length;
                            return match;
                        });
                        source += "';\n";
                        var variable = options.variable, hasVariable = variable;
                        if (!hasVariable) {
                            variable = "obj";
                            source = "with (" + variable + ") {\n" + source + "\n}\n";
                        }
                        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
                        source = "function(" + variable + ") {\n" + (hasVariable ? "" : variable + " || (" + variable + " = {});\n") + "var __t, __p = '', __e = _.escape" + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                        var sourceURL = "\n/*\n//# sourceURL=" + (options.sourceURL || "/lodash/template/source[" + templateCounter++ + "]") + "\n*/";
                        try {
                            var result = Function(importsKeys, "return " + source + sourceURL).apply(undefined, importsValues);
                        } catch (e) {
                            e.source = source;
                            throw e;
                        }
                        if (data) {
                            return result(data);
                        }
                        result.source = source;
                        return result;
                    }
                    function times(n, callback, thisArg) {
                        n = (n = +n) > -1 ? n : 0;
                        var index = -1, result = Array(n);
                        callback = baseCreateCallback(callback, thisArg, 1);
                        while (++index < n) {
                            result[index] = callback(index);
                        }
                        return result;
                    }
                    function unescape(string) {
                        return string == null ? "" : String(string).replace(reEscapedHtml, unescapeHtmlChar);
                    }
                    function uniqueId(prefix) {
                        var id = ++idCounter;
                        return String(prefix == null ? "" : prefix) + id;
                    }
                    function chain(value) {
                        value = new lodashWrapper(value);
                        value.__chain__ = true;
                        return value;
                    }
                    function tap(value, interceptor) {
                        interceptor(value);
                        return value;
                    }
                    function wrapperChain() {
                        this.__chain__ = true;
                        return this;
                    }
                    function wrapperToString() {
                        return String(this.__wrapped__);
                    }
                    function wrapperValueOf() {
                        return this.__wrapped__;
                    }
                    lodash.after = after;
                    lodash.assign = assign;
                    lodash.at = at;
                    lodash.bind = bind;
                    lodash.bindAll = bindAll;
                    lodash.bindKey = bindKey;
                    lodash.chain = chain;
                    lodash.compact = compact;
                    lodash.compose = compose;
                    lodash.constant = constant;
                    lodash.countBy = countBy;
                    lodash.create = create;
                    lodash.createCallback = createCallback;
                    lodash.curry = curry;
                    lodash.debounce = debounce;
                    lodash.defaults = defaults;
                    lodash.defer = defer;
                    lodash.delay = delay;
                    lodash.difference = difference;
                    lodash.filter = filter;
                    lodash.flatten = flatten;
                    lodash.forEach = forEach;
                    lodash.forEachRight = forEachRight;
                    lodash.forIn = forIn;
                    lodash.forInRight = forInRight;
                    lodash.forOwn = forOwn;
                    lodash.forOwnRight = forOwnRight;
                    lodash.functions = functions;
                    lodash.groupBy = groupBy;
                    lodash.indexBy = indexBy;
                    lodash.initial = initial;
                    lodash.intersection = intersection;
                    lodash.invert = invert;
                    lodash.invoke = invoke;
                    lodash.keys = keys;
                    lodash.map = map;
                    lodash.mapValues = mapValues;
                    lodash.max = max;
                    lodash.memoize = memoize;
                    lodash.merge = merge;
                    lodash.min = min;
                    lodash.omit = omit;
                    lodash.once = once;
                    lodash.pairs = pairs;
                    lodash.partial = partial;
                    lodash.partialRight = partialRight;
                    lodash.pick = pick;
                    lodash.pluck = pluck;
                    lodash.property = property;
                    lodash.pull = pull;
                    lodash.range = range;
                    lodash.reject = reject;
                    lodash.remove = remove;
                    lodash.rest = rest;
                    lodash.shuffle = shuffle;
                    lodash.sortBy = sortBy;
                    lodash.tap = tap;
                    lodash.throttle = throttle;
                    lodash.times = times;
                    lodash.toArray = toArray;
                    lodash.transform = transform;
                    lodash.union = union;
                    lodash.uniq = uniq;
                    lodash.values = values;
                    lodash.where = where;
                    lodash.without = without;
                    lodash.wrap = wrap;
                    lodash.xor = xor;
                    lodash.zip = zip;
                    lodash.zipObject = zipObject;
                    lodash.collect = map;
                    lodash.drop = rest;
                    lodash.each = forEach;
                    lodash.eachRight = forEachRight;
                    lodash.extend = assign;
                    lodash.methods = functions;
                    lodash.object = zipObject;
                    lodash.select = filter;
                    lodash.tail = rest;
                    lodash.unique = uniq;
                    lodash.unzip = zip;
                    mixin(lodash);
                    lodash.clone = clone;
                    lodash.cloneDeep = cloneDeep;
                    lodash.contains = contains;
                    lodash.escape = escape;
                    lodash.every = every;
                    lodash.find = find;
                    lodash.findIndex = findIndex;
                    lodash.findKey = findKey;
                    lodash.findLast = findLast;
                    lodash.findLastIndex = findLastIndex;
                    lodash.findLastKey = findLastKey;
                    lodash.has = has;
                    lodash.identity = identity;
                    lodash.indexOf = indexOf;
                    lodash.isArguments = isArguments;
                    lodash.isArray = isArray;
                    lodash.isBoolean = isBoolean;
                    lodash.isDate = isDate;
                    lodash.isElement = isElement;
                    lodash.isEmpty = isEmpty;
                    lodash.isEqual = isEqual;
                    lodash.isFinite = isFinite;
                    lodash.isFunction = isFunction;
                    lodash.isNaN = isNaN;
                    lodash.isNull = isNull;
                    lodash.isNumber = isNumber;
                    lodash.isObject = isObject;
                    lodash.isPlainObject = isPlainObject;
                    lodash.isRegExp = isRegExp;
                    lodash.isString = isString;
                    lodash.isUndefined = isUndefined;
                    lodash.lastIndexOf = lastIndexOf;
                    lodash.mixin = mixin;
                    lodash.noConflict = noConflict;
                    lodash.noop = noop;
                    lodash.now = now;
                    lodash.parseInt = parseInt;
                    lodash.random = random;
                    lodash.reduce = reduce;
                    lodash.reduceRight = reduceRight;
                    lodash.result = result;
                    lodash.runInContext = runInContext;
                    lodash.size = size;
                    lodash.some = some;
                    lodash.sortedIndex = sortedIndex;
                    lodash.template = template;
                    lodash.unescape = unescape;
                    lodash.uniqueId = uniqueId;
                    lodash.all = every;
                    lodash.any = some;
                    lodash.detect = find;
                    lodash.findWhere = find;
                    lodash.foldl = reduce;
                    lodash.foldr = reduceRight;
                    lodash.include = contains;
                    lodash.inject = reduce;
                    mixin(function() {
                        var source = {};
                        forOwn(lodash, function(func, methodName) {
                            if (!lodash.prototype[methodName]) {
                                source[methodName] = func;
                            }
                        });
                        return source;
                    }(), false);
                    lodash.first = first;
                    lodash.last = last;
                    lodash.sample = sample;
                    lodash.take = first;
                    lodash.head = first;
                    forOwn(lodash, function(func, methodName) {
                        var callbackable = methodName !== "sample";
                        if (!lodash.prototype[methodName]) {
                            lodash.prototype[methodName] = function(n, guard) {
                                var chainAll = this.__chain__, result = func(this.__wrapped__, n, guard);
                                return !chainAll && (n == null || guard && !(callbackable && typeof n == "function")) ? result : new lodashWrapper(result, chainAll);
                            };
                        }
                    });
                    lodash.VERSION = "2.4.1";
                    lodash.prototype.chain = wrapperChain;
                    lodash.prototype.toString = wrapperToString;
                    lodash.prototype.value = wrapperValueOf;
                    lodash.prototype.valueOf = wrapperValueOf;
                    forEach([ "join", "pop", "shift" ], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            var chainAll = this.__chain__, result = func.apply(this.__wrapped__, arguments);
                            return chainAll ? new lodashWrapper(result, chainAll) : result;
                        };
                    });
                    forEach([ "push", "reverse", "sort", "unshift" ], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            func.apply(this.__wrapped__, arguments);
                            return this;
                        };
                    });
                    forEach([ "concat", "slice", "splice" ], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
                        };
                    });
                    return lodash;
                }
                var _ = runInContext();
                if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
                    root._ = _;
                    define(function() {
                        return _;
                    });
                } else if (freeExports && freeModule) {
                    if (moduleExports) {
                        (freeModule.exports = _)._ = _;
                    } else {
                        freeExports._ = _;
                    }
                } else {
                    root._ = _;
                }
            }).call(this);
        }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {} ],
    2: [ function(require, module, exports) {
        var _;
        _ = require("lodash");
        Polymer("ui-fast-picker", {
            radiusChanged: function() {
                var items;
                items = this.querySelectorAll("ui-fast-picker-item:not([clone])");
                return _.each(items, function(_this) {
                    return function(item) {
                        return item.style.width = "" + _this.radius + "px";
                    };
                }(this));
            },
            startangleChanged: function() {
                return this.layout();
            },
            endangleChanged: function() {
                return this.layout();
            },
            setup: function() {
                var first, items, offset, selected, styleDef, topBorder, topPadding, width;
                this.toggled = false;
                this.startangle || (this.startangle = 0);
                this.endangle || (this.endangle = 360);
                if (!this.querySelector("[selected]")) {
                    first = this.querySelector("ui-fast-picker-item:not([clone])");
                    if (first) {
                        first.setAttribute("selected", "");
                    }
                    if (first) {
                        this.select(first);
                    }
                }
                selected = this.querySelector("[selected]");
                this.close();
                items = this.querySelectorAll("ui-fast-picker-item:not([clone])");
                selected = this.querySelector("ui-fast-picker-item[clone]");
                width = (selected != null ? selected.offsetWidth : void 0) || 0;
                first = items[0];
                styleDef = window.getComputedStyle(first, null);
                if (styleDef) {
                    topPadding = styleDef.getPropertyValue("padding-top");
                    topBorder = styleDef.getPropertyValue("border-top-width");
                    offset = Number(topBorder.replace("px", "")) + Number(topPadding.replace("px", ""));
                }
                return _.each(items, function(item, index) {
                    item.style.left = "" + width / 2 + "px";
                    item.style.webkitTransformOrigin = "0% 50%";
                    return item.style.top = "-" + offset + "px";
                });
            },
            close: function() {
                var background, items, _ref;
                items = this.querySelectorAll("ui-fast-picker-item:not([clone])");
                _.each(items, function(_this) {
                    return function(i) {
                        return i.setAttribute("hide", "");
                    };
                }(this));
                if ((_ref = this.querySelector("ui-fast-picker-item[clone]")) != null) {
                    _ref.removeAttribute("active");
                }
                background = this.shadowRoot.querySelector("background");
                return background.setAttribute("hide", "");
            },
            open: function() {
                var background, items, _ref;
                items = this.querySelectorAll("ui-fast-picker-item:not([clone])");
                _.each(items, function(_this) {
                    return function(i) {
                        return i.removeAttribute("hide");
                    };
                }(this));
                if ((_ref = this.querySelector("ui-fast-picker-item[clone]")) != null) {
                    _ref.setAttribute("active", "");
                }
                background = this.shadowRoot.querySelector("background");
                background.removeAttribute("hide");
                return this.layout();
            },
            toggle: function() {
                this.toggled = !this.toggled;
                if (this.toggled) {
                    return this.open();
                } else {
                    return this.close();
                }
            },
            select: function(node) {
                var clone, existingClone, rect;
                this.selected = node.value;
                existingClone = this.querySelector("ui-fast-picker-item[clone]");
                if (existingClone === node) {
                    return this.toggle();
                } else {
                    if (existingClone) {
                        this.removeChild(existingClone);
                    }
                    clone = node.cloneNode(true);
                    clone.removeAttribute("hide");
                    clone.removeAttribute("selected");
                    clone.removeAttribute("style");
                    clone.setAttribute("clone", "");
                    _.each(clone.children, function(child) {
                        child.removeAttribute("style");
                        return clone.removeAttribute("hide");
                    });
                    this.appendChild(clone);
                    rect = clone.getBoundingClientRect();
                    this.style.width = "" + rect.width + "px";
                    return this.style.height = "" + rect.height + "px";
                }
            },
            positionBackground: function(against) {
                var background, h, styleDef, w;
                background = this.shadowRoot.querySelector("background");
                background.style.width = "" + 2 * this.radius + "px";
                background.style.height = "" + 2 * this.radius + "px";
                styleDef = window.getComputedStyle(background, null);
                if (styleDef) {
                    w = Number(styleDef.getPropertyValue("width").replace("px", ""));
                    h = Number(styleDef.getPropertyValue("height").replace("px", ""));
                    background.style.left = "-" + (w / 2 - against.offsetWidth / 2) + "px";
                    return background.style.top = "-" + (h / 2 - against.offsetHeight / 2) + "px";
                }
            },
            layout: function() {
                var clone, deg, items, numItems, offsetAngle, totalAngle, width;
                items = this.querySelectorAll("ui-fast-picker-item:not([clone])");
                numItems = items.length;
                totalAngle = Math.abs(Number(this.startangle) - Number(this.endangle));
                if (totalAngle < 360) {
                    numItems -= 1;
                }
                deg = totalAngle / numItems;
                offsetAngle = Number(this.startangle);
                clone = this.querySelector("ui-fast-picker-item[clone]");
                width = (clone != null ? clone.offsetWidth : void 0) || 0;
                this.radius || (this.radius = (clone != null ? clone.offsetWidth : void 0) * 2.5);
                _.each(items, function(_this) {
                    return function(item, index) {
                        item.setAttribute("animate", item.style.left = "" + width / 2 + "px");
                        item.style.webkitTransform = "rotate(" + (deg * index + offsetAngle) + "deg) ";
                        item.style.zIndex = items.length - index;
                        return _.each(item.children, function(child) {
                            return child.style.webkitTransform = "rotate(-" + (deg * index + offsetAngle) + "deg)";
                        });
                    };
                }(this));
                if (clone) {
                    return this.positionBackground(clone);
                }
            },
            observeChildren: function(fn) {
                fn.bind(this)();
                return this.onMutation(this, function(_this) {
                    return function() {
                        return _this.observeChildren(fn);
                    };
                }(this));
            },
            selectHandler: function(event) {
                return this.select(event.target);
            },
            attached: function() {
                this.observeChildren(this.setup);
                return this.setup();
            }
        });
    }, {
        lodash: 1
    } ]
}, {}, [ 2 ]);</script>
</polymer-element>

<polymer-element name="ui-fast-picker-item" attributes="selected value" on-click="{{clickHandler}}" on-mousedown="{{pointerdown}}" on-mouseup="{{pointerup}}">
<template>
  <style>.hide {
  display: none !important;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(0, 0, 0, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease;
  -webkit-transition: opacity 0.2s ease;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease, opacity 0.2s ease;
  -webkit-transition: height 0.2s ease, opacity 0.2s ease;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
.sheen {
  background-image: linear-gradient(rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.1));
}
:host {
  position: absolute;
  box-sizing: border-box;
  text-align: right;
  visibility: visible;
  opacity: 1;
}
:host([animate]) {
  transition: 0.2s ease;
  -webkit-transition: 0.2s ease;
}
:host([clone]) {
  position: relative;
  display: inline-block;
  text-align: left;
  z-index: initial;
}
:host(:not([clone])) {
  background: rgba(0, 0, 0, 0.33);
  box-shadow: 0px 0px 1px 1px rgba(0, 0, 0, 0.1) inset;
  -webkit-box-shadow: 0px 0px 1px 1px rgba(0, 0, 0, 0.1) inset;
  padding-right: 0.3em;
}
:host([active]) {
  z-index: 99999;
}
:host([hide]) {
  transform: rotate(0rad) !important;
  -webkit-transform: rotate(0rad) !important;
  visibility: hidden;
  opacity: 0;
}
section[pressed] {
  transition: 0.2s ease;
  -webkit-transition: 0.2s ease;
  transform: scale(0.95, 0.95);
  -webkit-transform: scale(0.95, 0.95);
}
</style>
  <background></background>
  <section id="button">
    <content></content>
  </section>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-fast-picker/src/ui-fast-picker-item.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        Polymer("ui-fast-picker-item", {
            selectedChanged: function(oldVal, newVal) {
                if (this.hasAttribute("selected")) {
                    return this.fire("select", this.value);
                }
            },
            clickHandler: function(event) {
                return this.fire("select");
            },
            pointerdown: function() {
                return this.$.button.setAttribute("pressed", "");
            },
            pointerup: function() {
                return this.$.button.removeAttribute("pressed");
            }
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>

<polymer-element name="ui-input" attributes="value multiline icon iconAnimation placeholder disabled type autofocus">
<template>
  <style>.hide {
  display: none !important;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(0, 0, 0, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease;
  -webkit-transition: opacity 0.2s ease;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease, opacity 0.2s ease;
  -webkit-transition: height 0.2s ease, opacity 0.2s ease;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
.sheen {
  background-image: linear-gradient(rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.1));
}
.fa {
  display: inline-block;
  font-family: FontAwesome;
  font-style: normal;
  font-weight: normal;
  line-height: 1;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
/* makes the font 33% larger relative to the icon container */
.fa-lg {
  font-size: 1.33333333em;
  line-height: 0.75em;
  vertical-align: -15%;
}
.fa-2x {
  font-size: 2em;
}
.fa-3x {
  font-size: 3em;
}
.fa-4x {
  font-size: 4em;
}
.fa-5x {
  font-size: 5em;
}
.fa-fw {
  width: 1.28571429em;
  text-align: center;
}
.fa-ul {
  padding-left: 0;
  margin-left: 2.14285714em;
  list-style-type: none;
}
.fa-ul > li {
  position: relative;
}
.fa-li {
  position: absolute;
  left: -2.14285714em;
  width: 2.14285714em;
  top: 0.14285714em;
  text-align: center;
}
.fa-li.fa-lg {
  left: -1.85714286em;
}
.fa-border {
  padding: .2em .25em .15em;
  border: solid 0.08em #eeeeee;
  border-radius: .1em;
}
.pull-right {
  float: right;
}
.pull-left {
  float: left;
}
.fa.pull-left {
  margin-right: .3em;
}
.fa.pull-right {
  margin-left: .3em;
}
.fa-spin {
  -webkit-animation: spin 2s infinite linear;
  -moz-animation: spin 2s infinite linear;
  -o-animation: spin 2s infinite linear;
  animation: spin 2s infinite linear;
}
@-moz-keyframes spin {
  0% {
    -moz-transform: rotate(0deg);
  }
  100% {
    -moz-transform: rotate(359deg);
  }
}
@-webkit-keyframes spin {
  0% {
    -webkit-transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(359deg);
  }
}
@-o-keyframes spin {
  0% {
    -o-transform: rotate(0deg);
  }
  100% {
    -o-transform: rotate(359deg);
  }
}
@keyframes spin {
  0% {
    -webkit-transform: rotate(0deg);
    transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(359deg);
    transform: rotate(359deg);
  }
}
.fa-rotate-90 {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=1);
  -webkit-transform: rotate(90deg);
  -moz-transform: rotate(90deg);
  -ms-transform: rotate(90deg);
  -o-transform: rotate(90deg);
  transform: rotate(90deg);
}
.fa-rotate-180 {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=2);
  -webkit-transform: rotate(180deg);
  -moz-transform: rotate(180deg);
  -ms-transform: rotate(180deg);
  -o-transform: rotate(180deg);
  transform: rotate(180deg);
}
.fa-rotate-270 {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=3);
  -webkit-transform: rotate(270deg);
  -moz-transform: rotate(270deg);
  -ms-transform: rotate(270deg);
  -o-transform: rotate(270deg);
  transform: rotate(270deg);
}
.fa-flip-horizontal {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1);
  -webkit-transform: scale(-1, 1);
  -moz-transform: scale(-1, 1);
  -ms-transform: scale(-1, 1);
  -o-transform: scale(-1, 1);
  transform: scale(-1, 1);
}
.fa-flip-vertical {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1);
  -webkit-transform: scale(1, -1);
  -moz-transform: scale(1, -1);
  -ms-transform: scale(1, -1);
  -o-transform: scale(1, -1);
  transform: scale(1, -1);
}
.fa-stack {
  position: relative;
  display: inline-block;
  width: 2em;
  height: 2em;
  line-height: 2em;
  vertical-align: middle;
}
.fa-stack-1x,
.fa-stack-2x {
  position: absolute;
  left: 0;
  width: 100%;
  text-align: center;
}
.fa-stack-1x {
  line-height: inherit;
}
.fa-stack-2x {
  font-size: 2em;
}
.fa-inverse {
  color: #ffffff;
}
/* Font Awesome uses the Unicode Private Use Area (PUA) to ensure screen
   readers do not read off random characters that represent icons */
.fa-glass:before {
  content: "\f000";
}
.fa-music:before {
  content: "\f001";
}
.fa-search:before {
  content: "\f002";
}
.fa-envelope-o:before {
  content: "\f003";
}
.fa-heart:before {
  content: "\f004";
}
.fa-star:before {
  content: "\f005";
}
.fa-star-o:before {
  content: "\f006";
}
.fa-user:before {
  content: "\f007";
}
.fa-film:before {
  content: "\f008";
}
.fa-th-large:before {
  content: "\f009";
}
.fa-th:before {
  content: "\f00a";
}
.fa-th-list:before {
  content: "\f00b";
}
.fa-check:before {
  content: "\f00c";
}
.fa-times:before {
  content: "\f00d";
}
.fa-search-plus:before {
  content: "\f00e";
}
.fa-search-minus:before {
  content: "\f010";
}
.fa-power-off:before {
  content: "\f011";
}
.fa-signal:before {
  content: "\f012";
}
.fa-gear:before,
.fa-cog:before {
  content: "\f013";
}
.fa-trash-o:before {
  content: "\f014";
}
.fa-home:before {
  content: "\f015";
}
.fa-file-o:before {
  content: "\f016";
}
.fa-clock-o:before {
  content: "\f017";
}
.fa-road:before {
  content: "\f018";
}
.fa-download:before {
  content: "\f019";
}
.fa-arrow-circle-o-down:before {
  content: "\f01a";
}
.fa-arrow-circle-o-up:before {
  content: "\f01b";
}
.fa-inbox:before {
  content: "\f01c";
}
.fa-play-circle-o:before {
  content: "\f01d";
}
.fa-rotate-right:before,
.fa-repeat:before {
  content: "\f01e";
}
.fa-refresh:before {
  content: "\f021";
}
.fa-list-alt:before {
  content: "\f022";
}
.fa-lock:before {
  content: "\f023";
}
.fa-flag:before {
  content: "\f024";
}
.fa-headphones:before {
  content: "\f025";
}
.fa-volume-off:before {
  content: "\f026";
}
.fa-volume-down:before {
  content: "\f027";
}
.fa-volume-up:before {
  content: "\f028";
}
.fa-qrcode:before {
  content: "\f029";
}
.fa-barcode:before {
  content: "\f02a";
}
.fa-tag:before {
  content: "\f02b";
}
.fa-tags:before {
  content: "\f02c";
}
.fa-book:before {
  content: "\f02d";
}
.fa-bookmark:before {
  content: "\f02e";
}
.fa-print:before {
  content: "\f02f";
}
.fa-camera:before {
  content: "\f030";
}
.fa-font:before {
  content: "\f031";
}
.fa-bold:before {
  content: "\f032";
}
.fa-italic:before {
  content: "\f033";
}
.fa-text-height:before {
  content: "\f034";
}
.fa-text-width:before {
  content: "\f035";
}
.fa-align-left:before {
  content: "\f036";
}
.fa-align-center:before {
  content: "\f037";
}
.fa-align-right:before {
  content: "\f038";
}
.fa-align-justify:before {
  content: "\f039";
}
.fa-list:before {
  content: "\f03a";
}
.fa-dedent:before,
.fa-outdent:before {
  content: "\f03b";
}
.fa-indent:before {
  content: "\f03c";
}
.fa-video-camera:before {
  content: "\f03d";
}
.fa-photo:before,
.fa-image:before,
.fa-picture-o:before {
  content: "\f03e";
}
.fa-pencil:before {
  content: "\f040";
}
.fa-map-marker:before {
  content: "\f041";
}
.fa-adjust:before {
  content: "\f042";
}
.fa-tint:before {
  content: "\f043";
}
.fa-edit:before,
.fa-pencil-square-o:before {
  content: "\f044";
}
.fa-share-square-o:before {
  content: "\f045";
}
.fa-check-square-o:before {
  content: "\f046";
}
.fa-arrows:before {
  content: "\f047";
}
.fa-step-backward:before {
  content: "\f048";
}
.fa-fast-backward:before {
  content: "\f049";
}
.fa-backward:before {
  content: "\f04a";
}
.fa-play:before {
  content: "\f04b";
}
.fa-pause:before {
  content: "\f04c";
}
.fa-stop:before {
  content: "\f04d";
}
.fa-forward:before {
  content: "\f04e";
}
.fa-fast-forward:before {
  content: "\f050";
}
.fa-step-forward:before {
  content: "\f051";
}
.fa-eject:before {
  content: "\f052";
}
.fa-chevron-left:before {
  content: "\f053";
}
.fa-chevron-right:before {
  content: "\f054";
}
.fa-plus-circle:before {
  content: "\f055";
}
.fa-minus-circle:before {
  content: "\f056";
}
.fa-times-circle:before {
  content: "\f057";
}
.fa-check-circle:before {
  content: "\f058";
}
.fa-question-circle:before {
  content: "\f059";
}
.fa-info-circle:before {
  content: "\f05a";
}
.fa-crosshairs:before {
  content: "\f05b";
}
.fa-times-circle-o:before {
  content: "\f05c";
}
.fa-check-circle-o:before {
  content: "\f05d";
}
.fa-ban:before {
  content: "\f05e";
}
.fa-arrow-left:before {
  content: "\f060";
}
.fa-arrow-right:before {
  content: "\f061";
}
.fa-arrow-up:before {
  content: "\f062";
}
.fa-arrow-down:before {
  content: "\f063";
}
.fa-mail-forward:before,
.fa-share:before {
  content: "\f064";
}
.fa-expand:before {
  content: "\f065";
}
.fa-compress:before {
  content: "\f066";
}
.fa-plus:before {
  content: "\f067";
}
.fa-minus:before {
  content: "\f068";
}
.fa-asterisk:before {
  content: "\f069";
}
.fa-exclamation-circle:before {
  content: "\f06a";
}
.fa-gift:before {
  content: "\f06b";
}
.fa-leaf:before {
  content: "\f06c";
}
.fa-fire:before {
  content: "\f06d";
}
.fa-eye:before {
  content: "\f06e";
}
.fa-eye-slash:before {
  content: "\f070";
}
.fa-warning:before,
.fa-exclamation-triangle:before {
  content: "\f071";
}
.fa-plane:before {
  content: "\f072";
}
.fa-calendar:before {
  content: "\f073";
}
.fa-random:before {
  content: "\f074";
}
.fa-comment:before {
  content: "\f075";
}
.fa-magnet:before {
  content: "\f076";
}
.fa-chevron-up:before {
  content: "\f077";
}
.fa-chevron-down:before {
  content: "\f078";
}
.fa-retweet:before {
  content: "\f079";
}
.fa-shopping-cart:before {
  content: "\f07a";
}
.fa-folder:before {
  content: "\f07b";
}
.fa-folder-open:before {
  content: "\f07c";
}
.fa-arrows-v:before {
  content: "\f07d";
}
.fa-arrows-h:before {
  content: "\f07e";
}
.fa-bar-chart-o:before {
  content: "\f080";
}
.fa-twitter-square:before {
  content: "\f081";
}
.fa-facebook-square:before {
  content: "\f082";
}
.fa-camera-retro:before {
  content: "\f083";
}
.fa-key:before {
  content: "\f084";
}
.fa-gears:before,
.fa-cogs:before {
  content: "\f085";
}
.fa-comments:before {
  content: "\f086";
}
.fa-thumbs-o-up:before {
  content: "\f087";
}
.fa-thumbs-o-down:before {
  content: "\f088";
}
.fa-star-half:before {
  content: "\f089";
}
.fa-heart-o:before {
  content: "\f08a";
}
.fa-sign-out:before {
  content: "\f08b";
}
.fa-linkedin-square:before {
  content: "\f08c";
}
.fa-thumb-tack:before {
  content: "\f08d";
}
.fa-external-link:before {
  content: "\f08e";
}
.fa-sign-in:before {
  content: "\f090";
}
.fa-trophy:before {
  content: "\f091";
}
.fa-github-square:before {
  content: "\f092";
}
.fa-upload:before {
  content: "\f093";
}
.fa-lemon-o:before {
  content: "\f094";
}
.fa-phone:before {
  content: "\f095";
}
.fa-square-o:before {
  content: "\f096";
}
.fa-bookmark-o:before {
  content: "\f097";
}
.fa-phone-square:before {
  content: "\f098";
}
.fa-twitter:before {
  content: "\f099";
}
.fa-facebook:before {
  content: "\f09a";
}
.fa-github:before {
  content: "\f09b";
}
.fa-unlock:before {
  content: "\f09c";
}
.fa-credit-card:before {
  content: "\f09d";
}
.fa-rss:before {
  content: "\f09e";
}
.fa-hdd-o:before {
  content: "\f0a0";
}
.fa-bullhorn:before {
  content: "\f0a1";
}
.fa-bell:before {
  content: "\f0f3";
}
.fa-certificate:before {
  content: "\f0a3";
}
.fa-hand-o-right:before {
  content: "\f0a4";
}
.fa-hand-o-left:before {
  content: "\f0a5";
}
.fa-hand-o-up:before {
  content: "\f0a6";
}
.fa-hand-o-down:before {
  content: "\f0a7";
}
.fa-arrow-circle-left:before {
  content: "\f0a8";
}
.fa-arrow-circle-right:before {
  content: "\f0a9";
}
.fa-arrow-circle-up:before {
  content: "\f0aa";
}
.fa-arrow-circle-down:before {
  content: "\f0ab";
}
.fa-globe:before {
  content: "\f0ac";
}
.fa-wrench:before {
  content: "\f0ad";
}
.fa-tasks:before {
  content: "\f0ae";
}
.fa-filter:before {
  content: "\f0b0";
}
.fa-briefcase:before {
  content: "\f0b1";
}
.fa-arrows-alt:before {
  content: "\f0b2";
}
.fa-group:before,
.fa-users:before {
  content: "\f0c0";
}
.fa-chain:before,
.fa-link:before {
  content: "\f0c1";
}
.fa-cloud:before {
  content: "\f0c2";
}
.fa-flask:before {
  content: "\f0c3";
}
.fa-cut:before,
.fa-scissors:before {
  content: "\f0c4";
}
.fa-copy:before,
.fa-files-o:before {
  content: "\f0c5";
}
.fa-paperclip:before {
  content: "\f0c6";
}
.fa-save:before,
.fa-floppy-o:before {
  content: "\f0c7";
}
.fa-square:before {
  content: "\f0c8";
}
.fa-navicon:before,
.fa-reorder:before,
.fa-bars:before {
  content: "\f0c9";
}
.fa-list-ul:before {
  content: "\f0ca";
}
.fa-list-ol:before {
  content: "\f0cb";
}
.fa-strikethrough:before {
  content: "\f0cc";
}
.fa-underline:before {
  content: "\f0cd";
}
.fa-table:before {
  content: "\f0ce";
}
.fa-magic:before {
  content: "\f0d0";
}
.fa-truck:before {
  content: "\f0d1";
}
.fa-pinterest:before {
  content: "\f0d2";
}
.fa-pinterest-square:before {
  content: "\f0d3";
}
.fa-google-plus-square:before {
  content: "\f0d4";
}
.fa-google-plus:before {
  content: "\f0d5";
}
.fa-money:before {
  content: "\f0d6";
}
.fa-caret-down:before {
  content: "\f0d7";
}
.fa-caret-up:before {
  content: "\f0d8";
}
.fa-caret-left:before {
  content: "\f0d9";
}
.fa-caret-right:before {
  content: "\f0da";
}
.fa-columns:before {
  content: "\f0db";
}
.fa-unsorted:before,
.fa-sort:before {
  content: "\f0dc";
}
.fa-sort-down:before,
.fa-sort-desc:before {
  content: "\f0dd";
}
.fa-sort-up:before,
.fa-sort-asc:before {
  content: "\f0de";
}
.fa-envelope:before {
  content: "\f0e0";
}
.fa-linkedin:before {
  content: "\f0e1";
}
.fa-rotate-left:before,
.fa-undo:before {
  content: "\f0e2";
}
.fa-legal:before,
.fa-gavel:before {
  content: "\f0e3";
}
.fa-dashboard:before,
.fa-tachometer:before {
  content: "\f0e4";
}
.fa-comment-o:before {
  content: "\f0e5";
}
.fa-comments-o:before {
  content: "\f0e6";
}
.fa-flash:before,
.fa-bolt:before {
  content: "\f0e7";
}
.fa-sitemap:before {
  content: "\f0e8";
}
.fa-umbrella:before {
  content: "\f0e9";
}
.fa-paste:before,
.fa-clipboard:before {
  content: "\f0ea";
}
.fa-lightbulb-o:before {
  content: "\f0eb";
}
.fa-exchange:before {
  content: "\f0ec";
}
.fa-cloud-download:before {
  content: "\f0ed";
}
.fa-cloud-upload:before {
  content: "\f0ee";
}
.fa-user-md:before {
  content: "\f0f0";
}
.fa-stethoscope:before {
  content: "\f0f1";
}
.fa-suitcase:before {
  content: "\f0f2";
}
.fa-bell-o:before {
  content: "\f0a2";
}
.fa-coffee:before {
  content: "\f0f4";
}
.fa-cutlery:before {
  content: "\f0f5";
}
.fa-file-text-o:before {
  content: "\f0f6";
}
.fa-building-o:before {
  content: "\f0f7";
}
.fa-hospital-o:before {
  content: "\f0f8";
}
.fa-ambulance:before {
  content: "\f0f9";
}
.fa-medkit:before {
  content: "\f0fa";
}
.fa-fighter-jet:before {
  content: "\f0fb";
}
.fa-beer:before {
  content: "\f0fc";
}
.fa-h-square:before {
  content: "\f0fd";
}
.fa-plus-square:before {
  content: "\f0fe";
}
.fa-angle-double-left:before {
  content: "\f100";
}
.fa-angle-double-right:before {
  content: "\f101";
}
.fa-angle-double-up:before {
  content: "\f102";
}
.fa-angle-double-down:before {
  content: "\f103";
}
.fa-angle-left:before {
  content: "\f104";
}
.fa-angle-right:before {
  content: "\f105";
}
.fa-angle-up:before {
  content: "\f106";
}
.fa-angle-down:before {
  content: "\f107";
}
.fa-desktop:before {
  content: "\f108";
}
.fa-laptop:before {
  content: "\f109";
}
.fa-tablet:before {
  content: "\f10a";
}
.fa-mobile-phone:before,
.fa-mobile:before {
  content: "\f10b";
}
.fa-circle-o:before {
  content: "\f10c";
}
.fa-quote-left:before {
  content: "\f10d";
}
.fa-quote-right:before {
  content: "\f10e";
}
.fa-spinner:before {
  content: "\f110";
}
.fa-circle:before {
  content: "\f111";
}
.fa-mail-reply:before,
.fa-reply:before {
  content: "\f112";
}
.fa-github-alt:before {
  content: "\f113";
}
.fa-folder-o:before {
  content: "\f114";
}
.fa-folder-open-o:before {
  content: "\f115";
}
.fa-smile-o:before {
  content: "\f118";
}
.fa-frown-o:before {
  content: "\f119";
}
.fa-meh-o:before {
  content: "\f11a";
}
.fa-gamepad:before {
  content: "\f11b";
}
.fa-keyboard-o:before {
  content: "\f11c";
}
.fa-flag-o:before {
  content: "\f11d";
}
.fa-flag-checkered:before {
  content: "\f11e";
}
.fa-terminal:before {
  content: "\f120";
}
.fa-code:before {
  content: "\f121";
}
.fa-mail-reply-all:before,
.fa-reply-all:before {
  content: "\f122";
}
.fa-star-half-empty:before,
.fa-star-half-full:before,
.fa-star-half-o:before {
  content: "\f123";
}
.fa-location-arrow:before {
  content: "\f124";
}
.fa-crop:before {
  content: "\f125";
}
.fa-code-fork:before {
  content: "\f126";
}
.fa-unlink:before,
.fa-chain-broken:before {
  content: "\f127";
}
.fa-question:before {
  content: "\f128";
}
.fa-info:before {
  content: "\f129";
}
.fa-exclamation:before {
  content: "\f12a";
}
.fa-superscript:before {
  content: "\f12b";
}
.fa-subscript:before {
  content: "\f12c";
}
.fa-eraser:before {
  content: "\f12d";
}
.fa-puzzle-piece:before {
  content: "\f12e";
}
.fa-microphone:before {
  content: "\f130";
}
.fa-microphone-slash:before {
  content: "\f131";
}
.fa-shield:before {
  content: "\f132";
}
.fa-calendar-o:before {
  content: "\f133";
}
.fa-fire-extinguisher:before {
  content: "\f134";
}
.fa-rocket:before {
  content: "\f135";
}
.fa-maxcdn:before {
  content: "\f136";
}
.fa-chevron-circle-left:before {
  content: "\f137";
}
.fa-chevron-circle-right:before {
  content: "\f138";
}
.fa-chevron-circle-up:before {
  content: "\f139";
}
.fa-chevron-circle-down:before {
  content: "\f13a";
}
.fa-html5:before {
  content: "\f13b";
}
.fa-css3:before {
  content: "\f13c";
}
.fa-anchor:before {
  content: "\f13d";
}
.fa-unlock-alt:before {
  content: "\f13e";
}
.fa-bullseye:before {
  content: "\f140";
}
.fa-ellipsis-h:before {
  content: "\f141";
}
.fa-ellipsis-v:before {
  content: "\f142";
}
.fa-rss-square:before {
  content: "\f143";
}
.fa-play-circle:before {
  content: "\f144";
}
.fa-ticket:before {
  content: "\f145";
}
.fa-minus-square:before {
  content: "\f146";
}
.fa-minus-square-o:before {
  content: "\f147";
}
.fa-level-up:before {
  content: "\f148";
}
.fa-level-down:before {
  content: "\f149";
}
.fa-check-square:before {
  content: "\f14a";
}
.fa-pencil-square:before {
  content: "\f14b";
}
.fa-external-link-square:before {
  content: "\f14c";
}
.fa-share-square:before {
  content: "\f14d";
}
.fa-compass:before {
  content: "\f14e";
}
.fa-toggle-down:before,
.fa-caret-square-o-down:before {
  content: "\f150";
}
.fa-toggle-up:before,
.fa-caret-square-o-up:before {
  content: "\f151";
}
.fa-toggle-right:before,
.fa-caret-square-o-right:before {
  content: "\f152";
}
.fa-euro:before,
.fa-eur:before {
  content: "\f153";
}
.fa-gbp:before {
  content: "\f154";
}
.fa-dollar:before,
.fa-usd:before {
  content: "\f155";
}
.fa-rupee:before,
.fa-inr:before {
  content: "\f156";
}
.fa-cny:before,
.fa-rmb:before,
.fa-yen:before,
.fa-jpy:before {
  content: "\f157";
}
.fa-ruble:before,
.fa-rouble:before,
.fa-rub:before {
  content: "\f158";
}
.fa-won:before,
.fa-krw:before {
  content: "\f159";
}
.fa-bitcoin:before,
.fa-btc:before {
  content: "\f15a";
}
.fa-file:before {
  content: "\f15b";
}
.fa-file-text:before {
  content: "\f15c";
}
.fa-sort-alpha-asc:before {
  content: "\f15d";
}
.fa-sort-alpha-desc:before {
  content: "\f15e";
}
.fa-sort-amount-asc:before {
  content: "\f160";
}
.fa-sort-amount-desc:before {
  content: "\f161";
}
.fa-sort-numeric-asc:before {
  content: "\f162";
}
.fa-sort-numeric-desc:before {
  content: "\f163";
}
.fa-thumbs-up:before {
  content: "\f164";
}
.fa-thumbs-down:before {
  content: "\f165";
}
.fa-youtube-square:before {
  content: "\f166";
}
.fa-youtube:before {
  content: "\f167";
}
.fa-xing:before {
  content: "\f168";
}
.fa-xing-square:before {
  content: "\f169";
}
.fa-youtube-play:before {
  content: "\f16a";
}
.fa-dropbox:before {
  content: "\f16b";
}
.fa-stack-overflow:before {
  content: "\f16c";
}
.fa-instagram:before {
  content: "\f16d";
}
.fa-flickr:before {
  content: "\f16e";
}
.fa-adn:before {
  content: "\f170";
}
.fa-bitbucket:before {
  content: "\f171";
}
.fa-bitbucket-square:before {
  content: "\f172";
}
.fa-tumblr:before {
  content: "\f173";
}
.fa-tumblr-square:before {
  content: "\f174";
}
.fa-long-arrow-down:before {
  content: "\f175";
}
.fa-long-arrow-up:before {
  content: "\f176";
}
.fa-long-arrow-left:before {
  content: "\f177";
}
.fa-long-arrow-right:before {
  content: "\f178";
}
.fa-apple:before {
  content: "\f179";
}
.fa-windows:before {
  content: "\f17a";
}
.fa-android:before {
  content: "\f17b";
}
.fa-linux:before {
  content: "\f17c";
}
.fa-dribbble:before {
  content: "\f17d";
}
.fa-skype:before {
  content: "\f17e";
}
.fa-foursquare:before {
  content: "\f180";
}
.fa-trello:before {
  content: "\f181";
}
.fa-female:before {
  content: "\f182";
}
.fa-male:before {
  content: "\f183";
}
.fa-gittip:before {
  content: "\f184";
}
.fa-sun-o:before {
  content: "\f185";
}
.fa-moon-o:before {
  content: "\f186";
}
.fa-archive:before {
  content: "\f187";
}
.fa-bug:before {
  content: "\f188";
}
.fa-vk:before {
  content: "\f189";
}
.fa-weibo:before {
  content: "\f18a";
}
.fa-renren:before {
  content: "\f18b";
}
.fa-pagelines:before {
  content: "\f18c";
}
.fa-stack-exchange:before {
  content: "\f18d";
}
.fa-arrow-circle-o-right:before {
  content: "\f18e";
}
.fa-arrow-circle-o-left:before {
  content: "\f190";
}
.fa-toggle-left:before,
.fa-caret-square-o-left:before {
  content: "\f191";
}
.fa-dot-circle-o:before {
  content: "\f192";
}
.fa-wheelchair:before {
  content: "\f193";
}
.fa-vimeo-square:before {
  content: "\f194";
}
.fa-turkish-lira:before,
.fa-try:before {
  content: "\f195";
}
.fa-plus-square-o:before {
  content: "\f196";
}
.fa-space-shuttle:before {
  content: "\f197";
}
.fa-slack:before {
  content: "\f198";
}
.fa-envelope-square:before {
  content: "\f199";
}
.fa-wordpress:before {
  content: "\f19a";
}
.fa-openid:before {
  content: "\f19b";
}
.fa-institution:before,
.fa-bank:before,
.fa-university:before {
  content: "\f19c";
}
.fa-mortar-board:before,
.fa-graduation-cap:before {
  content: "\f19d";
}
.fa-yahoo:before {
  content: "\f19e";
}
.fa-google:before {
  content: "\f1a0";
}
.fa-reddit:before {
  content: "\f1a1";
}
.fa-reddit-square:before {
  content: "\f1a2";
}
.fa-stumbleupon-circle:before {
  content: "\f1a3";
}
.fa-stumbleupon:before {
  content: "\f1a4";
}
.fa-delicious:before {
  content: "\f1a5";
}
.fa-digg:before {
  content: "\f1a6";
}
.fa-pied-piper-square:before,
.fa-pied-piper:before {
  content: "\f1a7";
}
.fa-pied-piper-alt:before {
  content: "\f1a8";
}
.fa-drupal:before {
  content: "\f1a9";
}
.fa-joomla:before {
  content: "\f1aa";
}
.fa-language:before {
  content: "\f1ab";
}
.fa-fax:before {
  content: "\f1ac";
}
.fa-building:before {
  content: "\f1ad";
}
.fa-child:before {
  content: "\f1ae";
}
.fa-paw:before {
  content: "\f1b0";
}
.fa-spoon:before {
  content: "\f1b1";
}
.fa-cube:before {
  content: "\f1b2";
}
.fa-cubes:before {
  content: "\f1b3";
}
.fa-behance:before {
  content: "\f1b4";
}
.fa-behance-square:before {
  content: "\f1b5";
}
.fa-steam:before {
  content: "\f1b6";
}
.fa-steam-square:before {
  content: "\f1b7";
}
.fa-recycle:before {
  content: "\f1b8";
}
.fa-automobile:before,
.fa-car:before {
  content: "\f1b9";
}
.fa-cab:before,
.fa-taxi:before {
  content: "\f1ba";
}
.fa-tree:before {
  content: "\f1bb";
}
.fa-spotify:before {
  content: "\f1bc";
}
.fa-deviantart:before {
  content: "\f1bd";
}
.fa-soundcloud:before {
  content: "\f1be";
}
.fa-database:before {
  content: "\f1c0";
}
.fa-file-pdf-o:before {
  content: "\f1c1";
}
.fa-file-word-o:before {
  content: "\f1c2";
}
.fa-file-excel-o:before {
  content: "\f1c3";
}
.fa-file-powerpoint-o:before {
  content: "\f1c4";
}
.fa-file-photo-o:before,
.fa-file-picture-o:before,
.fa-file-image-o:before {
  content: "\f1c5";
}
.fa-file-zip-o:before,
.fa-file-archive-o:before {
  content: "\f1c6";
}
.fa-file-sound-o:before,
.fa-file-audio-o:before {
  content: "\f1c7";
}
.fa-file-movie-o:before,
.fa-file-video-o:before {
  content: "\f1c8";
}
.fa-file-code-o:before {
  content: "\f1c9";
}
.fa-vine:before {
  content: "\f1ca";
}
.fa-codepen:before {
  content: "\f1cb";
}
.fa-jsfiddle:before {
  content: "\f1cc";
}
.fa-life-bouy:before,
.fa-life-saver:before,
.fa-support:before,
.fa-life-ring:before {
  content: "\f1cd";
}
.fa-circle-o-notch:before {
  content: "\f1ce";
}
.fa-ra:before,
.fa-rebel:before {
  content: "\f1d0";
}
.fa-ge:before,
.fa-empire:before {
  content: "\f1d1";
}
.fa-git-square:before {
  content: "\f1d2";
}
.fa-git:before {
  content: "\f1d3";
}
.fa-hacker-news:before {
  content: "\f1d4";
}
.fa-tencent-weibo:before {
  content: "\f1d5";
}
.fa-qq:before {
  content: "\f1d6";
}
.fa-wechat:before,
.fa-weixin:before {
  content: "\f1d7";
}
.fa-send:before,
.fa-paper-plane:before {
  content: "\f1d8";
}
.fa-send-o:before,
.fa-paper-plane-o:before {
  content: "\f1d9";
}
.fa-history:before {
  content: "\f1da";
}
.fa-circle-thin:before {
  content: "\f1db";
}
.fa-header:before {
  content: "\f1dc";
}
.fa-paragraph:before {
  content: "\f1dd";
}
.fa-sliders:before {
  content: "\f1de";
}
.fa-share-alt:before {
  content: "\f1e0";
}
.fa-share-alt-square:before {
  content: "\f1e1";
}
.fa-bomb:before {
  content: "\f1e2";
}
:host {
  display: inline-block;
  width: 100%;
  background-color: transparent;
  border: 1px solid rgba(0, 0, 0, 0.1);
  font-size: 1em;
  color: rgba(69, 69, 69, 0.85);
  transition: 0.2s ease;
  -webkit-transition: 0.2s ease;
  box-sizing: border-box;
}
:host #icon {
  margin-right: 0.25em;
  line-height: inherit;
}
:host #field {
  display: flex;
  align-items: center;
  margin: 0;
  padding: 0.65em 0.65em;
}
:host #field.focused {
  color: #454545;
  border-color: rgba(0, 0, 0, 0.33);
  box-shadow: 0.3em 0em 0em 0em rgba(0, 0, 0, 0.33) inset;
  -webkit-box-shadow: 0.3em 0em 0em 0em rgba(0, 0, 0, 0.33) inset;
}
:host #field.disabled {
  color: rgba(69, 69, 69, 0.33);
}
:host #field input,
:host #field textarea {
  flex: 1;
  height: 100%;
  background-color: transparent;
  font-size: 1em;
  outline: none;
  border: none;
  margin: 0;
  padding: 0;
  color: rgba(69, 69, 69, 0.85);
  transition: 0.2s ease;
  -webkit-transition: 0.2s ease;
}
:host #field input:focus,
:host #field textarea:focus {
  color: #454545;
}
:host(.inverted) {
  color: rgba(255, 255, 255, 0.85);
  border-color: rgba(255, 255, 255, 0.33);
}
:host(.inverted) #field.focused {
  color: #ffffff;
  border-color: rgba(255, 255, 255, 0.61);
  box-shadow: 0.3em 0em 0em 0em rgba(255, 255, 255, 0.61) inset;
  -webkit-box-shadow: 0.3em 0em 0em 0em rgba(255, 255, 255, 0.61) inset;
}
:host(.inverted) #field.disabled {
  color: rgba(255, 255, 255, 0.33);
}
:host(.inverted) #field input,
:host(.inverted) #field textarea {
  color: rgba(255, 255, 255, 0.85);
}
:host(.inverted) #field input:focus,
:host(.inverted) #field textarea:focus {
  color: #ffffff;
}
input[type="date"],
input[type="datetime-local"],
input[type="month"],
input[type="time"],
input[type="week"] {
  font-family: inherit;
}
</style>
  <section id="field" on-keydown="{{keydown}}" class="{{ {disabled: disabled} | tokenList }}">
    <template if="{{icon}}">
      <i id="icon" class="fa {{icon}} {{iconAnimation}}"></i>
    </template>
    <template if="{{multiline}}">
      <textarea id="input" value="{{value}}" disabled?="{{disabled}}" placeholder="{{placeholder}}" aria-labelledby="placeholder" aria-invalid="{{invalid}}" on-change="{{change}}" on-focus="{{inputFocus}}" on-blur="{{blur}}" on-keyup="keyup" on-cut="cut" on-paste="paste" on-drop="drop" autofocus?="{{autofocus}}"></textarea>
    </template>
    <template if="{{!multiline}}">
      <input type="{{type}}" id="input" value="{{value}}" disabled?="{{disabled}}" placeholder="{{placeholder}}" aria-labelledby="placeholder" aria-invalid="{{invalid}}" on-change="{{change}}" on-focus="{{inputFocus}}" on-blur="{{blur}}" on-keyup="keyup" autofocus?="{{autofocus}}">
    </template>
  </section>
  <content></content>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-input/src/ui-input.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        Polymer("ui-input", {
            bubble: function(evt) {
                return this.fire(evt.type, null, this, false);
            },
            blur: function(evt) {
                this.$.field.classList.remove("focused");
                return this.bubble(evt);
            },
            inputFocus: function(evt) {
                this.$.field.classList.add("focused");
                return this.bubble(evt);
            },
            focus: function() {
                return this.$.input.focus();
            },
            change: function(evt) {
                if (this.multiline != null) {
                    this.resize();
                }
                this.value = evt.target.value;
                return this.bubble(evt);
            },
            keyup: function(evt) {
                return this.value = evt.target.value;
            },
            keydown: function(evt) {
                if (this.multiline != null) {
                    this.resize();
                }
                if (evt.keyCode === 27) {
                    return this.value = null;
                }
            },
            cut: function(evt) {
                if (this.multiline != null) {
                    return this.resize();
                }
            },
            paste: function(evt) {
                if (this.multiline != null) {
                    return this.resize();
                }
            },
            drop: function(evt) {
                if (this.multiline != null) {
                    return this.resize();
                }
            },
            resize: function() {
                var textarea;
                textarea = this.shadowRoot.querySelector("textarea");
                return setTimeout(function() {
                    textarea.style.height = "auto";
                    return textarea.style.height = "" + textarea.scrollHeight + "px";
                });
            },
            created: function() {
                return this.type = "text";
            },
            ready: function() {},
            attached: function() {},
            domReady: function() {},
            detached: function() {}
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>

<polymer-element name="ui-overlay" attributes="detail hover">
<template>
  <style>.hide {
  display: none !important;
}
.border {
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1) inset;
}
.focused-border {
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.33) inset;
}
.cannot-select-text {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(0, 0, 0, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease;
  -webkit-transition: opacity 0.2s ease;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease, opacity 0.2s ease;
  -webkit-transition: height 0.2s ease, opacity 0.2s ease;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
.sheen {
  background-image: linear-gradient(rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.1));
}
:host {
  display: inline-block;
  position: relative;
}
#all {
  display: block;
  position: relative;
  width: 100%;
  height: 100%;
}
#overlay {
  opacity: 0;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1000;
  transition: opacity 0.2s ease;
  text-align: center;
}
#overlay.show {
  opacity: 1;
  transition: opacity 0.2s ease;
}
</style>
  <section id="all" on-mouseenter="{{showIt}}" on-mouseleave="{{hideIt}}" on-click="{{click}}">
    <section id="overlay" class="show">
      <content select="[overlay]" class="{{hoverclass}}"></content>
    </section>
    <content></content>
  </section>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-overlay/src/ui-overlay.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        module.exports = function(element, callback) {
            function addResizeListener(element, callback) {
                if (window.OverflowEvent) {
                    element.addEventListener("overflowchanged", function(e) {
                        callback.call(this, e);
                    });
                } else {
                    element.addEventListener("overflow", function(e) {
                        callback.call(this, e);
                    });
                    element.addEventListener("underflow", function(e) {
                        callback.call(this, e);
                    });
                }
            }
            function EventQueue() {
                this.q = [];
                this.add = function(ev) {
                    this.q.push(ev);
                };
                var i, j;
                this.call = function() {
                    for (i = 0, j = this.q.length; i < j; i++) {
                        this.q[i].call();
                    }
                };
            }
            function getComputedStyle(element, prop) {
                if (element.currentStyle) {
                    return element.currentStyle[prop];
                } else if (window.getComputedStyle) {
                    return window.getComputedStyle(element, null).getPropertyValue(prop);
                } else {
                    return element.style[prop];
                }
            }
            function attachResizeEvent(element, resized) {
                if (!element.resizedAttached) {
                    element.resizedAttached = new EventQueue();
                    element.resizedAttached.add(resized);
                } else if (element.resizedAttached) {
                    element.resizedAttached.add(resized);
                    return;
                }
                var myResized = function() {
                    if (setupSensor()) {
                        element.resizedAttached.call();
                    }
                };
                element.resizeSensor = document.createElement("div");
                element.resizeSensor.className = "resize-sensor";
                var style = "position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1;";
                element.resizeSensor.style.cssText = style;
                element.resizeSensor.innerHTML = '<div class="resize-sensor-overflow" style="' + style + '">' + "<div></div>" + "</div>" + '<div class="resize-sensor-underflow" style="' + style + '">' + "<div></div>" + "</div>";
                element.appendChild(element.resizeSensor);
                if ("absolute" !== getComputedStyle(element, "position")) {
                    element.style.position = "relative";
                }
                var x = -1, y = -1, firstStyle = element.resizeSensor.firstElementChild.firstChild.style, lastStyle = element.resizeSensor.lastElementChild.firstChild.style;
                function setupSensor() {
                    var change = false, width = element.resizeSensor.offsetWidth, height = element.resizeSensor.offsetHeight;
                    if (x != width) {
                        firstStyle.width = width - 1 + "px";
                        lastStyle.width = width + 1 + "px";
                        change = true;
                        x = width;
                    }
                    if (y != height) {
                        firstStyle.height = height - 1 + "px";
                        lastStyle.height = height + 1 + "px";
                        change = true;
                        y = height;
                    }
                    return change;
                }
                setupSensor();
                addResizeListener(element.resizeSensor, myResized);
                addResizeListener(element.resizeSensor.firstElementChild, myResized);
                addResizeListener(element.resizeSensor.lastElementChild, myResized);
            }
            if ("array" === typeof element || "undefined" !== typeof jQuery && element instanceof jQuery || "undefined" !== typeof Elements && element instanceof Elements) {
                var i = 0, j = element.length;
                for (;i < j; i++) {
                    attachResizeEvent(element[i], callback);
                }
            } else {
                attachResizeEvent(element, callback);
            }
        };
    }, {} ],
    2: [ function(require, module, exports) {
        var ResizeSensor;
        ResizeSensor = require("./ResizeSensor");
        Polymer("ui-overlay", {
            click: function(evt) {
                evt.preventDefault();
                evt.stopPropagation();
                return this.fire("click", this.detail);
            },
            showIt: function() {
                this.resized();
                if (this.hover != null) {
                    return this.$.overlay.classList.add("show");
                }
            },
            hideIt: function() {
                if (this.hover != null) {
                    return this.$.overlay.classList.remove("show");
                }
            },
            resized: function() {
                var size, _ref;
                size = Math.min(this.clientWidth, this.clientHeight) / Math.max(1, (_ref = window.getComputedStyle(this.$.overlay, "before")["content"]) != null ? _ref.length : void 0);
                this.$.overlay.style["font-size"] = "" + size + "px";
                return this.$.overlay.style["line-height"] = "" + size + "px";
            },
            created: function() {},
            ready: function() {},
            attached: function() {
                if (this.hover != null) {
                    this.$.overlay.classList.remove("show");
                }
                this.sensor = new ResizeSensor(this.$.overlay, function(_this) {
                    return function() {
                        return _this.resized();
                    };
                }(this));
                return this.resized();
            },
            domReady: function() {},
            detached: function() {}
        });
    }, {
        "./ResizeSensor": 1
    } ]
}, {}, [ 2 ]);</script>
</polymer-element>

<polymer-element name="ui-tooltip" attributes="label display" on-mouseenter="mouseenter" on-mouseleave="mouseleave">
<template>
  <style>.hide {
  display: none !important;
}
.border {
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1) inset;
}
.focused-border {
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.33) inset;
}
.cannot-select-text {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(0, 0, 0, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease;
  -webkit-transition: opacity 0.2s ease;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease, opacity 0.2s ease;
  -webkit-transition: height 0.2s ease, opacity 0.2s ease;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
.sheen {
  background-image: linear-gradient(rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.1));
}
:host {
  display: inline-block;
  position: relative;
  box-sizing: border-box;
  perspective: 1000;
}
#tooltip {
  position: absolute;
  display: flex;
  white-space: nowrap;
  font-size: 0.85rem;
  border: 1px solid rgba(0, 0, 0, 0.33);
  color: #454545;
  font-weight: 200;
  background-color: #ffffff;
  z-index: 1000;
  transform-style: preserve-3d;
  padding: 0.8em 1.2em;
  opacity: 85%;
  box-shadow: 1px 1px 1px rgba(0, 0, 0, 0.1);
  -webkit-box-shadow: 1px 1px 1px rgba(0, 0, 0, 0.1);
  transition: 0.2s ease;
  -webkit-transition: 0.2s ease;
  transform: rotateX(0deg);
  -webkit-transform: rotateX(0deg);
}
#tooltip.hidden {
  transform: rotateX(90deg);
  -webkit-transform: rotateX(90deg);
  opacity: 0;
}
#tooltip:before {
  position: absolute;
  box-sizing: border-box;
  content: "";
  width: 0.75em;
  height: 0.75em;
  border-color: #ffffff;
  background-color: #ffffff;
  transform: rotate(45deg);
  -webkit-transform: rotate(45deg);
  z-index: 1002;
}
#tooltip.down {
  top: calc(100%);
  margin-top: 0.5em;
}
#tooltip.up {
  bottom: calc(100%);
  margin-bottom: 0.5em;
}
#tooltip.left {
  right: 25%;
}
#tooltip.right {
  left: 25%;
}
#tooltip.right.down:before {
  top: -0.4em;
  left: 0.4em;
  border-left: 1px solid rgba(0, 0, 0, 0.33);
  border-top: 1px solid rgba(0, 0, 0, 0.33);
}
#tooltip.left.down:before {
  top: -0.4em;
  right: 0.4em;
  border-left: 1px solid rgba(0, 0, 0, 0.33);
  border-top: 1px solid rgba(0, 0, 0, 0.33);
}
#tooltip.right.up:before {
  bottom: -0.4em;
  left: 0.4em;
  border-right: 1px solid rgba(0, 0, 0, 0.33);
  border-bottom: 1px solid rgba(0, 0, 0, 0.33);
  box-shadow: 1px 1px 1px rgba(0, 0, 0, 0.1);
  -webkit-box-shadow: 1px 1px 1px rgba(0, 0, 0, 0.1);
}
#tooltip.left.up:before {
  bottom: -0.4em;
  right: 0.4em;
  border-right: 1px solid rgba(0, 0, 0, 0.33);
  border-bottom: 1px solid rgba(0, 0, 0, 0.33);
  box-shadow: 1px 1px 1px rgba(0, 0, 0, 0.1);
  -webkit-box-shadow: 1px 1px 1px rgba(0, 0, 0, 0.1);
}
</style>
  <div id="tooltip" class="{{display}} hidden">
    <content select="[tip]">{{label}}</content>
  </div>
  <content></content>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-tooltip/src/ui-tooltip.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        Polymer("ui-tooltip", {
            position: function() {
                var body, offsetX, offsetY, tip, xStep, yStep;
                tip = this.getBoundingClientRect();
                body = document.querySelector("body").getBoundingClientRect();
                xStep = document.documentElement.clientWidth / 3;
                yStep = document.documentElement.clientHeight / 3;
                offsetX = "left";
                if (tip.left < xStep * 2) {
                    offsetX = "right";
                }
                offsetY = "up";
                if (tip.top < yStep * 2) {
                    offsetY = "down";
                }
                return this.display = "" + offsetX + " " + offsetY;
            },
            mouseenter: function() {
                this.position();
                return this.$.tooltip.classList.remove("hidden");
            },
            mouseleave: function() {
                this.position();
                return this.$.tooltip.classList.add("hidden");
            },
            created: function() {},
            ready: function() {},
            attached: function() {
                return this.position();
            },
            domReady: function() {},
            detached: function() {}
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>




<style>.hide {
  display: none !important;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(0, 0, 0, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease;
  -webkit-transition: opacity 0.2s ease;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease, opacity 0.2s ease;
  -webkit-transition: height 0.2s ease, opacity 0.2s ease;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
.sheen {
  background-image: linear-gradient(rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.1));
}
ui-typeahead[selected] ui-typeahead-item:not([selected]) {
  display: none;
}
ui-typeahead[selected] ui-typeahead-item[selected]::before {
  content: '(change)';
  float: right;
}
</style>
<polymer-element name="ui-typeahead" attributes="text icon placeholder debounce data">
<template>
  <style>.hide {
  display: none !important;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(0, 0, 0, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease;
  -webkit-transition: opacity 0.2s ease;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease, opacity 0.2s ease;
  -webkit-transition: height 0.2s ease, opacity 0.2s ease;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
.sheen {
  background-image: linear-gradient(rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.1));
}
:host {
  display: block;
  position: relative;
  box-sizing: border-box;
  border: 1px solid rgba(0, 0, 0, 0.04);
}
:host ui-input {
  border: 0;
}
:host([selected]) #results {
  top: 0;
  overflow: visible;
  background-color: transparent;
}
#results {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background-color: white;
  border-left: solid 1px rgba(0, 0, 0, 0.1);
  border-right: solid 1px rgba(0, 0, 0, 0.1);
  transition: top 0.2s ease;
  -webkit-transition: top 0.2s ease;
  overflow-y: scroll;
  z-index: 999;
}
#selected::before {
  float: right;
  content: "(change)";
}
</style>
  <ui-input fadeout="" id="input" icon="{{icon}}" placeholder="{{placeholder}}" value="{{text}}"></ui-input>

  <section id="results">
    <content select="ui-typeahead-item">
    </content>
  </section>

</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-typeahead/src/ui-typeahead.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        (function(global) {
            (function() {
                var undefined;
                var arrayPool = [], objectPool = [];
                var idCounter = 0;
                var keyPrefix = +new Date() + "";
                var largeArraySize = 75;
                var maxPoolSize = 40;
                var whitespace = " 	\f ﻿" + "\n\r\u2028\u2029" + " ᠎             　";
                var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
                var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
                var reFlags = /\w*$/;
                var reFuncName = /^\s*function[ \n\r\t]+\w/;
                var reInterpolate = /<%=([\s\S]+?)%>/g;
                var reLeadingSpacesAndZeros = RegExp("^[" + whitespace + "]*0+(?=.$)");
                var reNoMatch = /($^)/;
                var reThis = /\bthis\b/;
                var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
                var contextProps = [ "Array", "Boolean", "Date", "Function", "Math", "Number", "Object", "RegExp", "String", "_", "attachEvent", "clearTimeout", "isFinite", "isNaN", "parseInt", "setTimeout" ];
                var templateCounter = 0;
                var argsClass = "[object Arguments]", arrayClass = "[object Array]", boolClass = "[object Boolean]", dateClass = "[object Date]", funcClass = "[object Function]", numberClass = "[object Number]", objectClass = "[object Object]", regexpClass = "[object RegExp]", stringClass = "[object String]";
                var cloneableClasses = {};
                cloneableClasses[funcClass] = false;
                cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
                var debounceOptions = {
                    leading: false,
                    maxWait: 0,
                    trailing: false
                };
                var descriptor = {
                    configurable: false,
                    enumerable: false,
                    value: null,
                    writable: false
                };
                var objectTypes = {
                    "boolean": false,
                    "function": true,
                    object: true,
                    number: false,
                    string: false,
                    undefined: false
                };
                var stringEscapes = {
                    "\\": "\\",
                    "'": "'",
                    "\n": "n",
                    "\r": "r",
                    "	": "t",
                    "\u2028": "u2028",
                    "\u2029": "u2029"
                };
                var root = objectTypes[typeof window] && window || this;
                var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
                var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
                var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
                var freeGlobal = objectTypes[typeof global] && global;
                if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
                    root = freeGlobal;
                }
                function baseIndexOf(array, value, fromIndex) {
                    var index = (fromIndex || 0) - 1, length = array ? array.length : 0;
                    while (++index < length) {
                        if (array[index] === value) {
                            return index;
                        }
                    }
                    return -1;
                }
                function cacheIndexOf(cache, value) {
                    var type = typeof value;
                    cache = cache.cache;
                    if (type == "boolean" || value == null) {
                        return cache[value] ? 0 : -1;
                    }
                    if (type != "number" && type != "string") {
                        type = "object";
                    }
                    var key = type == "number" ? value : keyPrefix + value;
                    cache = (cache = cache[type]) && cache[key];
                    return type == "object" ? cache && baseIndexOf(cache, value) > -1 ? 0 : -1 : cache ? 0 : -1;
                }
                function cachePush(value) {
                    var cache = this.cache, type = typeof value;
                    if (type == "boolean" || value == null) {
                        cache[value] = true;
                    } else {
                        if (type != "number" && type != "string") {
                            type = "object";
                        }
                        var key = type == "number" ? value : keyPrefix + value, typeCache = cache[type] || (cache[type] = {});
                        if (type == "object") {
                            (typeCache[key] || (typeCache[key] = [])).push(value);
                        } else {
                            typeCache[key] = true;
                        }
                    }
                }
                function charAtCallback(value) {
                    return value.charCodeAt(0);
                }
                function compareAscending(a, b) {
                    var ac = a.criteria, bc = b.criteria, index = -1, length = ac.length;
                    while (++index < length) {
                        var value = ac[index], other = bc[index];
                        if (value !== other) {
                            if (value > other || typeof value == "undefined") {
                                return 1;
                            }
                            if (value < other || typeof other == "undefined") {
                                return -1;
                            }
                        }
                    }
                    return a.index - b.index;
                }
                function createCache(array) {
                    var index = -1, length = array.length, first = array[0], mid = array[length / 2 | 0], last = array[length - 1];
                    if (first && typeof first == "object" && mid && typeof mid == "object" && last && typeof last == "object") {
                        return false;
                    }
                    var cache = getObject();
                    cache["false"] = cache["null"] = cache["true"] = cache["undefined"] = false;
                    var result = getObject();
                    result.array = array;
                    result.cache = cache;
                    result.push = cachePush;
                    while (++index < length) {
                        result.push(array[index]);
                    }
                    return result;
                }
                function escapeStringChar(match) {
                    return "\\" + stringEscapes[match];
                }
                function getArray() {
                    return arrayPool.pop() || [];
                }
                function getObject() {
                    return objectPool.pop() || {
                        array: null,
                        cache: null,
                        criteria: null,
                        "false": false,
                        index: 0,
                        "null": false,
                        number: null,
                        object: null,
                        push: null,
                        string: null,
                        "true": false,
                        undefined: false,
                        value: null
                    };
                }
                function releaseArray(array) {
                    array.length = 0;
                    if (arrayPool.length < maxPoolSize) {
                        arrayPool.push(array);
                    }
                }
                function releaseObject(object) {
                    var cache = object.cache;
                    if (cache) {
                        releaseObject(cache);
                    }
                    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
                    if (objectPool.length < maxPoolSize) {
                        objectPool.push(object);
                    }
                }
                function slice(array, start, end) {
                    start || (start = 0);
                    if (typeof end == "undefined") {
                        end = array ? array.length : 0;
                    }
                    var index = -1, length = end - start || 0, result = Array(length < 0 ? 0 : length);
                    while (++index < length) {
                        result[index] = array[start + index];
                    }
                    return result;
                }
                function runInContext(context) {
                    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
                    var Array = context.Array, Boolean = context.Boolean, Date = context.Date, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
                    var arrayRef = [];
                    var objectProto = Object.prototype;
                    var oldDash = context._;
                    var toString = objectProto.toString;
                    var reNative = RegExp("^" + String(toString).replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/toString| for [^\]]+/g, ".*?") + "$");
                    var ceil = Math.ceil, clearTimeout = context.clearTimeout, floor = Math.floor, fnToString = Function.prototype.toString, getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, hasOwnProperty = objectProto.hasOwnProperty, push = arrayRef.push, setTimeout = context.setTimeout, splice = arrayRef.splice, unshift = arrayRef.unshift;
                    var defineProperty = function() {
                        try {
                            var o = {}, func = isNative(func = Object.defineProperty) && func, result = func(o, o, o) && func;
                        } catch (e) {}
                        return result;
                    }();
                    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate, nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray, nativeIsFinite = context.isFinite, nativeIsNaN = context.isNaN, nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeParseInt = context.parseInt, nativeRandom = Math.random;
                    var ctorByClass = {};
                    ctorByClass[arrayClass] = Array;
                    ctorByClass[boolClass] = Boolean;
                    ctorByClass[dateClass] = Date;
                    ctorByClass[funcClass] = Function;
                    ctorByClass[objectClass] = Object;
                    ctorByClass[numberClass] = Number;
                    ctorByClass[regexpClass] = RegExp;
                    ctorByClass[stringClass] = String;
                    function lodash(value) {
                        return value && typeof value == "object" && !isArray(value) && hasOwnProperty.call(value, "__wrapped__") ? value : new lodashWrapper(value);
                    }
                    function lodashWrapper(value, chainAll) {
                        this.__chain__ = !!chainAll;
                        this.__wrapped__ = value;
                    }
                    lodashWrapper.prototype = lodash.prototype;
                    var support = lodash.support = {};
                    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
                    support.funcNames = typeof Function.name == "string";
                    lodash.templateSettings = {
                        escape: /<%-([\s\S]+?)%>/g,
                        evaluate: /<%([\s\S]+?)%>/g,
                        interpolate: reInterpolate,
                        variable: "",
                        imports: {
                            _: lodash
                        }
                    };
                    function baseBind(bindData) {
                        var func = bindData[0], partialArgs = bindData[2], thisArg = bindData[4];
                        function bound() {
                            if (partialArgs) {
                                var args = slice(partialArgs);
                                push.apply(args, arguments);
                            }
                            if (this instanceof bound) {
                                var thisBinding = baseCreate(func.prototype), result = func.apply(thisBinding, args || arguments);
                                return isObject(result) ? result : thisBinding;
                            }
                            return func.apply(thisArg, args || arguments);
                        }
                        setBindData(bound, bindData);
                        return bound;
                    }
                    function baseClone(value, isDeep, callback, stackA, stackB) {
                        if (callback) {
                            var result = callback(value);
                            if (typeof result != "undefined") {
                                return result;
                            }
                        }
                        var isObj = isObject(value);
                        if (isObj) {
                            var className = toString.call(value);
                            if (!cloneableClasses[className]) {
                                return value;
                            }
                            var ctor = ctorByClass[className];
                            switch (className) {
                              case boolClass:
                              case dateClass:
                                return new ctor(+value);

                              case numberClass:
                              case stringClass:
                                return new ctor(value);

                              case regexpClass:
                                result = ctor(value.source, reFlags.exec(value));
                                result.lastIndex = value.lastIndex;
                                return result;
                            }
                        } else {
                            return value;
                        }
                        var isArr = isArray(value);
                        if (isDeep) {
                            var initedStack = !stackA;
                            stackA || (stackA = getArray());
                            stackB || (stackB = getArray());
                            var length = stackA.length;
                            while (length--) {
                                if (stackA[length] == value) {
                                    return stackB[length];
                                }
                            }
                            result = isArr ? ctor(value.length) : {};
                        } else {
                            result = isArr ? slice(value) : assign({}, value);
                        }
                        if (isArr) {
                            if (hasOwnProperty.call(value, "index")) {
                                result.index = value.index;
                            }
                            if (hasOwnProperty.call(value, "input")) {
                                result.input = value.input;
                            }
                        }
                        if (!isDeep) {
                            return result;
                        }
                        stackA.push(value);
                        stackB.push(result);
                        (isArr ? forEach : forOwn)(value, function(objValue, key) {
                            result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
                        });
                        if (initedStack) {
                            releaseArray(stackA);
                            releaseArray(stackB);
                        }
                        return result;
                    }
                    function baseCreate(prototype, properties) {
                        return isObject(prototype) ? nativeCreate(prototype) : {};
                    }
                    if (!nativeCreate) {
                        baseCreate = function() {
                            function Object() {}
                            return function(prototype) {
                                if (isObject(prototype)) {
                                    Object.prototype = prototype;
                                    var result = new Object();
                                    Object.prototype = null;
                                }
                                return result || context.Object();
                            };
                        }();
                    }
                    function baseCreateCallback(func, thisArg, argCount) {
                        if (typeof func != "function") {
                            return identity;
                        }
                        if (typeof thisArg == "undefined" || !("prototype" in func)) {
                            return func;
                        }
                        var bindData = func.__bindData__;
                        if (typeof bindData == "undefined") {
                            if (support.funcNames) {
                                bindData = !func.name;
                            }
                            bindData = bindData || !support.funcDecomp;
                            if (!bindData) {
                                var source = fnToString.call(func);
                                if (!support.funcNames) {
                                    bindData = !reFuncName.test(source);
                                }
                                if (!bindData) {
                                    bindData = reThis.test(source);
                                    setBindData(func, bindData);
                                }
                            }
                        }
                        if (bindData === false || bindData !== true && bindData[1] & 1) {
                            return func;
                        }
                        switch (argCount) {
                          case 1:
                            return function(value) {
                                return func.call(thisArg, value);
                            };

                          case 2:
                            return function(a, b) {
                                return func.call(thisArg, a, b);
                            };

                          case 3:
                            return function(value, index, collection) {
                                return func.call(thisArg, value, index, collection);
                            };

                          case 4:
                            return function(accumulator, value, index, collection) {
                                return func.call(thisArg, accumulator, value, index, collection);
                            };
                        }
                        return bind(func, thisArg);
                    }
                    function baseCreateWrapper(bindData) {
                        var func = bindData[0], bitmask = bindData[1], partialArgs = bindData[2], partialRightArgs = bindData[3], thisArg = bindData[4], arity = bindData[5];
                        var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, key = func;
                        function bound() {
                            var thisBinding = isBind ? thisArg : this;
                            if (partialArgs) {
                                var args = slice(partialArgs);
                                push.apply(args, arguments);
                            }
                            if (partialRightArgs || isCurry) {
                                args || (args = slice(arguments));
                                if (partialRightArgs) {
                                    push.apply(args, partialRightArgs);
                                }
                                if (isCurry && args.length < arity) {
                                    bitmask |= 16 & ~32;
                                    return baseCreateWrapper([ func, isCurryBound ? bitmask : bitmask & ~3, args, null, thisArg, arity ]);
                                }
                            }
                            args || (args = arguments);
                            if (isBindKey) {
                                func = thisBinding[key];
                            }
                            if (this instanceof bound) {
                                thisBinding = baseCreate(func.prototype);
                                var result = func.apply(thisBinding, args);
                                return isObject(result) ? result : thisBinding;
                            }
                            return func.apply(thisBinding, args);
                        }
                        setBindData(bound, bindData);
                        return bound;
                    }
                    function baseDifference(array, values) {
                        var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, isLarge = length >= largeArraySize && indexOf === baseIndexOf, result = [];
                        if (isLarge) {
                            var cache = createCache(values);
                            if (cache) {
                                indexOf = cacheIndexOf;
                                values = cache;
                            } else {
                                isLarge = false;
                            }
                        }
                        while (++index < length) {
                            var value = array[index];
                            if (indexOf(values, value) < 0) {
                                result.push(value);
                            }
                        }
                        if (isLarge) {
                            releaseObject(values);
                        }
                        return result;
                    }
                    function baseFlatten(array, isShallow, isStrict, fromIndex) {
                        var index = (fromIndex || 0) - 1, length = array ? array.length : 0, result = [];
                        while (++index < length) {
                            var value = array[index];
                            if (value && typeof value == "object" && typeof value.length == "number" && (isArray(value) || isArguments(value))) {
                                if (!isShallow) {
                                    value = baseFlatten(value, isShallow, isStrict);
                                }
                                var valIndex = -1, valLength = value.length, resIndex = result.length;
                                result.length += valLength;
                                while (++valIndex < valLength) {
                                    result[resIndex++] = value[valIndex];
                                }
                            } else if (!isStrict) {
                                result.push(value);
                            }
                        }
                        return result;
                    }
                    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
                        if (callback) {
                            var result = callback(a, b);
                            if (typeof result != "undefined") {
                                return !!result;
                            }
                        }
                        if (a === b) {
                            return a !== 0 || 1 / a == 1 / b;
                        }
                        var type = typeof a, otherType = typeof b;
                        if (a === a && !(a && objectTypes[type]) && !(b && objectTypes[otherType])) {
                            return false;
                        }
                        if (a == null || b == null) {
                            return a === b;
                        }
                        var className = toString.call(a), otherClass = toString.call(b);
                        if (className == argsClass) {
                            className = objectClass;
                        }
                        if (otherClass == argsClass) {
                            otherClass = objectClass;
                        }
                        if (className != otherClass) {
                            return false;
                        }
                        switch (className) {
                          case boolClass:
                          case dateClass:
                            return +a == +b;

                          case numberClass:
                            return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;

                          case regexpClass:
                          case stringClass:
                            return a == String(b);
                        }
                        var isArr = className == arrayClass;
                        if (!isArr) {
                            var aWrapped = hasOwnProperty.call(a, "__wrapped__"), bWrapped = hasOwnProperty.call(b, "__wrapped__");
                            if (aWrapped || bWrapped) {
                                return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
                            }
                            if (className != objectClass) {
                                return false;
                            }
                            var ctorA = a.constructor, ctorB = b.constructor;
                            if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ("constructor" in a && "constructor" in b)) {
                                return false;
                            }
                        }
                        var initedStack = !stackA;
                        stackA || (stackA = getArray());
                        stackB || (stackB = getArray());
                        var length = stackA.length;
                        while (length--) {
                            if (stackA[length] == a) {
                                return stackB[length] == b;
                            }
                        }
                        var size = 0;
                        result = true;
                        stackA.push(a);
                        stackB.push(b);
                        if (isArr) {
                            length = a.length;
                            size = b.length;
                            result = size == length;
                            if (result || isWhere) {
                                while (size--) {
                                    var index = length, value = b[size];
                                    if (isWhere) {
                                        while (index--) {
                                            if (result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB)) {
                                                break;
                                            }
                                        }
                                    } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
                                        break;
                                    }
                                }
                            }
                        } else {
                            forIn(b, function(value, key, b) {
                                if (hasOwnProperty.call(b, key)) {
                                    size++;
                                    return result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB);
                                }
                            });
                            if (result && !isWhere) {
                                forIn(a, function(value, key, a) {
                                    if (hasOwnProperty.call(a, key)) {
                                        return result = --size > -1;
                                    }
                                });
                            }
                        }
                        stackA.pop();
                        stackB.pop();
                        if (initedStack) {
                            releaseArray(stackA);
                            releaseArray(stackB);
                        }
                        return result;
                    }
                    function baseMerge(object, source, callback, stackA, stackB) {
                        (isArray(source) ? forEach : forOwn)(source, function(source, key) {
                            var found, isArr, result = source, value = object[key];
                            if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                                var stackLength = stackA.length;
                                while (stackLength--) {
                                    if (found = stackA[stackLength] == source) {
                                        value = stackB[stackLength];
                                        break;
                                    }
                                }
                                if (!found) {
                                    var isShallow;
                                    if (callback) {
                                        result = callback(value, source);
                                        if (isShallow = typeof result != "undefined") {
                                            value = result;
                                        }
                                    }
                                    if (!isShallow) {
                                        value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {};
                                    }
                                    stackA.push(source);
                                    stackB.push(value);
                                    if (!isShallow) {
                                        baseMerge(value, source, callback, stackA, stackB);
                                    }
                                }
                            } else {
                                if (callback) {
                                    result = callback(value, source);
                                    if (typeof result == "undefined") {
                                        result = source;
                                    }
                                }
                                if (typeof result != "undefined") {
                                    value = result;
                                }
                            }
                            object[key] = value;
                        });
                    }
                    function baseRandom(min, max) {
                        return min + floor(nativeRandom() * (max - min + 1));
                    }
                    function baseUniq(array, isSorted, callback) {
                        var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [];
                        var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf, seen = callback || isLarge ? getArray() : result;
                        if (isLarge) {
                            var cache = createCache(seen);
                            indexOf = cacheIndexOf;
                            seen = cache;
                        }
                        while (++index < length) {
                            var value = array[index], computed = callback ? callback(value, index, array) : value;
                            if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) {
                                if (callback || isLarge) {
                                    seen.push(computed);
                                }
                                result.push(value);
                            }
                        }
                        if (isLarge) {
                            releaseArray(seen.array);
                            releaseObject(seen);
                        } else if (callback) {
                            releaseArray(seen);
                        }
                        return result;
                    }
                    function createAggregator(setter) {
                        return function(collection, callback, thisArg) {
                            var result = {};
                            callback = lodash.createCallback(callback, thisArg, 3);
                            var index = -1, length = collection ? collection.length : 0;
                            if (typeof length == "number") {
                                while (++index < length) {
                                    var value = collection[index];
                                    setter(result, value, callback(value, index, collection), collection);
                                }
                            } else {
                                forOwn(collection, function(value, key, collection) {
                                    setter(result, value, callback(value, key, collection), collection);
                                });
                            }
                            return result;
                        };
                    }
                    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
                        var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, isPartial = bitmask & 16, isPartialRight = bitmask & 32;
                        if (!isBindKey && !isFunction(func)) {
                            throw new TypeError();
                        }
                        if (isPartial && !partialArgs.length) {
                            bitmask &= ~16;
                            isPartial = partialArgs = false;
                        }
                        if (isPartialRight && !partialRightArgs.length) {
                            bitmask &= ~32;
                            isPartialRight = partialRightArgs = false;
                        }
                        var bindData = func && func.__bindData__;
                        if (bindData && bindData !== true) {
                            bindData = slice(bindData);
                            if (bindData[2]) {
                                bindData[2] = slice(bindData[2]);
                            }
                            if (bindData[3]) {
                                bindData[3] = slice(bindData[3]);
                            }
                            if (isBind && !(bindData[1] & 1)) {
                                bindData[4] = thisArg;
                            }
                            if (!isBind && bindData[1] & 1) {
                                bitmask |= 8;
                            }
                            if (isCurry && !(bindData[1] & 4)) {
                                bindData[5] = arity;
                            }
                            if (isPartial) {
                                push.apply(bindData[2] || (bindData[2] = []), partialArgs);
                            }
                            if (isPartialRight) {
                                unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
                            }
                            bindData[1] |= bitmask;
                            return createWrapper.apply(null, bindData);
                        }
                        var creater = bitmask == 1 || bitmask === 17 ? baseBind : baseCreateWrapper;
                        return creater([ func, bitmask, partialArgs, partialRightArgs, thisArg, arity ]);
                    }
                    function escapeHtmlChar(match) {
                        return htmlEscapes[match];
                    }
                    function getIndexOf() {
                        var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
                        return result;
                    }
                    function isNative(value) {
                        return typeof value == "function" && reNative.test(value);
                    }
                    var setBindData = !defineProperty ? noop : function(func, value) {
                        descriptor.value = value;
                        defineProperty(func, "__bindData__", descriptor);
                    };
                    function shimIsPlainObject(value) {
                        var ctor, result;
                        if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, 
                        isFunction(ctor) && !(ctor instanceof ctor))) {
                            return false;
                        }
                        forIn(value, function(value, key) {
                            result = key;
                        });
                        return typeof result == "undefined" || hasOwnProperty.call(value, result);
                    }
                    function unescapeHtmlChar(match) {
                        return htmlUnescapes[match];
                    }
                    function isArguments(value) {
                        return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == argsClass || false;
                    }
                    var isArray = nativeIsArray || function(value) {
                        return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == arrayClass || false;
                    };
                    var shimKeys = function(object) {
                        var index, iterable = object, result = [];
                        if (!iterable) return result;
                        if (!objectTypes[typeof object]) return result;
                        for (index in iterable) {
                            if (hasOwnProperty.call(iterable, index)) {
                                result.push(index);
                            }
                        }
                        return result;
                    };
                    var keys = !nativeKeys ? shimKeys : function(object) {
                        if (!isObject(object)) {
                            return [];
                        }
                        return nativeKeys(object);
                    };
                    var htmlEscapes = {
                        "&": "&amp;",
                        "<": "&lt;",
                        ">": "&gt;",
                        '"': "&quot;",
                        "'": "&#39;"
                    };
                    var htmlUnescapes = invert(htmlEscapes);
                    var reEscapedHtml = RegExp("(" + keys(htmlUnescapes).join("|") + ")", "g"), reUnescapedHtml = RegExp("[" + keys(htmlEscapes).join("") + "]", "g");
                    var assign = function(object, source, guard) {
                        var index, iterable = object, result = iterable;
                        if (!iterable) return result;
                        var args = arguments, argsIndex = 0, argsLength = typeof guard == "number" ? 2 : args.length;
                        if (argsLength > 3 && typeof args[argsLength - 2] == "function") {
                            var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
                        } else if (argsLength > 2 && typeof args[argsLength - 1] == "function") {
                            callback = args[--argsLength];
                        }
                        while (++argsIndex < argsLength) {
                            iterable = args[argsIndex];
                            if (iterable && objectTypes[typeof iterable]) {
                                var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                                while (++ownIndex < length) {
                                    index = ownProps[ownIndex];
                                    result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
                                }
                            }
                        }
                        return result;
                    };
                    function clone(value, isDeep, callback, thisArg) {
                        if (typeof isDeep != "boolean" && isDeep != null) {
                            thisArg = callback;
                            callback = isDeep;
                            isDeep = false;
                        }
                        return baseClone(value, isDeep, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
                    }
                    function cloneDeep(value, callback, thisArg) {
                        return baseClone(value, true, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
                    }
                    function create(prototype, properties) {
                        var result = baseCreate(prototype);
                        return properties ? assign(result, properties) : result;
                    }
                    var defaults = function(object, source, guard) {
                        var index, iterable = object, result = iterable;
                        if (!iterable) return result;
                        var args = arguments, argsIndex = 0, argsLength = typeof guard == "number" ? 2 : args.length;
                        while (++argsIndex < argsLength) {
                            iterable = args[argsIndex];
                            if (iterable && objectTypes[typeof iterable]) {
                                var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                                while (++ownIndex < length) {
                                    index = ownProps[ownIndex];
                                    if (typeof result[index] == "undefined") result[index] = iterable[index];
                                }
                            }
                        }
                        return result;
                    };
                    function findKey(object, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwn(object, function(value, key, object) {
                            if (callback(value, key, object)) {
                                result = key;
                                return false;
                            }
                        });
                        return result;
                    }
                    function findLastKey(object, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwnRight(object, function(value, key, object) {
                            if (callback(value, key, object)) {
                                result = key;
                                return false;
                            }
                        });
                        return result;
                    }
                    var forIn = function(collection, callback, thisArg) {
                        var index, iterable = collection, result = iterable;
                        if (!iterable) return result;
                        if (!objectTypes[typeof iterable]) return result;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        for (index in iterable) {
                            if (callback(iterable[index], index, collection) === false) return result;
                        }
                        return result;
                    };
                    function forInRight(object, callback, thisArg) {
                        var pairs = [];
                        forIn(object, function(value, key) {
                            pairs.push(key, value);
                        });
                        var length = pairs.length;
                        callback = baseCreateCallback(callback, thisArg, 3);
                        while (length--) {
                            if (callback(pairs[length--], pairs[length], object) === false) {
                                break;
                            }
                        }
                        return object;
                    }
                    var forOwn = function(collection, callback, thisArg) {
                        var index, iterable = collection, result = iterable;
                        if (!iterable) return result;
                        if (!objectTypes[typeof iterable]) return result;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                        while (++ownIndex < length) {
                            index = ownProps[ownIndex];
                            if (callback(iterable[index], index, collection) === false) return result;
                        }
                        return result;
                    };
                    function forOwnRight(object, callback, thisArg) {
                        var props = keys(object), length = props.length;
                        callback = baseCreateCallback(callback, thisArg, 3);
                        while (length--) {
                            var key = props[length];
                            if (callback(object[key], key, object) === false) {
                                break;
                            }
                        }
                        return object;
                    }
                    function functions(object) {
                        var result = [];
                        forIn(object, function(value, key) {
                            if (isFunction(value)) {
                                result.push(key);
                            }
                        });
                        return result.sort();
                    }
                    function has(object, key) {
                        return object ? hasOwnProperty.call(object, key) : false;
                    }
                    function invert(object) {
                        var index = -1, props = keys(object), length = props.length, result = {};
                        while (++index < length) {
                            var key = props[index];
                            result[object[key]] = key;
                        }
                        return result;
                    }
                    function isBoolean(value) {
                        return value === true || value === false || value && typeof value == "object" && toString.call(value) == boolClass || false;
                    }
                    function isDate(value) {
                        return value && typeof value == "object" && toString.call(value) == dateClass || false;
                    }
                    function isElement(value) {
                        return value && value.nodeType === 1 || false;
                    }
                    function isEmpty(value) {
                        var result = true;
                        if (!value) {
                            return result;
                        }
                        var className = toString.call(value), length = value.length;
                        if (className == arrayClass || className == stringClass || className == argsClass || className == objectClass && typeof length == "number" && isFunction(value.splice)) {
                            return !length;
                        }
                        forOwn(value, function() {
                            return result = false;
                        });
                        return result;
                    }
                    function isEqual(a, b, callback, thisArg) {
                        return baseIsEqual(a, b, typeof callback == "function" && baseCreateCallback(callback, thisArg, 2));
                    }
                    function isFinite(value) {
                        return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
                    }
                    function isFunction(value) {
                        return typeof value == "function";
                    }
                    function isObject(value) {
                        return !!(value && objectTypes[typeof value]);
                    }
                    function isNaN(value) {
                        return isNumber(value) && value != +value;
                    }
                    function isNull(value) {
                        return value === null;
                    }
                    function isNumber(value) {
                        return typeof value == "number" || value && typeof value == "object" && toString.call(value) == numberClass || false;
                    }
                    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
                        if (!(value && toString.call(value) == objectClass)) {
                            return false;
                        }
                        var valueOf = value.valueOf, objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
                        return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
                    };
                    function isRegExp(value) {
                        return value && typeof value == "object" && toString.call(value) == regexpClass || false;
                    }
                    function isString(value) {
                        return typeof value == "string" || value && typeof value == "object" && toString.call(value) == stringClass || false;
                    }
                    function isUndefined(value) {
                        return typeof value == "undefined";
                    }
                    function mapValues(object, callback, thisArg) {
                        var result = {};
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwn(object, function(value, key, object) {
                            result[key] = callback(value, key, object);
                        });
                        return result;
                    }
                    function merge(object) {
                        var args = arguments, length = 2;
                        if (!isObject(object)) {
                            return object;
                        }
                        if (typeof args[2] != "number") {
                            length = args.length;
                        }
                        if (length > 3 && typeof args[length - 2] == "function") {
                            var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
                        } else if (length > 2 && typeof args[length - 1] == "function") {
                            callback = args[--length];
                        }
                        var sources = slice(arguments, 1, length), index = -1, stackA = getArray(), stackB = getArray();
                        while (++index < length) {
                            baseMerge(object, sources[index], callback, stackA, stackB);
                        }
                        releaseArray(stackA);
                        releaseArray(stackB);
                        return object;
                    }
                    function omit(object, callback, thisArg) {
                        var result = {};
                        if (typeof callback != "function") {
                            var props = [];
                            forIn(object, function(value, key) {
                                props.push(key);
                            });
                            props = baseDifference(props, baseFlatten(arguments, true, false, 1));
                            var index = -1, length = props.length;
                            while (++index < length) {
                                var key = props[index];
                                result[key] = object[key];
                            }
                        } else {
                            callback = lodash.createCallback(callback, thisArg, 3);
                            forIn(object, function(value, key, object) {
                                if (!callback(value, key, object)) {
                                    result[key] = value;
                                }
                            });
                        }
                        return result;
                    }
                    function pairs(object) {
                        var index = -1, props = keys(object), length = props.length, result = Array(length);
                        while (++index < length) {
                            var key = props[index];
                            result[index] = [ key, object[key] ];
                        }
                        return result;
                    }
                    function pick(object, callback, thisArg) {
                        var result = {};
                        if (typeof callback != "function") {
                            var index = -1, props = baseFlatten(arguments, true, false, 1), length = isObject(object) ? props.length : 0;
                            while (++index < length) {
                                var key = props[index];
                                if (key in object) {
                                    result[key] = object[key];
                                }
                            }
                        } else {
                            callback = lodash.createCallback(callback, thisArg, 3);
                            forIn(object, function(value, key, object) {
                                if (callback(value, key, object)) {
                                    result[key] = value;
                                }
                            });
                        }
                        return result;
                    }
                    function transform(object, callback, accumulator, thisArg) {
                        var isArr = isArray(object);
                        if (accumulator == null) {
                            if (isArr) {
                                accumulator = [];
                            } else {
                                var ctor = object && object.constructor, proto = ctor && ctor.prototype;
                                accumulator = baseCreate(proto);
                            }
                        }
                        if (callback) {
                            callback = lodash.createCallback(callback, thisArg, 4);
                            (isArr ? forEach : forOwn)(object, function(value, index, object) {
                                return callback(accumulator, value, index, object);
                            });
                        }
                        return accumulator;
                    }
                    function values(object) {
                        var index = -1, props = keys(object), length = props.length, result = Array(length);
                        while (++index < length) {
                            result[index] = object[props[index]];
                        }
                        return result;
                    }
                    function at(collection) {
                        var args = arguments, index = -1, props = baseFlatten(args, true, false, 1), length = args[2] && args[2][args[1]] === collection ? 1 : props.length, result = Array(length);
                        while (++index < length) {
                            result[index] = collection[props[index]];
                        }
                        return result;
                    }
                    function contains(collection, target, fromIndex) {
                        var index = -1, indexOf = getIndexOf(), length = collection ? collection.length : 0, result = false;
                        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
                        if (isArray(collection)) {
                            result = indexOf(collection, target, fromIndex) > -1;
                        } else if (typeof length == "number") {
                            result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
                        } else {
                            forOwn(collection, function(value) {
                                if (++index >= fromIndex) {
                                    return !(result = value === target);
                                }
                            });
                        }
                        return result;
                    }
                    var countBy = createAggregator(function(result, value, key) {
                        hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1;
                    });
                    function every(collection, callback, thisArg) {
                        var result = true;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                if (!(result = !!callback(collection[index], index, collection))) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                return result = !!callback(value, index, collection);
                            });
                        }
                        return result;
                    }
                    function filter(collection, callback, thisArg) {
                        var result = [];
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                var value = collection[index];
                                if (callback(value, index, collection)) {
                                    result.push(value);
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                if (callback(value, index, collection)) {
                                    result.push(value);
                                }
                            });
                        }
                        return result;
                    }
                    function find(collection, callback, thisArg) {
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                var value = collection[index];
                                if (callback(value, index, collection)) {
                                    return value;
                                }
                            }
                        } else {
                            var result;
                            forOwn(collection, function(value, index, collection) {
                                if (callback(value, index, collection)) {
                                    result = value;
                                    return false;
                                }
                            });
                            return result;
                        }
                    }
                    function findLast(collection, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forEachRight(collection, function(value, index, collection) {
                            if (callback(value, index, collection)) {
                                result = value;
                                return false;
                            }
                        });
                        return result;
                    }
                    function forEach(collection, callback, thisArg) {
                        var index = -1, length = collection ? collection.length : 0;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        if (typeof length == "number") {
                            while (++index < length) {
                                if (callback(collection[index], index, collection) === false) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, callback);
                        }
                        return collection;
                    }
                    function forEachRight(collection, callback, thisArg) {
                        var length = collection ? collection.length : 0;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        if (typeof length == "number") {
                            while (length--) {
                                if (callback(collection[length], length, collection) === false) {
                                    break;
                                }
                            }
                        } else {
                            var props = keys(collection);
                            length = props.length;
                            forOwn(collection, function(value, key, collection) {
                                key = props ? props[--length] : --length;
                                return callback(collection[key], key, collection);
                            });
                        }
                        return collection;
                    }
                    var groupBy = createAggregator(function(result, value, key) {
                        (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
                    });
                    var indexBy = createAggregator(function(result, value, key) {
                        result[key] = value;
                    });
                    function invoke(collection, methodName) {
                        var args = slice(arguments, 2), index = -1, isFunc = typeof methodName == "function", length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
                        forEach(collection, function(value) {
                            result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
                        });
                        return result;
                    }
                    function map(collection, callback, thisArg) {
                        var index = -1, length = collection ? collection.length : 0;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        if (typeof length == "number") {
                            var result = Array(length);
                            while (++index < length) {
                                result[index] = callback(collection[index], index, collection);
                            }
                        } else {
                            result = [];
                            forOwn(collection, function(value, key, collection) {
                                result[++index] = callback(value, key, collection);
                            });
                        }
                        return result;
                    }
                    function max(collection, callback, thisArg) {
                        var computed = -Infinity, result = computed;
                        if (typeof callback != "function" && thisArg && thisArg[callback] === collection) {
                            callback = null;
                        }
                        if (callback == null && isArray(collection)) {
                            var index = -1, length = collection.length;
                            while (++index < length) {
                                var value = collection[index];
                                if (value > result) {
                                    result = value;
                                }
                            }
                        } else {
                            callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                            forEach(collection, function(value, index, collection) {
                                var current = callback(value, index, collection);
                                if (current > computed) {
                                    computed = current;
                                    result = value;
                                }
                            });
                        }
                        return result;
                    }
                    function min(collection, callback, thisArg) {
                        var computed = Infinity, result = computed;
                        if (typeof callback != "function" && thisArg && thisArg[callback] === collection) {
                            callback = null;
                        }
                        if (callback == null && isArray(collection)) {
                            var index = -1, length = collection.length;
                            while (++index < length) {
                                var value = collection[index];
                                if (value < result) {
                                    result = value;
                                }
                            }
                        } else {
                            callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                            forEach(collection, function(value, index, collection) {
                                var current = callback(value, index, collection);
                                if (current < computed) {
                                    computed = current;
                                    result = value;
                                }
                            });
                        }
                        return result;
                    }
                    var pluck = map;
                    function reduce(collection, callback, accumulator, thisArg) {
                        if (!collection) return accumulator;
                        var noaccum = arguments.length < 3;
                        callback = lodash.createCallback(callback, thisArg, 4);
                        var index = -1, length = collection.length;
                        if (typeof length == "number") {
                            if (noaccum) {
                                accumulator = collection[++index];
                            }
                            while (++index < length) {
                                accumulator = callback(accumulator, collection[index], index, collection);
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
                            });
                        }
                        return accumulator;
                    }
                    function reduceRight(collection, callback, accumulator, thisArg) {
                        var noaccum = arguments.length < 3;
                        callback = lodash.createCallback(callback, thisArg, 4);
                        forEachRight(collection, function(value, index, collection) {
                            accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
                        });
                        return accumulator;
                    }
                    function reject(collection, callback, thisArg) {
                        callback = lodash.createCallback(callback, thisArg, 3);
                        return filter(collection, function(value, index, collection) {
                            return !callback(value, index, collection);
                        });
                    }
                    function sample(collection, n, guard) {
                        if (collection && typeof collection.length != "number") {
                            collection = values(collection);
                        }
                        if (n == null || guard) {
                            return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
                        }
                        var result = shuffle(collection);
                        result.length = nativeMin(nativeMax(0, n), result.length);
                        return result;
                    }
                    function shuffle(collection) {
                        var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
                        forEach(collection, function(value) {
                            var rand = baseRandom(0, ++index);
                            result[index] = result[rand];
                            result[rand] = value;
                        });
                        return result;
                    }
                    function size(collection) {
                        var length = collection ? collection.length : 0;
                        return typeof length == "number" ? length : keys(collection).length;
                    }
                    function some(collection, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                if (result = callback(collection[index], index, collection)) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                return !(result = callback(value, index, collection));
                            });
                        }
                        return !!result;
                    }
                    function sortBy(collection, callback, thisArg) {
                        var index = -1, isArr = isArray(callback), length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
                        if (!isArr) {
                            callback = lodash.createCallback(callback, thisArg, 3);
                        }
                        forEach(collection, function(value, key, collection) {
                            var object = result[++index] = getObject();
                            if (isArr) {
                                object.criteria = map(callback, function(key) {
                                    return value[key];
                                });
                            } else {
                                (object.criteria = getArray())[0] = callback(value, key, collection);
                            }
                            object.index = index;
                            object.value = value;
                        });
                        length = result.length;
                        result.sort(compareAscending);
                        while (length--) {
                            var object = result[length];
                            result[length] = object.value;
                            if (!isArr) {
                                releaseArray(object.criteria);
                            }
                            releaseObject(object);
                        }
                        return result;
                    }
                    function toArray(collection) {
                        if (collection && typeof collection.length == "number") {
                            return slice(collection);
                        }
                        return values(collection);
                    }
                    var where = filter;
                    function compact(array) {
                        var index = -1, length = array ? array.length : 0, result = [];
                        while (++index < length) {
                            var value = array[index];
                            if (value) {
                                result.push(value);
                            }
                        }
                        return result;
                    }
                    function difference(array) {
                        return baseDifference(array, baseFlatten(arguments, true, true, 1));
                    }
                    function findIndex(array, callback, thisArg) {
                        var index = -1, length = array ? array.length : 0;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (++index < length) {
                            if (callback(array[index], index, array)) {
                                return index;
                            }
                        }
                        return -1;
                    }
                    function findLastIndex(array, callback, thisArg) {
                        var length = array ? array.length : 0;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (length--) {
                            if (callback(array[length], length, array)) {
                                return length;
                            }
                        }
                        return -1;
                    }
                    function first(array, callback, thisArg) {
                        var n = 0, length = array ? array.length : 0;
                        if (typeof callback != "number" && callback != null) {
                            var index = -1;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (++index < length && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback;
                            if (n == null || thisArg) {
                                return array ? array[0] : undefined;
                            }
                        }
                        return slice(array, 0, nativeMin(nativeMax(0, n), length));
                    }
                    function flatten(array, isShallow, callback, thisArg) {
                        if (typeof isShallow != "boolean" && isShallow != null) {
                            thisArg = callback;
                            callback = typeof isShallow != "function" && thisArg && thisArg[isShallow] === array ? null : isShallow;
                            isShallow = false;
                        }
                        if (callback != null) {
                            array = map(array, callback, thisArg);
                        }
                        return baseFlatten(array, isShallow);
                    }
                    function indexOf(array, value, fromIndex) {
                        if (typeof fromIndex == "number") {
                            var length = array ? array.length : 0;
                            fromIndex = fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0;
                        } else if (fromIndex) {
                            var index = sortedIndex(array, value);
                            return array[index] === value ? index : -1;
                        }
                        return baseIndexOf(array, value, fromIndex);
                    }
                    function initial(array, callback, thisArg) {
                        var n = 0, length = array ? array.length : 0;
                        if (typeof callback != "number" && callback != null) {
                            var index = length;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (index-- && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback == null || thisArg ? 1 : callback || n;
                        }
                        return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
                    }
                    function intersection() {
                        var args = [], argsIndex = -1, argsLength = arguments.length, caches = getArray(), indexOf = getIndexOf(), trustIndexOf = indexOf === baseIndexOf, seen = getArray();
                        while (++argsIndex < argsLength) {
                            var value = arguments[argsIndex];
                            if (isArray(value) || isArguments(value)) {
                                args.push(value);
                                caches.push(trustIndexOf && value.length >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen));
                            }
                        }
                        var array = args[0], index = -1, length = array ? array.length : 0, result = [];
                        outer: while (++index < length) {
                            var cache = caches[0];
                            value = array[index];
                            if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                                argsIndex = argsLength;
                                (cache || seen).push(value);
                                while (--argsIndex) {
                                    cache = caches[argsIndex];
                                    if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                                        continue outer;
                                    }
                                }
                                result.push(value);
                            }
                        }
                        while (argsLength--) {
                            cache = caches[argsLength];
                            if (cache) {
                                releaseObject(cache);
                            }
                        }
                        releaseArray(caches);
                        releaseArray(seen);
                        return result;
                    }
                    function last(array, callback, thisArg) {
                        var n = 0, length = array ? array.length : 0;
                        if (typeof callback != "number" && callback != null) {
                            var index = length;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (index-- && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback;
                            if (n == null || thisArg) {
                                return array ? array[length - 1] : undefined;
                            }
                        }
                        return slice(array, nativeMax(0, length - n));
                    }
                    function lastIndexOf(array, value, fromIndex) {
                        var index = array ? array.length : 0;
                        if (typeof fromIndex == "number") {
                            index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
                        }
                        while (index--) {
                            if (array[index] === value) {
                                return index;
                            }
                        }
                        return -1;
                    }
                    function pull(array) {
                        var args = arguments, argsIndex = 0, argsLength = args.length, length = array ? array.length : 0;
                        while (++argsIndex < argsLength) {
                            var index = -1, value = args[argsIndex];
                            while (++index < length) {
                                if (array[index] === value) {
                                    splice.call(array, index--, 1);
                                    length--;
                                }
                            }
                        }
                        return array;
                    }
                    function range(start, end, step) {
                        start = +start || 0;
                        step = typeof step == "number" ? step : +step || 1;
                        if (end == null) {
                            end = start;
                            start = 0;
                        }
                        var index = -1, length = nativeMax(0, ceil((end - start) / (step || 1))), result = Array(length);
                        while (++index < length) {
                            result[index] = start;
                            start += step;
                        }
                        return result;
                    }
                    function remove(array, callback, thisArg) {
                        var index = -1, length = array ? array.length : 0, result = [];
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (++index < length) {
                            var value = array[index];
                            if (callback(value, index, array)) {
                                result.push(value);
                                splice.call(array, index--, 1);
                                length--;
                            }
                        }
                        return result;
                    }
                    function rest(array, callback, thisArg) {
                        if (typeof callback != "number" && callback != null) {
                            var n = 0, index = -1, length = array ? array.length : 0;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (++index < length && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback == null || thisArg ? 1 : nativeMax(0, callback);
                        }
                        return slice(array, n);
                    }
                    function sortedIndex(array, value, callback, thisArg) {
                        var low = 0, high = array ? array.length : low;
                        callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
                        value = callback(value);
                        while (low < high) {
                            var mid = low + high >>> 1;
                            callback(array[mid]) < value ? low = mid + 1 : high = mid;
                        }
                        return low;
                    }
                    function union() {
                        return baseUniq(baseFlatten(arguments, true, true));
                    }
                    function uniq(array, isSorted, callback, thisArg) {
                        if (typeof isSorted != "boolean" && isSorted != null) {
                            thisArg = callback;
                            callback = typeof isSorted != "function" && thisArg && thisArg[isSorted] === array ? null : isSorted;
                            isSorted = false;
                        }
                        if (callback != null) {
                            callback = lodash.createCallback(callback, thisArg, 3);
                        }
                        return baseUniq(array, isSorted, callback);
                    }
                    function without(array) {
                        return baseDifference(array, slice(arguments, 1));
                    }
                    function xor() {
                        var index = -1, length = arguments.length;
                        while (++index < length) {
                            var array = arguments[index];
                            if (isArray(array) || isArguments(array)) {
                                var result = result ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result))) : array;
                            }
                        }
                        return result || [];
                    }
                    function zip() {
                        var array = arguments.length > 1 ? arguments : arguments[0], index = -1, length = array ? max(pluck(array, "length")) : 0, result = Array(length < 0 ? 0 : length);
                        while (++index < length) {
                            result[index] = pluck(array, index);
                        }
                        return result;
                    }
                    function zipObject(keys, values) {
                        var index = -1, length = keys ? keys.length : 0, result = {};
                        if (!values && length && !isArray(keys[0])) {
                            values = [];
                        }
                        while (++index < length) {
                            var key = keys[index];
                            if (values) {
                                result[key] = values[index];
                            } else if (key) {
                                result[key[0]] = key[1];
                            }
                        }
                        return result;
                    }
                    function after(n, func) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        return function() {
                            if (--n < 1) {
                                return func.apply(this, arguments);
                            }
                        };
                    }
                    function bind(func, thisArg) {
                        return arguments.length > 2 ? createWrapper(func, 17, slice(arguments, 2), null, thisArg) : createWrapper(func, 1, null, null, thisArg);
                    }
                    function bindAll(object) {
                        var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object), index = -1, length = funcs.length;
                        while (++index < length) {
                            var key = funcs[index];
                            object[key] = createWrapper(object[key], 1, null, null, object);
                        }
                        return object;
                    }
                    function bindKey(object, key) {
                        return arguments.length > 2 ? createWrapper(key, 19, slice(arguments, 2), null, object) : createWrapper(key, 3, null, null, object);
                    }
                    function compose() {
                        var funcs = arguments, length = funcs.length;
                        while (length--) {
                            if (!isFunction(funcs[length])) {
                                throw new TypeError();
                            }
                        }
                        return function() {
                            var args = arguments, length = funcs.length;
                            while (length--) {
                                args = [ funcs[length].apply(this, args) ];
                            }
                            return args[0];
                        };
                    }
                    function curry(func, arity) {
                        arity = typeof arity == "number" ? arity : +arity || func.length;
                        return createWrapper(func, 4, null, null, null, arity);
                    }
                    function debounce(func, wait, options) {
                        var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = false, trailing = true;
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        wait = nativeMax(0, wait) || 0;
                        if (options === true) {
                            var leading = true;
                            trailing = false;
                        } else if (isObject(options)) {
                            leading = options.leading;
                            maxWait = "maxWait" in options && (nativeMax(wait, options.maxWait) || 0);
                            trailing = "trailing" in options ? options.trailing : trailing;
                        }
                        var delayed = function() {
                            var remaining = wait - (now() - stamp);
                            if (remaining <= 0) {
                                if (maxTimeoutId) {
                                    clearTimeout(maxTimeoutId);
                                }
                                var isCalled = trailingCall;
                                maxTimeoutId = timeoutId = trailingCall = undefined;
                                if (isCalled) {
                                    lastCalled = now();
                                    result = func.apply(thisArg, args);
                                    if (!timeoutId && !maxTimeoutId) {
                                        args = thisArg = null;
                                    }
                                }
                            } else {
                                timeoutId = setTimeout(delayed, remaining);
                            }
                        };
                        var maxDelayed = function() {
                            if (timeoutId) {
                                clearTimeout(timeoutId);
                            }
                            maxTimeoutId = timeoutId = trailingCall = undefined;
                            if (trailing || maxWait !== wait) {
                                lastCalled = now();
                                result = func.apply(thisArg, args);
                                if (!timeoutId && !maxTimeoutId) {
                                    args = thisArg = null;
                                }
                            }
                        };
                        return function() {
                            args = arguments;
                            stamp = now();
                            thisArg = this;
                            trailingCall = trailing && (timeoutId || !leading);
                            if (maxWait === false) {
                                var leadingCall = leading && !timeoutId;
                            } else {
                                if (!maxTimeoutId && !leading) {
                                    lastCalled = stamp;
                                }
                                var remaining = maxWait - (stamp - lastCalled), isCalled = remaining <= 0;
                                if (isCalled) {
                                    if (maxTimeoutId) {
                                        maxTimeoutId = clearTimeout(maxTimeoutId);
                                    }
                                    lastCalled = stamp;
                                    result = func.apply(thisArg, args);
                                } else if (!maxTimeoutId) {
                                    maxTimeoutId = setTimeout(maxDelayed, remaining);
                                }
                            }
                            if (isCalled && timeoutId) {
                                timeoutId = clearTimeout(timeoutId);
                            } else if (!timeoutId && wait !== maxWait) {
                                timeoutId = setTimeout(delayed, wait);
                            }
                            if (leadingCall) {
                                isCalled = true;
                                result = func.apply(thisArg, args);
                            }
                            if (isCalled && !timeoutId && !maxTimeoutId) {
                                args = thisArg = null;
                            }
                            return result;
                        };
                    }
                    function defer(func) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        var args = slice(arguments, 1);
                        return setTimeout(function() {
                            func.apply(undefined, args);
                        }, 1);
                    }
                    function delay(func, wait) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        var args = slice(arguments, 2);
                        return setTimeout(function() {
                            func.apply(undefined, args);
                        }, wait);
                    }
                    function memoize(func, resolver) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        var memoized = function() {
                            var cache = memoized.cache, key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
                            return hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = func.apply(this, arguments);
                        };
                        memoized.cache = {};
                        return memoized;
                    }
                    function once(func) {
                        var ran, result;
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        return function() {
                            if (ran) {
                                return result;
                            }
                            ran = true;
                            result = func.apply(this, arguments);
                            func = null;
                            return result;
                        };
                    }
                    function partial(func) {
                        return createWrapper(func, 16, slice(arguments, 1));
                    }
                    function partialRight(func) {
                        return createWrapper(func, 32, null, slice(arguments, 1));
                    }
                    function throttle(func, wait, options) {
                        var leading = true, trailing = true;
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        if (options === false) {
                            leading = false;
                        } else if (isObject(options)) {
                            leading = "leading" in options ? options.leading : leading;
                            trailing = "trailing" in options ? options.trailing : trailing;
                        }
                        debounceOptions.leading = leading;
                        debounceOptions.maxWait = wait;
                        debounceOptions.trailing = trailing;
                        return debounce(func, wait, debounceOptions);
                    }
                    function wrap(value, wrapper) {
                        return createWrapper(wrapper, 16, [ value ]);
                    }
                    function constant(value) {
                        return function() {
                            return value;
                        };
                    }
                    function createCallback(func, thisArg, argCount) {
                        var type = typeof func;
                        if (func == null || type == "function") {
                            return baseCreateCallback(func, thisArg, argCount);
                        }
                        if (type != "object") {
                            return property(func);
                        }
                        var props = keys(func), key = props[0], a = func[key];
                        if (props.length == 1 && a === a && !isObject(a)) {
                            return function(object) {
                                var b = object[key];
                                return a === b && (a !== 0 || 1 / a == 1 / b);
                            };
                        }
                        return function(object) {
                            var length = props.length, result = false;
                            while (length--) {
                                if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
                                    break;
                                }
                            }
                            return result;
                        };
                    }
                    function escape(string) {
                        return string == null ? "" : String(string).replace(reUnescapedHtml, escapeHtmlChar);
                    }
                    function identity(value) {
                        return value;
                    }
                    function mixin(object, source, options) {
                        var chain = true, methodNames = source && functions(source);
                        if (!source || !options && !methodNames.length) {
                            if (options == null) {
                                options = source;
                            }
                            ctor = lodashWrapper;
                            source = object;
                            object = lodash;
                            methodNames = functions(source);
                        }
                        if (options === false) {
                            chain = false;
                        } else if (isObject(options) && "chain" in options) {
                            chain = options.chain;
                        }
                        var ctor = object, isFunc = isFunction(ctor);
                        forEach(methodNames, function(methodName) {
                            var func = object[methodName] = source[methodName];
                            if (isFunc) {
                                ctor.prototype[methodName] = function() {
                                    var chainAll = this.__chain__, value = this.__wrapped__, args = [ value ];
                                    push.apply(args, arguments);
                                    var result = func.apply(object, args);
                                    if (chain || chainAll) {
                                        if (value === result && isObject(result)) {
                                            return this;
                                        }
                                        result = new ctor(result);
                                        result.__chain__ = chainAll;
                                    }
                                    return result;
                                };
                            }
                        });
                    }
                    function noConflict() {
                        context._ = oldDash;
                        return this;
                    }
                    function noop() {}
                    var now = isNative(now = Date.now) && now || function() {
                        return new Date().getTime();
                    };
                    var parseInt = nativeParseInt(whitespace + "08") == 8 ? nativeParseInt : function(value, radix) {
                        return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, "") : value, radix || 0);
                    };
                    function property(key) {
                        return function(object) {
                            return object[key];
                        };
                    }
                    function random(min, max, floating) {
                        var noMin = min == null, noMax = max == null;
                        if (floating == null) {
                            if (typeof min == "boolean" && noMax) {
                                floating = min;
                                min = 1;
                            } else if (!noMax && typeof max == "boolean") {
                                floating = max;
                                noMax = true;
                            }
                        }
                        if (noMin && noMax) {
                            max = 1;
                        }
                        min = +min || 0;
                        if (noMax) {
                            max = min;
                            min = 0;
                        } else {
                            max = +max || 0;
                        }
                        if (floating || min % 1 || max % 1) {
                            var rand = nativeRandom();
                            return nativeMin(min + rand * (max - min + parseFloat("1e-" + ((rand + "").length - 1))), max);
                        }
                        return baseRandom(min, max);
                    }
                    function result(object, key) {
                        if (object) {
                            var value = object[key];
                            return isFunction(value) ? object[key]() : value;
                        }
                    }
                    function template(text, data, options) {
                        var settings = lodash.templateSettings;
                        text = String(text || "");
                        options = defaults({}, options, settings);
                        var imports = defaults({}, options.imports, settings.imports), importsKeys = keys(imports), importsValues = values(imports);
                        var isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
                        var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
                        text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                            interpolateValue || (interpolateValue = esTemplateValue);
                            source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                            if (escapeValue) {
                                source += "' +\n__e(" + escapeValue + ") +\n'";
                            }
                            if (evaluateValue) {
                                isEvaluating = true;
                                source += "';\n" + evaluateValue + ";\n__p += '";
                            }
                            if (interpolateValue) {
                                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                            }
                            index = offset + match.length;
                            return match;
                        });
                        source += "';\n";
                        var variable = options.variable, hasVariable = variable;
                        if (!hasVariable) {
                            variable = "obj";
                            source = "with (" + variable + ") {\n" + source + "\n}\n";
                        }
                        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
                        source = "function(" + variable + ") {\n" + (hasVariable ? "" : variable + " || (" + variable + " = {});\n") + "var __t, __p = '', __e = _.escape" + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                        var sourceURL = "\n/*\n//# sourceURL=" + (options.sourceURL || "/lodash/template/source[" + templateCounter++ + "]") + "\n*/";
                        try {
                            var result = Function(importsKeys, "return " + source + sourceURL).apply(undefined, importsValues);
                        } catch (e) {
                            e.source = source;
                            throw e;
                        }
                        if (data) {
                            return result(data);
                        }
                        result.source = source;
                        return result;
                    }
                    function times(n, callback, thisArg) {
                        n = (n = +n) > -1 ? n : 0;
                        var index = -1, result = Array(n);
                        callback = baseCreateCallback(callback, thisArg, 1);
                        while (++index < n) {
                            result[index] = callback(index);
                        }
                        return result;
                    }
                    function unescape(string) {
                        return string == null ? "" : String(string).replace(reEscapedHtml, unescapeHtmlChar);
                    }
                    function uniqueId(prefix) {
                        var id = ++idCounter;
                        return String(prefix == null ? "" : prefix) + id;
                    }
                    function chain(value) {
                        value = new lodashWrapper(value);
                        value.__chain__ = true;
                        return value;
                    }
                    function tap(value, interceptor) {
                        interceptor(value);
                        return value;
                    }
                    function wrapperChain() {
                        this.__chain__ = true;
                        return this;
                    }
                    function wrapperToString() {
                        return String(this.__wrapped__);
                    }
                    function wrapperValueOf() {
                        return this.__wrapped__;
                    }
                    lodash.after = after;
                    lodash.assign = assign;
                    lodash.at = at;
                    lodash.bind = bind;
                    lodash.bindAll = bindAll;
                    lodash.bindKey = bindKey;
                    lodash.chain = chain;
                    lodash.compact = compact;
                    lodash.compose = compose;
                    lodash.constant = constant;
                    lodash.countBy = countBy;
                    lodash.create = create;
                    lodash.createCallback = createCallback;
                    lodash.curry = curry;
                    lodash.debounce = debounce;
                    lodash.defaults = defaults;
                    lodash.defer = defer;
                    lodash.delay = delay;
                    lodash.difference = difference;
                    lodash.filter = filter;
                    lodash.flatten = flatten;
                    lodash.forEach = forEach;
                    lodash.forEachRight = forEachRight;
                    lodash.forIn = forIn;
                    lodash.forInRight = forInRight;
                    lodash.forOwn = forOwn;
                    lodash.forOwnRight = forOwnRight;
                    lodash.functions = functions;
                    lodash.groupBy = groupBy;
                    lodash.indexBy = indexBy;
                    lodash.initial = initial;
                    lodash.intersection = intersection;
                    lodash.invert = invert;
                    lodash.invoke = invoke;
                    lodash.keys = keys;
                    lodash.map = map;
                    lodash.mapValues = mapValues;
                    lodash.max = max;
                    lodash.memoize = memoize;
                    lodash.merge = merge;
                    lodash.min = min;
                    lodash.omit = omit;
                    lodash.once = once;
                    lodash.pairs = pairs;
                    lodash.partial = partial;
                    lodash.partialRight = partialRight;
                    lodash.pick = pick;
                    lodash.pluck = pluck;
                    lodash.property = property;
                    lodash.pull = pull;
                    lodash.range = range;
                    lodash.reject = reject;
                    lodash.remove = remove;
                    lodash.rest = rest;
                    lodash.shuffle = shuffle;
                    lodash.sortBy = sortBy;
                    lodash.tap = tap;
                    lodash.throttle = throttle;
                    lodash.times = times;
                    lodash.toArray = toArray;
                    lodash.transform = transform;
                    lodash.union = union;
                    lodash.uniq = uniq;
                    lodash.values = values;
                    lodash.where = where;
                    lodash.without = without;
                    lodash.wrap = wrap;
                    lodash.xor = xor;
                    lodash.zip = zip;
                    lodash.zipObject = zipObject;
                    lodash.collect = map;
                    lodash.drop = rest;
                    lodash.each = forEach;
                    lodash.eachRight = forEachRight;
                    lodash.extend = assign;
                    lodash.methods = functions;
                    lodash.object = zipObject;
                    lodash.select = filter;
                    lodash.tail = rest;
                    lodash.unique = uniq;
                    lodash.unzip = zip;
                    mixin(lodash);
                    lodash.clone = clone;
                    lodash.cloneDeep = cloneDeep;
                    lodash.contains = contains;
                    lodash.escape = escape;
                    lodash.every = every;
                    lodash.find = find;
                    lodash.findIndex = findIndex;
                    lodash.findKey = findKey;
                    lodash.findLast = findLast;
                    lodash.findLastIndex = findLastIndex;
                    lodash.findLastKey = findLastKey;
                    lodash.has = has;
                    lodash.identity = identity;
                    lodash.indexOf = indexOf;
                    lodash.isArguments = isArguments;
                    lodash.isArray = isArray;
                    lodash.isBoolean = isBoolean;
                    lodash.isDate = isDate;
                    lodash.isElement = isElement;
                    lodash.isEmpty = isEmpty;
                    lodash.isEqual = isEqual;
                    lodash.isFinite = isFinite;
                    lodash.isFunction = isFunction;
                    lodash.isNaN = isNaN;
                    lodash.isNull = isNull;
                    lodash.isNumber = isNumber;
                    lodash.isObject = isObject;
                    lodash.isPlainObject = isPlainObject;
                    lodash.isRegExp = isRegExp;
                    lodash.isString = isString;
                    lodash.isUndefined = isUndefined;
                    lodash.lastIndexOf = lastIndexOf;
                    lodash.mixin = mixin;
                    lodash.noConflict = noConflict;
                    lodash.noop = noop;
                    lodash.now = now;
                    lodash.parseInt = parseInt;
                    lodash.random = random;
                    lodash.reduce = reduce;
                    lodash.reduceRight = reduceRight;
                    lodash.result = result;
                    lodash.runInContext = runInContext;
                    lodash.size = size;
                    lodash.some = some;
                    lodash.sortedIndex = sortedIndex;
                    lodash.template = template;
                    lodash.unescape = unescape;
                    lodash.uniqueId = uniqueId;
                    lodash.all = every;
                    lodash.any = some;
                    lodash.detect = find;
                    lodash.findWhere = find;
                    lodash.foldl = reduce;
                    lodash.foldr = reduceRight;
                    lodash.include = contains;
                    lodash.inject = reduce;
                    mixin(function() {
                        var source = {};
                        forOwn(lodash, function(func, methodName) {
                            if (!lodash.prototype[methodName]) {
                                source[methodName] = func;
                            }
                        });
                        return source;
                    }(), false);
                    lodash.first = first;
                    lodash.last = last;
                    lodash.sample = sample;
                    lodash.take = first;
                    lodash.head = first;
                    forOwn(lodash, function(func, methodName) {
                        var callbackable = methodName !== "sample";
                        if (!lodash.prototype[methodName]) {
                            lodash.prototype[methodName] = function(n, guard) {
                                var chainAll = this.__chain__, result = func(this.__wrapped__, n, guard);
                                return !chainAll && (n == null || guard && !(callbackable && typeof n == "function")) ? result : new lodashWrapper(result, chainAll);
                            };
                        }
                    });
                    lodash.VERSION = "2.4.1";
                    lodash.prototype.chain = wrapperChain;
                    lodash.prototype.toString = wrapperToString;
                    lodash.prototype.value = wrapperValueOf;
                    lodash.prototype.valueOf = wrapperValueOf;
                    forEach([ "join", "pop", "shift" ], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            var chainAll = this.__chain__, result = func.apply(this.__wrapped__, arguments);
                            return chainAll ? new lodashWrapper(result, chainAll) : result;
                        };
                    });
                    forEach([ "push", "reverse", "sort", "unshift" ], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            func.apply(this.__wrapped__, arguments);
                            return this;
                        };
                    });
                    forEach([ "concat", "slice", "splice" ], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
                        };
                    });
                    return lodash;
                }
                var _ = runInContext();
                if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
                    root._ = _;
                    define(function() {
                        return _;
                    });
                } else if (freeExports && freeModule) {
                    if (moduleExports) {
                        (freeModule.exports = _)._ = _;
                    } else {
                        freeExports._ = _;
                    }
                } else {
                    root._ = _;
                }
            }).call(this);
        }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {} ],
    2: [ function(require, module, exports) {
        var keys, lastEmittedValue, _, __indexOf = [].indexOf || function(item) {
            for (var i = 0, l = this.length; i < l; i++) {
                if (i in this && this[i] === item) return i;
            }
            return -1;
        };
        _ = require("lodash");
        lastEmittedValue = null;
        keys = {
            up: 38,
            down: 40,
            enter: 13,
            escape: 27,
            tab: 9
        };
        Polymer("ui-typeahead", {
            selectItem: function(item) {
                var index, items;
                items = this.querySelectorAll("ui-typeahead-item");
                if (item) {
                    this.setAttribute("selected", "");
                    this.$.input.setAttribute("hide", "");
                } else {
                    this.removeAttribute("selected");
                    this.$.input.removeAttribute("hide");
                    this.$.input.focus();
                }
                _.each(items, function(_this) {
                    return function(i) {
                        i.removeAttribute("focused");
                        if (i === item) {
                            if (_this.hasAttribute("selected") && i.hasAttribute("selected")) {
                                return _this.clear(false);
                            }
                            return i.setAttribute("selected", "");
                        } else {
                            return i.removeAttribute("selected");
                        }
                    };
                }(this));
                index = _.indexOf(items, item);
                return this.fire("change", {
                    item: item,
                    index: index
                });
            },
            clear: function(clearInput) {
                if (clearInput == null) {
                    clearInput = true;
                }
                this.selectItem(null);
                if (clearInput) {
                    return this.$.input.value = null;
                }
            },
            focus: function(evt) {
                return this.classList.add("focused");
            },
            documentClick: function(evt) {
                return this.classList.remove("focused");
            },
            click: function(evt) {
                var _ref;
                evt.stopPropagation();
                if (_ref = evt.target, __indexOf.call(this.querySelectorAll("ui-typeahead-item"), _ref) >= 0) {
                    return this.selectItem(evt.target);
                }
            },
            keyup: function(evt) {
                var bottom, focusIndex, height, items, maxHeight, top, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
                items = this.querySelectorAll("ui-typeahead-item");
                focusIndex = _.findIndex(items, function(i) {
                    return i.hasAttribute("focused");
                });
                this.removeAttribute("selected");
                if (evt.which === keys.down) {
                    if ((_ref = items[focusIndex]) != null) {
                        _ref.removeAttribute("focused");
                    }
                    if ((_ref1 = items[(focusIndex + 1) % items.length]) != null) {
                        _ref1.setAttribute("focused", "");
                    }
                } else if (evt.which === keys.up) {
                    if ((_ref2 = items[focusIndex]) != null) {
                        _ref2.removeAttribute("focused");
                    }
                    if (focusIndex <= 0) {
                        focusIndex = items.length;
                    }
                    if ((_ref3 = items[focusIndex - 1]) != null) {
                        _ref3.setAttribute("focused", "");
                    }
                } else if ((_ref4 = evt.which) === keys.enter || _ref4 === keys.tab) {
                    this.selectItem(items[focusIndex]);
                } else if (evt.which === keys.escape) {
                    if ((_ref5 = items[focusIndex]) != null) {
                        _ref5.focused = false;
                    }
                    this.selectItem(null);
                    this.fire("inputChange", {
                        value: null
                    });
                } else {
                    this.debouncedKeyPress(evt);
                }
                bottom = window.scrollY + window.innerHeight;
                top = this.$.results.getBoundingClientRect().top;
                height = this.$.results.scrollHeight;
                if (top + height > bottom) {
                    maxHeight = bottom - top;
                    this.$.results.style.maxHeight = "" + maxHeight + "px";
                    if (((_ref6 = this.querySelector("[focused]")) != null ? _ref6.offsetTop : void 0) > maxHeight) {
                        this.$.results.scrollTop = (_ref7 = this.querySelector("[focused]")) != null ? _ref7.offsetTop : void 0;
                    }
                    if (((_ref8 = this.querySelector("[focused]")) != null ? _ref8.offsetTop : void 0) < this.$.results.scrollTop) {
                        return this.$.results.scrollTop = (_ref9 = this.querySelector("[focused]")) != null ? _ref9.offsetTop : void 0;
                    }
                } else {
                    return this.$.results.style.maxHeight = "";
                }
            },
            dataChanged: function(oldVal, newVal) {
                return this.querySelector("template").model = newVal;
            },
            attached: function() {
                this.debounce || (this.debounce = 300);
                this.debouncedKeyPress = _.debounce(function() {
                    if (this.$.input.value !== lastEmittedValue) {
                        lastEmittedValue = this.$.input.value;
                        return this.fire("inputChange", {
                            value: this.$.input.value
                        });
                    }
                }, this.debounce);
                this.addEventListener("click", this.click);
                this.addEventListener("focus", this.focus);
                this.addEventListener("keyup", this.keyup);
                return window.addEventListener("click", function(_this) {
                    return function(evt) {
                        return _this.documentClick(evt);
                    };
                }(this));
            },
            detached: function() {
                return window.removeEventListener("click", this.documentClick);
            }
        });
    }, {
        lodash: 1
    } ]
}, {}, [ 2 ]);</script>
</polymer-element>

<polymer-element name="ui-typeahead-item" attributes="focused selected model value">
<template>
  <style>.hide {
  display: none !important;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(0, 0, 0, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease;
  -webkit-transition: opacity 0.2s ease;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease, opacity 0.2s ease;
  -webkit-transition: height 0.2s ease, opacity 0.2s ease;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
.sheen {
  background-image: linear-gradient(rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.1));
}
:host {
  display: block;
  cursor: pointer;
  padding: 0.65em;
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
  color: rgba(69, 69, 69, 0.85);
  box-sizing: border-box;
}
:host([focused]) {
  background-image: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1));
}
:host([selected]) {
  border: 0;
}
</style>
  <content></content>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-typeahead/src/ui-typeahead-item.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        Polymer("ui-typeahead-item", {
            rebubbleClick: function(evt) {
                if (evt.target !== this) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    return this.fire("click");
                }
            },
            attached: function() {
                return this.addEventListener("click", this.rebubbleClick);
            }
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>

<polymer-element name="ui-toolbar-button" attributes="icon active enabled toggle selected" on-mousedown="{{pointerdown}}" on-mouseup="{{pointerup}}" on-mouseenter="{{pointerenter}}" on-mouseleave="{{pointerleave}}" on-click="{{pointerclick}}">
<template>
  <style>.hide {
  display: none !important;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(0, 0, 0, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease;
  -webkit-transition: opacity 0.2s ease;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease, opacity 0.2s ease;
  -webkit-transition: height 0.2s ease, opacity 0.2s ease;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
.sheen {
  background-image: linear-gradient(rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.1));
}
.fa {
  display: inline-block;
  font-family: FontAwesome;
  font-style: normal;
  font-weight: normal;
  line-height: 1;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
/* makes the font 33% larger relative to the icon container */
.fa-lg {
  font-size: 1.33333333em;
  line-height: 0.75em;
  vertical-align: -15%;
}
.fa-2x {
  font-size: 2em;
}
.fa-3x {
  font-size: 3em;
}
.fa-4x {
  font-size: 4em;
}
.fa-5x {
  font-size: 5em;
}
.fa-fw {
  width: 1.28571429em;
  text-align: center;
}
.fa-ul {
  padding-left: 0;
  margin-left: 2.14285714em;
  list-style-type: none;
}
.fa-ul > li {
  position: relative;
}
.fa-li {
  position: absolute;
  left: -2.14285714em;
  width: 2.14285714em;
  top: 0.14285714em;
  text-align: center;
}
.fa-li.fa-lg {
  left: -1.85714286em;
}
.fa-border {
  padding: .2em .25em .15em;
  border: solid 0.08em #eeeeee;
  border-radius: .1em;
}
.pull-right {
  float: right;
}
.pull-left {
  float: left;
}
.fa.pull-left {
  margin-right: .3em;
}
.fa.pull-right {
  margin-left: .3em;
}
.fa-spin {
  -webkit-animation: spin 2s infinite linear;
  -moz-animation: spin 2s infinite linear;
  -o-animation: spin 2s infinite linear;
  animation: spin 2s infinite linear;
}
@-moz-keyframes spin {
  0% {
    -moz-transform: rotate(0deg);
  }
  100% {
    -moz-transform: rotate(359deg);
  }
}
@-webkit-keyframes spin {
  0% {
    -webkit-transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(359deg);
  }
}
@-o-keyframes spin {
  0% {
    -o-transform: rotate(0deg);
  }
  100% {
    -o-transform: rotate(359deg);
  }
}
@keyframes spin {
  0% {
    -webkit-transform: rotate(0deg);
    transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(359deg);
    transform: rotate(359deg);
  }
}
.fa-rotate-90 {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=1);
  -webkit-transform: rotate(90deg);
  -moz-transform: rotate(90deg);
  -ms-transform: rotate(90deg);
  -o-transform: rotate(90deg);
  transform: rotate(90deg);
}
.fa-rotate-180 {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=2);
  -webkit-transform: rotate(180deg);
  -moz-transform: rotate(180deg);
  -ms-transform: rotate(180deg);
  -o-transform: rotate(180deg);
  transform: rotate(180deg);
}
.fa-rotate-270 {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=3);
  -webkit-transform: rotate(270deg);
  -moz-transform: rotate(270deg);
  -ms-transform: rotate(270deg);
  -o-transform: rotate(270deg);
  transform: rotate(270deg);
}
.fa-flip-horizontal {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1);
  -webkit-transform: scale(-1, 1);
  -moz-transform: scale(-1, 1);
  -ms-transform: scale(-1, 1);
  -o-transform: scale(-1, 1);
  transform: scale(-1, 1);
}
.fa-flip-vertical {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1);
  -webkit-transform: scale(1, -1);
  -moz-transform: scale(1, -1);
  -ms-transform: scale(1, -1);
  -o-transform: scale(1, -1);
  transform: scale(1, -1);
}
.fa-stack {
  position: relative;
  display: inline-block;
  width: 2em;
  height: 2em;
  line-height: 2em;
  vertical-align: middle;
}
.fa-stack-1x,
.fa-stack-2x {
  position: absolute;
  left: 0;
  width: 100%;
  text-align: center;
}
.fa-stack-1x {
  line-height: inherit;
}
.fa-stack-2x {
  font-size: 2em;
}
.fa-inverse {
  color: #ffffff;
}
/* Font Awesome uses the Unicode Private Use Area (PUA) to ensure screen
   readers do not read off random characters that represent icons */
.fa-glass:before {
  content: "\f000";
}
.fa-music:before {
  content: "\f001";
}
.fa-search:before {
  content: "\f002";
}
.fa-envelope-o:before {
  content: "\f003";
}
.fa-heart:before {
  content: "\f004";
}
.fa-star:before {
  content: "\f005";
}
.fa-star-o:before {
  content: "\f006";
}
.fa-user:before {
  content: "\f007";
}
.fa-film:before {
  content: "\f008";
}
.fa-th-large:before {
  content: "\f009";
}
.fa-th:before {
  content: "\f00a";
}
.fa-th-list:before {
  content: "\f00b";
}
.fa-check:before {
  content: "\f00c";
}
.fa-times:before {
  content: "\f00d";
}
.fa-search-plus:before {
  content: "\f00e";
}
.fa-search-minus:before {
  content: "\f010";
}
.fa-power-off:before {
  content: "\f011";
}
.fa-signal:before {
  content: "\f012";
}
.fa-gear:before,
.fa-cog:before {
  content: "\f013";
}
.fa-trash-o:before {
  content: "\f014";
}
.fa-home:before {
  content: "\f015";
}
.fa-file-o:before {
  content: "\f016";
}
.fa-clock-o:before {
  content: "\f017";
}
.fa-road:before {
  content: "\f018";
}
.fa-download:before {
  content: "\f019";
}
.fa-arrow-circle-o-down:before {
  content: "\f01a";
}
.fa-arrow-circle-o-up:before {
  content: "\f01b";
}
.fa-inbox:before {
  content: "\f01c";
}
.fa-play-circle-o:before {
  content: "\f01d";
}
.fa-rotate-right:before,
.fa-repeat:before {
  content: "\f01e";
}
.fa-refresh:before {
  content: "\f021";
}
.fa-list-alt:before {
  content: "\f022";
}
.fa-lock:before {
  content: "\f023";
}
.fa-flag:before {
  content: "\f024";
}
.fa-headphones:before {
  content: "\f025";
}
.fa-volume-off:before {
  content: "\f026";
}
.fa-volume-down:before {
  content: "\f027";
}
.fa-volume-up:before {
  content: "\f028";
}
.fa-qrcode:before {
  content: "\f029";
}
.fa-barcode:before {
  content: "\f02a";
}
.fa-tag:before {
  content: "\f02b";
}
.fa-tags:before {
  content: "\f02c";
}
.fa-book:before {
  content: "\f02d";
}
.fa-bookmark:before {
  content: "\f02e";
}
.fa-print:before {
  content: "\f02f";
}
.fa-camera:before {
  content: "\f030";
}
.fa-font:before {
  content: "\f031";
}
.fa-bold:before {
  content: "\f032";
}
.fa-italic:before {
  content: "\f033";
}
.fa-text-height:before {
  content: "\f034";
}
.fa-text-width:before {
  content: "\f035";
}
.fa-align-left:before {
  content: "\f036";
}
.fa-align-center:before {
  content: "\f037";
}
.fa-align-right:before {
  content: "\f038";
}
.fa-align-justify:before {
  content: "\f039";
}
.fa-list:before {
  content: "\f03a";
}
.fa-dedent:before,
.fa-outdent:before {
  content: "\f03b";
}
.fa-indent:before {
  content: "\f03c";
}
.fa-video-camera:before {
  content: "\f03d";
}
.fa-photo:before,
.fa-image:before,
.fa-picture-o:before {
  content: "\f03e";
}
.fa-pencil:before {
  content: "\f040";
}
.fa-map-marker:before {
  content: "\f041";
}
.fa-adjust:before {
  content: "\f042";
}
.fa-tint:before {
  content: "\f043";
}
.fa-edit:before,
.fa-pencil-square-o:before {
  content: "\f044";
}
.fa-share-square-o:before {
  content: "\f045";
}
.fa-check-square-o:before {
  content: "\f046";
}
.fa-arrows:before {
  content: "\f047";
}
.fa-step-backward:before {
  content: "\f048";
}
.fa-fast-backward:before {
  content: "\f049";
}
.fa-backward:before {
  content: "\f04a";
}
.fa-play:before {
  content: "\f04b";
}
.fa-pause:before {
  content: "\f04c";
}
.fa-stop:before {
  content: "\f04d";
}
.fa-forward:before {
  content: "\f04e";
}
.fa-fast-forward:before {
  content: "\f050";
}
.fa-step-forward:before {
  content: "\f051";
}
.fa-eject:before {
  content: "\f052";
}
.fa-chevron-left:before {
  content: "\f053";
}
.fa-chevron-right:before {
  content: "\f054";
}
.fa-plus-circle:before {
  content: "\f055";
}
.fa-minus-circle:before {
  content: "\f056";
}
.fa-times-circle:before {
  content: "\f057";
}
.fa-check-circle:before {
  content: "\f058";
}
.fa-question-circle:before {
  content: "\f059";
}
.fa-info-circle:before {
  content: "\f05a";
}
.fa-crosshairs:before {
  content: "\f05b";
}
.fa-times-circle-o:before {
  content: "\f05c";
}
.fa-check-circle-o:before {
  content: "\f05d";
}
.fa-ban:before {
  content: "\f05e";
}
.fa-arrow-left:before {
  content: "\f060";
}
.fa-arrow-right:before {
  content: "\f061";
}
.fa-arrow-up:before {
  content: "\f062";
}
.fa-arrow-down:before {
  content: "\f063";
}
.fa-mail-forward:before,
.fa-share:before {
  content: "\f064";
}
.fa-expand:before {
  content: "\f065";
}
.fa-compress:before {
  content: "\f066";
}
.fa-plus:before {
  content: "\f067";
}
.fa-minus:before {
  content: "\f068";
}
.fa-asterisk:before {
  content: "\f069";
}
.fa-exclamation-circle:before {
  content: "\f06a";
}
.fa-gift:before {
  content: "\f06b";
}
.fa-leaf:before {
  content: "\f06c";
}
.fa-fire:before {
  content: "\f06d";
}
.fa-eye:before {
  content: "\f06e";
}
.fa-eye-slash:before {
  content: "\f070";
}
.fa-warning:before,
.fa-exclamation-triangle:before {
  content: "\f071";
}
.fa-plane:before {
  content: "\f072";
}
.fa-calendar:before {
  content: "\f073";
}
.fa-random:before {
  content: "\f074";
}
.fa-comment:before {
  content: "\f075";
}
.fa-magnet:before {
  content: "\f076";
}
.fa-chevron-up:before {
  content: "\f077";
}
.fa-chevron-down:before {
  content: "\f078";
}
.fa-retweet:before {
  content: "\f079";
}
.fa-shopping-cart:before {
  content: "\f07a";
}
.fa-folder:before {
  content: "\f07b";
}
.fa-folder-open:before {
  content: "\f07c";
}
.fa-arrows-v:before {
  content: "\f07d";
}
.fa-arrows-h:before {
  content: "\f07e";
}
.fa-bar-chart-o:before {
  content: "\f080";
}
.fa-twitter-square:before {
  content: "\f081";
}
.fa-facebook-square:before {
  content: "\f082";
}
.fa-camera-retro:before {
  content: "\f083";
}
.fa-key:before {
  content: "\f084";
}
.fa-gears:before,
.fa-cogs:before {
  content: "\f085";
}
.fa-comments:before {
  content: "\f086";
}
.fa-thumbs-o-up:before {
  content: "\f087";
}
.fa-thumbs-o-down:before {
  content: "\f088";
}
.fa-star-half:before {
  content: "\f089";
}
.fa-heart-o:before {
  content: "\f08a";
}
.fa-sign-out:before {
  content: "\f08b";
}
.fa-linkedin-square:before {
  content: "\f08c";
}
.fa-thumb-tack:before {
  content: "\f08d";
}
.fa-external-link:before {
  content: "\f08e";
}
.fa-sign-in:before {
  content: "\f090";
}
.fa-trophy:before {
  content: "\f091";
}
.fa-github-square:before {
  content: "\f092";
}
.fa-upload:before {
  content: "\f093";
}
.fa-lemon-o:before {
  content: "\f094";
}
.fa-phone:before {
  content: "\f095";
}
.fa-square-o:before {
  content: "\f096";
}
.fa-bookmark-o:before {
  content: "\f097";
}
.fa-phone-square:before {
  content: "\f098";
}
.fa-twitter:before {
  content: "\f099";
}
.fa-facebook:before {
  content: "\f09a";
}
.fa-github:before {
  content: "\f09b";
}
.fa-unlock:before {
  content: "\f09c";
}
.fa-credit-card:before {
  content: "\f09d";
}
.fa-rss:before {
  content: "\f09e";
}
.fa-hdd-o:before {
  content: "\f0a0";
}
.fa-bullhorn:before {
  content: "\f0a1";
}
.fa-bell:before {
  content: "\f0f3";
}
.fa-certificate:before {
  content: "\f0a3";
}
.fa-hand-o-right:before {
  content: "\f0a4";
}
.fa-hand-o-left:before {
  content: "\f0a5";
}
.fa-hand-o-up:before {
  content: "\f0a6";
}
.fa-hand-o-down:before {
  content: "\f0a7";
}
.fa-arrow-circle-left:before {
  content: "\f0a8";
}
.fa-arrow-circle-right:before {
  content: "\f0a9";
}
.fa-arrow-circle-up:before {
  content: "\f0aa";
}
.fa-arrow-circle-down:before {
  content: "\f0ab";
}
.fa-globe:before {
  content: "\f0ac";
}
.fa-wrench:before {
  content: "\f0ad";
}
.fa-tasks:before {
  content: "\f0ae";
}
.fa-filter:before {
  content: "\f0b0";
}
.fa-briefcase:before {
  content: "\f0b1";
}
.fa-arrows-alt:before {
  content: "\f0b2";
}
.fa-group:before,
.fa-users:before {
  content: "\f0c0";
}
.fa-chain:before,
.fa-link:before {
  content: "\f0c1";
}
.fa-cloud:before {
  content: "\f0c2";
}
.fa-flask:before {
  content: "\f0c3";
}
.fa-cut:before,
.fa-scissors:before {
  content: "\f0c4";
}
.fa-copy:before,
.fa-files-o:before {
  content: "\f0c5";
}
.fa-paperclip:before {
  content: "\f0c6";
}
.fa-save:before,
.fa-floppy-o:before {
  content: "\f0c7";
}
.fa-square:before {
  content: "\f0c8";
}
.fa-navicon:before,
.fa-reorder:before,
.fa-bars:before {
  content: "\f0c9";
}
.fa-list-ul:before {
  content: "\f0ca";
}
.fa-list-ol:before {
  content: "\f0cb";
}
.fa-strikethrough:before {
  content: "\f0cc";
}
.fa-underline:before {
  content: "\f0cd";
}
.fa-table:before {
  content: "\f0ce";
}
.fa-magic:before {
  content: "\f0d0";
}
.fa-truck:before {
  content: "\f0d1";
}
.fa-pinterest:before {
  content: "\f0d2";
}
.fa-pinterest-square:before {
  content: "\f0d3";
}
.fa-google-plus-square:before {
  content: "\f0d4";
}
.fa-google-plus:before {
  content: "\f0d5";
}
.fa-money:before {
  content: "\f0d6";
}
.fa-caret-down:before {
  content: "\f0d7";
}
.fa-caret-up:before {
  content: "\f0d8";
}
.fa-caret-left:before {
  content: "\f0d9";
}
.fa-caret-right:before {
  content: "\f0da";
}
.fa-columns:before {
  content: "\f0db";
}
.fa-unsorted:before,
.fa-sort:before {
  content: "\f0dc";
}
.fa-sort-down:before,
.fa-sort-desc:before {
  content: "\f0dd";
}
.fa-sort-up:before,
.fa-sort-asc:before {
  content: "\f0de";
}
.fa-envelope:before {
  content: "\f0e0";
}
.fa-linkedin:before {
  content: "\f0e1";
}
.fa-rotate-left:before,
.fa-undo:before {
  content: "\f0e2";
}
.fa-legal:before,
.fa-gavel:before {
  content: "\f0e3";
}
.fa-dashboard:before,
.fa-tachometer:before {
  content: "\f0e4";
}
.fa-comment-o:before {
  content: "\f0e5";
}
.fa-comments-o:before {
  content: "\f0e6";
}
.fa-flash:before,
.fa-bolt:before {
  content: "\f0e7";
}
.fa-sitemap:before {
  content: "\f0e8";
}
.fa-umbrella:before {
  content: "\f0e9";
}
.fa-paste:before,
.fa-clipboard:before {
  content: "\f0ea";
}
.fa-lightbulb-o:before {
  content: "\f0eb";
}
.fa-exchange:before {
  content: "\f0ec";
}
.fa-cloud-download:before {
  content: "\f0ed";
}
.fa-cloud-upload:before {
  content: "\f0ee";
}
.fa-user-md:before {
  content: "\f0f0";
}
.fa-stethoscope:before {
  content: "\f0f1";
}
.fa-suitcase:before {
  content: "\f0f2";
}
.fa-bell-o:before {
  content: "\f0a2";
}
.fa-coffee:before {
  content: "\f0f4";
}
.fa-cutlery:before {
  content: "\f0f5";
}
.fa-file-text-o:before {
  content: "\f0f6";
}
.fa-building-o:before {
  content: "\f0f7";
}
.fa-hospital-o:before {
  content: "\f0f8";
}
.fa-ambulance:before {
  content: "\f0f9";
}
.fa-medkit:before {
  content: "\f0fa";
}
.fa-fighter-jet:before {
  content: "\f0fb";
}
.fa-beer:before {
  content: "\f0fc";
}
.fa-h-square:before {
  content: "\f0fd";
}
.fa-plus-square:before {
  content: "\f0fe";
}
.fa-angle-double-left:before {
  content: "\f100";
}
.fa-angle-double-right:before {
  content: "\f101";
}
.fa-angle-double-up:before {
  content: "\f102";
}
.fa-angle-double-down:before {
  content: "\f103";
}
.fa-angle-left:before {
  content: "\f104";
}
.fa-angle-right:before {
  content: "\f105";
}
.fa-angle-up:before {
  content: "\f106";
}
.fa-angle-down:before {
  content: "\f107";
}
.fa-desktop:before {
  content: "\f108";
}
.fa-laptop:before {
  content: "\f109";
}
.fa-tablet:before {
  content: "\f10a";
}
.fa-mobile-phone:before,
.fa-mobile:before {
  content: "\f10b";
}
.fa-circle-o:before {
  content: "\f10c";
}
.fa-quote-left:before {
  content: "\f10d";
}
.fa-quote-right:before {
  content: "\f10e";
}
.fa-spinner:before {
  content: "\f110";
}
.fa-circle:before {
  content: "\f111";
}
.fa-mail-reply:before,
.fa-reply:before {
  content: "\f112";
}
.fa-github-alt:before {
  content: "\f113";
}
.fa-folder-o:before {
  content: "\f114";
}
.fa-folder-open-o:before {
  content: "\f115";
}
.fa-smile-o:before {
  content: "\f118";
}
.fa-frown-o:before {
  content: "\f119";
}
.fa-meh-o:before {
  content: "\f11a";
}
.fa-gamepad:before {
  content: "\f11b";
}
.fa-keyboard-o:before {
  content: "\f11c";
}
.fa-flag-o:before {
  content: "\f11d";
}
.fa-flag-checkered:before {
  content: "\f11e";
}
.fa-terminal:before {
  content: "\f120";
}
.fa-code:before {
  content: "\f121";
}
.fa-mail-reply-all:before,
.fa-reply-all:before {
  content: "\f122";
}
.fa-star-half-empty:before,
.fa-star-half-full:before,
.fa-star-half-o:before {
  content: "\f123";
}
.fa-location-arrow:before {
  content: "\f124";
}
.fa-crop:before {
  content: "\f125";
}
.fa-code-fork:before {
  content: "\f126";
}
.fa-unlink:before,
.fa-chain-broken:before {
  content: "\f127";
}
.fa-question:before {
  content: "\f128";
}
.fa-info:before {
  content: "\f129";
}
.fa-exclamation:before {
  content: "\f12a";
}
.fa-superscript:before {
  content: "\f12b";
}
.fa-subscript:before {
  content: "\f12c";
}
.fa-eraser:before {
  content: "\f12d";
}
.fa-puzzle-piece:before {
  content: "\f12e";
}
.fa-microphone:before {
  content: "\f130";
}
.fa-microphone-slash:before {
  content: "\f131";
}
.fa-shield:before {
  content: "\f132";
}
.fa-calendar-o:before {
  content: "\f133";
}
.fa-fire-extinguisher:before {
  content: "\f134";
}
.fa-rocket:before {
  content: "\f135";
}
.fa-maxcdn:before {
  content: "\f136";
}
.fa-chevron-circle-left:before {
  content: "\f137";
}
.fa-chevron-circle-right:before {
  content: "\f138";
}
.fa-chevron-circle-up:before {
  content: "\f139";
}
.fa-chevron-circle-down:before {
  content: "\f13a";
}
.fa-html5:before {
  content: "\f13b";
}
.fa-css3:before {
  content: "\f13c";
}
.fa-anchor:before {
  content: "\f13d";
}
.fa-unlock-alt:before {
  content: "\f13e";
}
.fa-bullseye:before {
  content: "\f140";
}
.fa-ellipsis-h:before {
  content: "\f141";
}
.fa-ellipsis-v:before {
  content: "\f142";
}
.fa-rss-square:before {
  content: "\f143";
}
.fa-play-circle:before {
  content: "\f144";
}
.fa-ticket:before {
  content: "\f145";
}
.fa-minus-square:before {
  content: "\f146";
}
.fa-minus-square-o:before {
  content: "\f147";
}
.fa-level-up:before {
  content: "\f148";
}
.fa-level-down:before {
  content: "\f149";
}
.fa-check-square:before {
  content: "\f14a";
}
.fa-pencil-square:before {
  content: "\f14b";
}
.fa-external-link-square:before {
  content: "\f14c";
}
.fa-share-square:before {
  content: "\f14d";
}
.fa-compass:before {
  content: "\f14e";
}
.fa-toggle-down:before,
.fa-caret-square-o-down:before {
  content: "\f150";
}
.fa-toggle-up:before,
.fa-caret-square-o-up:before {
  content: "\f151";
}
.fa-toggle-right:before,
.fa-caret-square-o-right:before {
  content: "\f152";
}
.fa-euro:before,
.fa-eur:before {
  content: "\f153";
}
.fa-gbp:before {
  content: "\f154";
}
.fa-dollar:before,
.fa-usd:before {
  content: "\f155";
}
.fa-rupee:before,
.fa-inr:before {
  content: "\f156";
}
.fa-cny:before,
.fa-rmb:before,
.fa-yen:before,
.fa-jpy:before {
  content: "\f157";
}
.fa-ruble:before,
.fa-rouble:before,
.fa-rub:before {
  content: "\f158";
}
.fa-won:before,
.fa-krw:before {
  content: "\f159";
}
.fa-bitcoin:before,
.fa-btc:before {
  content: "\f15a";
}
.fa-file:before {
  content: "\f15b";
}
.fa-file-text:before {
  content: "\f15c";
}
.fa-sort-alpha-asc:before {
  content: "\f15d";
}
.fa-sort-alpha-desc:before {
  content: "\f15e";
}
.fa-sort-amount-asc:before {
  content: "\f160";
}
.fa-sort-amount-desc:before {
  content: "\f161";
}
.fa-sort-numeric-asc:before {
  content: "\f162";
}
.fa-sort-numeric-desc:before {
  content: "\f163";
}
.fa-thumbs-up:before {
  content: "\f164";
}
.fa-thumbs-down:before {
  content: "\f165";
}
.fa-youtube-square:before {
  content: "\f166";
}
.fa-youtube:before {
  content: "\f167";
}
.fa-xing:before {
  content: "\f168";
}
.fa-xing-square:before {
  content: "\f169";
}
.fa-youtube-play:before {
  content: "\f16a";
}
.fa-dropbox:before {
  content: "\f16b";
}
.fa-stack-overflow:before {
  content: "\f16c";
}
.fa-instagram:before {
  content: "\f16d";
}
.fa-flickr:before {
  content: "\f16e";
}
.fa-adn:before {
  content: "\f170";
}
.fa-bitbucket:before {
  content: "\f171";
}
.fa-bitbucket-square:before {
  content: "\f172";
}
.fa-tumblr:before {
  content: "\f173";
}
.fa-tumblr-square:before {
  content: "\f174";
}
.fa-long-arrow-down:before {
  content: "\f175";
}
.fa-long-arrow-up:before {
  content: "\f176";
}
.fa-long-arrow-left:before {
  content: "\f177";
}
.fa-long-arrow-right:before {
  content: "\f178";
}
.fa-apple:before {
  content: "\f179";
}
.fa-windows:before {
  content: "\f17a";
}
.fa-android:before {
  content: "\f17b";
}
.fa-linux:before {
  content: "\f17c";
}
.fa-dribbble:before {
  content: "\f17d";
}
.fa-skype:before {
  content: "\f17e";
}
.fa-foursquare:before {
  content: "\f180";
}
.fa-trello:before {
  content: "\f181";
}
.fa-female:before {
  content: "\f182";
}
.fa-male:before {
  content: "\f183";
}
.fa-gittip:before {
  content: "\f184";
}
.fa-sun-o:before {
  content: "\f185";
}
.fa-moon-o:before {
  content: "\f186";
}
.fa-archive:before {
  content: "\f187";
}
.fa-bug:before {
  content: "\f188";
}
.fa-vk:before {
  content: "\f189";
}
.fa-weibo:before {
  content: "\f18a";
}
.fa-renren:before {
  content: "\f18b";
}
.fa-pagelines:before {
  content: "\f18c";
}
.fa-stack-exchange:before {
  content: "\f18d";
}
.fa-arrow-circle-o-right:before {
  content: "\f18e";
}
.fa-arrow-circle-o-left:before {
  content: "\f190";
}
.fa-toggle-left:before,
.fa-caret-square-o-left:before {
  content: "\f191";
}
.fa-dot-circle-o:before {
  content: "\f192";
}
.fa-wheelchair:before {
  content: "\f193";
}
.fa-vimeo-square:before {
  content: "\f194";
}
.fa-turkish-lira:before,
.fa-try:before {
  content: "\f195";
}
.fa-plus-square-o:before {
  content: "\f196";
}
.fa-space-shuttle:before {
  content: "\f197";
}
.fa-slack:before {
  content: "\f198";
}
.fa-envelope-square:before {
  content: "\f199";
}
.fa-wordpress:before {
  content: "\f19a";
}
.fa-openid:before {
  content: "\f19b";
}
.fa-institution:before,
.fa-bank:before,
.fa-university:before {
  content: "\f19c";
}
.fa-mortar-board:before,
.fa-graduation-cap:before {
  content: "\f19d";
}
.fa-yahoo:before {
  content: "\f19e";
}
.fa-google:before {
  content: "\f1a0";
}
.fa-reddit:before {
  content: "\f1a1";
}
.fa-reddit-square:before {
  content: "\f1a2";
}
.fa-stumbleupon-circle:before {
  content: "\f1a3";
}
.fa-stumbleupon:before {
  content: "\f1a4";
}
.fa-delicious:before {
  content: "\f1a5";
}
.fa-digg:before {
  content: "\f1a6";
}
.fa-pied-piper-square:before,
.fa-pied-piper:before {
  content: "\f1a7";
}
.fa-pied-piper-alt:before {
  content: "\f1a8";
}
.fa-drupal:before {
  content: "\f1a9";
}
.fa-joomla:before {
  content: "\f1aa";
}
.fa-language:before {
  content: "\f1ab";
}
.fa-fax:before {
  content: "\f1ac";
}
.fa-building:before {
  content: "\f1ad";
}
.fa-child:before {
  content: "\f1ae";
}
.fa-paw:before {
  content: "\f1b0";
}
.fa-spoon:before {
  content: "\f1b1";
}
.fa-cube:before {
  content: "\f1b2";
}
.fa-cubes:before {
  content: "\f1b3";
}
.fa-behance:before {
  content: "\f1b4";
}
.fa-behance-square:before {
  content: "\f1b5";
}
.fa-steam:before {
  content: "\f1b6";
}
.fa-steam-square:before {
  content: "\f1b7";
}
.fa-recycle:before {
  content: "\f1b8";
}
.fa-automobile:before,
.fa-car:before {
  content: "\f1b9";
}
.fa-cab:before,
.fa-taxi:before {
  content: "\f1ba";
}
.fa-tree:before {
  content: "\f1bb";
}
.fa-spotify:before {
  content: "\f1bc";
}
.fa-deviantart:before {
  content: "\f1bd";
}
.fa-soundcloud:before {
  content: "\f1be";
}
.fa-database:before {
  content: "\f1c0";
}
.fa-file-pdf-o:before {
  content: "\f1c1";
}
.fa-file-word-o:before {
  content: "\f1c2";
}
.fa-file-excel-o:before {
  content: "\f1c3";
}
.fa-file-powerpoint-o:before {
  content: "\f1c4";
}
.fa-file-photo-o:before,
.fa-file-picture-o:before,
.fa-file-image-o:before {
  content: "\f1c5";
}
.fa-file-zip-o:before,
.fa-file-archive-o:before {
  content: "\f1c6";
}
.fa-file-sound-o:before,
.fa-file-audio-o:before {
  content: "\f1c7";
}
.fa-file-movie-o:before,
.fa-file-video-o:before {
  content: "\f1c8";
}
.fa-file-code-o:before {
  content: "\f1c9";
}
.fa-vine:before {
  content: "\f1ca";
}
.fa-codepen:before {
  content: "\f1cb";
}
.fa-jsfiddle:before {
  content: "\f1cc";
}
.fa-life-bouy:before,
.fa-life-saver:before,
.fa-support:before,
.fa-life-ring:before {
  content: "\f1cd";
}
.fa-circle-o-notch:before {
  content: "\f1ce";
}
.fa-ra:before,
.fa-rebel:before {
  content: "\f1d0";
}
.fa-ge:before,
.fa-empire:before {
  content: "\f1d1";
}
.fa-git-square:before {
  content: "\f1d2";
}
.fa-git:before {
  content: "\f1d3";
}
.fa-hacker-news:before {
  content: "\f1d4";
}
.fa-tencent-weibo:before {
  content: "\f1d5";
}
.fa-qq:before {
  content: "\f1d6";
}
.fa-wechat:before,
.fa-weixin:before {
  content: "\f1d7";
}
.fa-send:before,
.fa-paper-plane:before {
  content: "\f1d8";
}
.fa-send-o:before,
.fa-paper-plane-o:before {
  content: "\f1d9";
}
.fa-history:before {
  content: "\f1da";
}
.fa-circle-thin:before {
  content: "\f1db";
}
.fa-header:before {
  content: "\f1dc";
}
.fa-paragraph:before {
  content: "\f1dd";
}
.fa-sliders:before {
  content: "\f1de";
}
.fa-share-alt:before {
  content: "\f1e0";
}
.fa-share-alt-square:before {
  content: "\f1e1";
}
.fa-bomb:before {
  content: "\f1e2";
}
:host {
  display: inline-block;
  box-sizing: border-box;
  font-size: 1.5rem;
  perspective: 1000;
  position: relative;
}
:host .flipper {
  width: 1.75em;
  height: 1.75em;
  line-height: 1.75em;
  display: flex;
  align-items: center;
  transition: 0.2s ease;
  -webkit-transition: 0.2s ease;
  transform-style: preserve-3d;
  cursor: default;
}
:host .flipper.active {
  transform: rotateY(180deg);
  -webkit-transform: rotateY(180deg);
}
:host .flipper.active.pressed {
  transform: rotateY(180deg) scale(0.95, 0.95);
  -webkit-transform: rotateY(180deg) scale(0.95, 0.95);
}
:host .flipper.pressed {
  transform: scale(0.95, 0.95);
  -webkit-transform: scale(0.95, 0.95);
}
:host .flipper.enabled {
  cursor: pointer;
}
:host .selector {
  transition: 0.2s ease;
  -webkit-transition: 0.2s ease;
  transform: rotateY(90deg);
  -webkit-transform: rotateY(90deg);
  background-color: rgba(255, 255, 255, 0.85);
  position: absolute;
  left: 0;
  width: 100%;
  height: .1em;
}
:host .selector.selected {
  transform: rotateY(0deg);
  -webkit-transform: rotateY(0deg);
}
:host .toolicon {
  box-sizing: border-box;
  min-width: 100%;
  min-height: 100%;
  width: 100%;
  backface-visibility: hidden;
  -webkit-backface-visibility: hidden;
}
:host .back {
  color: rgba(255, 255, 255, 0.61);
}
:host .front {
  color: rgba(255, 255, 255, 0.33);
  z-index: 2;
  transform: rotateY(180deg);
  -webkit-transform: rotateY(180deg);
}
:host .front.enabled {
  color: #ffffff;
}
</style>
  <section id="button" on-click="{{click}}">
    <span id="selector" class="selector"></span>
    <span id="tool" class="flipper {{ {active: active, enabled: enabled} | tokenList }}">
      <i class="toolicon front fa {{ icon }} fa-stack-1x {{ {enabled: enabled} | tokenList }}"></i>
      <i class="toolicon back fa {{ icon }} fa-stack-1x"></i>
    </span>
  </section>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-toolbar/src/ui-toolbar-button.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        Polymer("ui-toolbar-button", {
            selectedChanged: function() {
                if (this.selected) {
                    return this.$.selector.classList.add("selected");
                } else {
                    return this.$.selector.classList.remove("selected");
                }
            },
            pointerdown: function() {
                if (this.enabled) {
                    return this.$.tool.classList.add("pressed");
                }
            },
            pointerup: function() {
                return this.$.tool.classList.remove("pressed");
            },
            click: function(evt) {
                if (!this.enabled) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    return false;
                }
            },
            pointerenter: function() {},
            pointerleave: function() {},
            pointerclick: function(evt) {
                if (this.toggle) {
                    return this.active = !this.active;
                }
            },
            created: function() {
                this.toggle = false;
                this.active = true;
                return this.enabled = true;
            },
            ready: function() {},
            attached: function() {},
            domReady: function() {},
            detached: function() {}
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>


<polymer-element name="ui-toolbar" attributes="">
<template>
  <style>.hide {
  display: none !important;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(0, 0, 0, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease;
  -webkit-transition: opacity 0.2s ease;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease, opacity 0.2s ease;
  -webkit-transition: height 0.2s ease, opacity 0.2s ease;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
.sheen {
  background-image: linear-gradient(rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.1));
}
:host {
  background-color: #333333;
  background-image: linear-gradient(rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.1));
  display: flex;
  box-sizing: border-box;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
}
</style>
  <content></content>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-toolbar/src/ui-toolbar.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        Polymer("ui-toolbar", {
            created: function() {},
            ready: function() {},
            attached: function() {},
            domReady: function() {},
            detached: function() {}
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>

<polymer-element name="ui-resizebox" attributes="left right">
<template>
  <style>:host {
  display: inline-block;
  box-sizing: border-box;
  position: relative;
  overflow-y: auto;
  overflow-x: hidden;
}
:host #splitter {
  box-sizing: border-box;
  cursor: col-resize;
  position: absolute;
  top: 0;
  bottom: 0;
  width: 0.5em;
  background-color: transparent;
  z-index: 1;
}
:host #display {
  box-sizing: border-box;
  position: relative;
  width: 100%;
  height: 100%;
}
::content > * {
  box-sizing: border-box;
}
:host([right]) {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
}
:host([right]) #splitter {
  left: 0;
}
:host([left]) {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
}
:host([left]) #splitter {
  right: 0;
}
</style>
  <section id="splitter" on-trackstart="{{trackStart}}" on-track="{{track}}"></section>
  <section id="display">
    <content></content>
  </section>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-resizebox/src/ui-resizebox.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        Polymer("ui-resizebox", {
            trackStart: function() {
                return this.size = parseInt(getComputedStyle(this)["width"]);
            },
            track: function(evt) {
                var delta;
                delta = evt["dx"];
                if (this.left != null) {
                    delta *= -1;
                }
                return this.style["width"] = "" + (this.size - delta) + "px";
            },
            created: function() {},
            ready: function() {},
            attached: function() {},
            domReady: function() {},
            detached: function() {}
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>

<style>body /deep/ .tile-1 {
  flex: 0 0 90%;
  max-height: 90%;
}
body /deep/ .tile-2 {
  flex: 0 0 50%;
  max-height: 50%;
}
body /deep/ .tile-3 {
  flex: 0 0 50%;
  max-height: 50%;
}
body /deep/ .tile-4 {
  flex: 0 0 50%;
  max-height: 50%;
}
body /deep/ .tile-5 {
  flex: 0 0 33%;
  max-height: 33%;
}
body /deep/ .tile-6 {
  flex: 0 0 33%;
  max-height: 33%;
}
body /deep/ .tile-7 {
  flex: 0 0 33%;
  max-height: 33%;
}
body /deep/ .tile-8 {
  flex: 0 0 33%;
  max-height: 33%;
}
body /deep/ .tile-9 {
  flex: 0 0 33%;
  max-height: 33%;
}
body /deep/ .tile-10 {
  flex: 0 0 25%;
  max-height: 25%;
}
body /deep/ .tile-11 {
  flex: 0 0 25%;
  max-height: 25%;
}
body /deep/ .tile-12 {
  flex: 0 0 25%;
  max-height: 25%;
}
body /deep/ .tile-13 {
  flex: 0 0 25%;
  max-height: 25%;
}
body /deep/ .tile-14 {
  flex: 0 0 25%;
  max-height: 25%;
}
body /deep/ .tile-15 {
  flex: 0 0 25%;
  max-height: 25%;
}
body /deep/ .tile-16 {
  flex: 0 0 25%;
  max-height: 25%;
}
body /deep/ .tile-17 {
  flex: 0 0 20%;
  max-height: 20%;
}
body /deep/ .tile-18 {
  flex: 0 0 20%;
  max-height: 20%;
}
body /deep/ .tile-19 {
  flex: 0 0 20%;
  max-height: 20%;
}
body /deep/ .tile-20 {
  flex: 0 0 20%;
  max-height: 20%;
}
body /deep/ .tile-21 {
  flex: 0 0 20%;
  max-height: 20%;
}
body /deep/ .tile-22 {
  flex: 0 0 20%;
  max-height: 20%;
}
body /deep/ .tile-23 {
  flex: 0 0 20%;
  max-height: 20%;
}
body /deep/ .tile-24 {
  flex: 0 0 20%;
  max-height: 20%;
}
body /deep/ .tile-25 {
  flex: 0 0 20%;
  max-height: 20%;
}
</style>
<polymer-element name="ui-grid-tiler" attributes="selector">
<template>
  <style>:host {
  display: flex;
  text-align: center;
  overflow: hidden;
  width: 100%;
  height: 100%;
  flex-wrap: wrap;
  align-items: center;
  align-content: center;
  justify-content: center;
}
</style>
  <content></content>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-grid-tiler/src/ui-grid-tiler.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        (function(global) {
            (function() {
                var undefined;
                var arrayPool = [], objectPool = [];
                var idCounter = 0;
                var keyPrefix = +new Date() + "";
                var largeArraySize = 75;
                var maxPoolSize = 40;
                var whitespace = " 	\f ﻿" + "\n\r\u2028\u2029" + " ᠎             　";
                var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
                var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
                var reFlags = /\w*$/;
                var reFuncName = /^\s*function[ \n\r\t]+\w/;
                var reInterpolate = /<%=([\s\S]+?)%>/g;
                var reLeadingSpacesAndZeros = RegExp("^[" + whitespace + "]*0+(?=.$)");
                var reNoMatch = /($^)/;
                var reThis = /\bthis\b/;
                var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
                var contextProps = [ "Array", "Boolean", "Date", "Function", "Math", "Number", "Object", "RegExp", "String", "_", "attachEvent", "clearTimeout", "isFinite", "isNaN", "parseInt", "setTimeout" ];
                var templateCounter = 0;
                var argsClass = "[object Arguments]", arrayClass = "[object Array]", boolClass = "[object Boolean]", dateClass = "[object Date]", funcClass = "[object Function]", numberClass = "[object Number]", objectClass = "[object Object]", regexpClass = "[object RegExp]", stringClass = "[object String]";
                var cloneableClasses = {};
                cloneableClasses[funcClass] = false;
                cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
                var debounceOptions = {
                    leading: false,
                    maxWait: 0,
                    trailing: false
                };
                var descriptor = {
                    configurable: false,
                    enumerable: false,
                    value: null,
                    writable: false
                };
                var objectTypes = {
                    "boolean": false,
                    "function": true,
                    object: true,
                    number: false,
                    string: false,
                    undefined: false
                };
                var stringEscapes = {
                    "\\": "\\",
                    "'": "'",
                    "\n": "n",
                    "\r": "r",
                    "	": "t",
                    "\u2028": "u2028",
                    "\u2029": "u2029"
                };
                var root = objectTypes[typeof window] && window || this;
                var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
                var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
                var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
                var freeGlobal = objectTypes[typeof global] && global;
                if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
                    root = freeGlobal;
                }
                function baseIndexOf(array, value, fromIndex) {
                    var index = (fromIndex || 0) - 1, length = array ? array.length : 0;
                    while (++index < length) {
                        if (array[index] === value) {
                            return index;
                        }
                    }
                    return -1;
                }
                function cacheIndexOf(cache, value) {
                    var type = typeof value;
                    cache = cache.cache;
                    if (type == "boolean" || value == null) {
                        return cache[value] ? 0 : -1;
                    }
                    if (type != "number" && type != "string") {
                        type = "object";
                    }
                    var key = type == "number" ? value : keyPrefix + value;
                    cache = (cache = cache[type]) && cache[key];
                    return type == "object" ? cache && baseIndexOf(cache, value) > -1 ? 0 : -1 : cache ? 0 : -1;
                }
                function cachePush(value) {
                    var cache = this.cache, type = typeof value;
                    if (type == "boolean" || value == null) {
                        cache[value] = true;
                    } else {
                        if (type != "number" && type != "string") {
                            type = "object";
                        }
                        var key = type == "number" ? value : keyPrefix + value, typeCache = cache[type] || (cache[type] = {});
                        if (type == "object") {
                            (typeCache[key] || (typeCache[key] = [])).push(value);
                        } else {
                            typeCache[key] = true;
                        }
                    }
                }
                function charAtCallback(value) {
                    return value.charCodeAt(0);
                }
                function compareAscending(a, b) {
                    var ac = a.criteria, bc = b.criteria, index = -1, length = ac.length;
                    while (++index < length) {
                        var value = ac[index], other = bc[index];
                        if (value !== other) {
                            if (value > other || typeof value == "undefined") {
                                return 1;
                            }
                            if (value < other || typeof other == "undefined") {
                                return -1;
                            }
                        }
                    }
                    return a.index - b.index;
                }
                function createCache(array) {
                    var index = -1, length = array.length, first = array[0], mid = array[length / 2 | 0], last = array[length - 1];
                    if (first && typeof first == "object" && mid && typeof mid == "object" && last && typeof last == "object") {
                        return false;
                    }
                    var cache = getObject();
                    cache["false"] = cache["null"] = cache["true"] = cache["undefined"] = false;
                    var result = getObject();
                    result.array = array;
                    result.cache = cache;
                    result.push = cachePush;
                    while (++index < length) {
                        result.push(array[index]);
                    }
                    return result;
                }
                function escapeStringChar(match) {
                    return "\\" + stringEscapes[match];
                }
                function getArray() {
                    return arrayPool.pop() || [];
                }
                function getObject() {
                    return objectPool.pop() || {
                        array: null,
                        cache: null,
                        criteria: null,
                        "false": false,
                        index: 0,
                        "null": false,
                        number: null,
                        object: null,
                        push: null,
                        string: null,
                        "true": false,
                        undefined: false,
                        value: null
                    };
                }
                function releaseArray(array) {
                    array.length = 0;
                    if (arrayPool.length < maxPoolSize) {
                        arrayPool.push(array);
                    }
                }
                function releaseObject(object) {
                    var cache = object.cache;
                    if (cache) {
                        releaseObject(cache);
                    }
                    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
                    if (objectPool.length < maxPoolSize) {
                        objectPool.push(object);
                    }
                }
                function slice(array, start, end) {
                    start || (start = 0);
                    if (typeof end == "undefined") {
                        end = array ? array.length : 0;
                    }
                    var index = -1, length = end - start || 0, result = Array(length < 0 ? 0 : length);
                    while (++index < length) {
                        result[index] = array[start + index];
                    }
                    return result;
                }
                function runInContext(context) {
                    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
                    var Array = context.Array, Boolean = context.Boolean, Date = context.Date, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
                    var arrayRef = [];
                    var objectProto = Object.prototype;
                    var oldDash = context._;
                    var toString = objectProto.toString;
                    var reNative = RegExp("^" + String(toString).replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/toString| for [^\]]+/g, ".*?") + "$");
                    var ceil = Math.ceil, clearTimeout = context.clearTimeout, floor = Math.floor, fnToString = Function.prototype.toString, getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, hasOwnProperty = objectProto.hasOwnProperty, push = arrayRef.push, setTimeout = context.setTimeout, splice = arrayRef.splice, unshift = arrayRef.unshift;
                    var defineProperty = function() {
                        try {
                            var o = {}, func = isNative(func = Object.defineProperty) && func, result = func(o, o, o) && func;
                        } catch (e) {}
                        return result;
                    }();
                    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate, nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray, nativeIsFinite = context.isFinite, nativeIsNaN = context.isNaN, nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeParseInt = context.parseInt, nativeRandom = Math.random;
                    var ctorByClass = {};
                    ctorByClass[arrayClass] = Array;
                    ctorByClass[boolClass] = Boolean;
                    ctorByClass[dateClass] = Date;
                    ctorByClass[funcClass] = Function;
                    ctorByClass[objectClass] = Object;
                    ctorByClass[numberClass] = Number;
                    ctorByClass[regexpClass] = RegExp;
                    ctorByClass[stringClass] = String;
                    function lodash(value) {
                        return value && typeof value == "object" && !isArray(value) && hasOwnProperty.call(value, "__wrapped__") ? value : new lodashWrapper(value);
                    }
                    function lodashWrapper(value, chainAll) {
                        this.__chain__ = !!chainAll;
                        this.__wrapped__ = value;
                    }
                    lodashWrapper.prototype = lodash.prototype;
                    var support = lodash.support = {};
                    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
                    support.funcNames = typeof Function.name == "string";
                    lodash.templateSettings = {
                        escape: /<%-([\s\S]+?)%>/g,
                        evaluate: /<%([\s\S]+?)%>/g,
                        interpolate: reInterpolate,
                        variable: "",
                        imports: {
                            _: lodash
                        }
                    };
                    function baseBind(bindData) {
                        var func = bindData[0], partialArgs = bindData[2], thisArg = bindData[4];
                        function bound() {
                            if (partialArgs) {
                                var args = slice(partialArgs);
                                push.apply(args, arguments);
                            }
                            if (this instanceof bound) {
                                var thisBinding = baseCreate(func.prototype), result = func.apply(thisBinding, args || arguments);
                                return isObject(result) ? result : thisBinding;
                            }
                            return func.apply(thisArg, args || arguments);
                        }
                        setBindData(bound, bindData);
                        return bound;
                    }
                    function baseClone(value, isDeep, callback, stackA, stackB) {
                        if (callback) {
                            var result = callback(value);
                            if (typeof result != "undefined") {
                                return result;
                            }
                        }
                        var isObj = isObject(value);
                        if (isObj) {
                            var className = toString.call(value);
                            if (!cloneableClasses[className]) {
                                return value;
                            }
                            var ctor = ctorByClass[className];
                            switch (className) {
                              case boolClass:
                              case dateClass:
                                return new ctor(+value);

                              case numberClass:
                              case stringClass:
                                return new ctor(value);

                              case regexpClass:
                                result = ctor(value.source, reFlags.exec(value));
                                result.lastIndex = value.lastIndex;
                                return result;
                            }
                        } else {
                            return value;
                        }
                        var isArr = isArray(value);
                        if (isDeep) {
                            var initedStack = !stackA;
                            stackA || (stackA = getArray());
                            stackB || (stackB = getArray());
                            var length = stackA.length;
                            while (length--) {
                                if (stackA[length] == value) {
                                    return stackB[length];
                                }
                            }
                            result = isArr ? ctor(value.length) : {};
                        } else {
                            result = isArr ? slice(value) : assign({}, value);
                        }
                        if (isArr) {
                            if (hasOwnProperty.call(value, "index")) {
                                result.index = value.index;
                            }
                            if (hasOwnProperty.call(value, "input")) {
                                result.input = value.input;
                            }
                        }
                        if (!isDeep) {
                            return result;
                        }
                        stackA.push(value);
                        stackB.push(result);
                        (isArr ? forEach : forOwn)(value, function(objValue, key) {
                            result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
                        });
                        if (initedStack) {
                            releaseArray(stackA);
                            releaseArray(stackB);
                        }
                        return result;
                    }
                    function baseCreate(prototype, properties) {
                        return isObject(prototype) ? nativeCreate(prototype) : {};
                    }
                    if (!nativeCreate) {
                        baseCreate = function() {
                            function Object() {}
                            return function(prototype) {
                                if (isObject(prototype)) {
                                    Object.prototype = prototype;
                                    var result = new Object();
                                    Object.prototype = null;
                                }
                                return result || context.Object();
                            };
                        }();
                    }
                    function baseCreateCallback(func, thisArg, argCount) {
                        if (typeof func != "function") {
                            return identity;
                        }
                        if (typeof thisArg == "undefined" || !("prototype" in func)) {
                            return func;
                        }
                        var bindData = func.__bindData__;
                        if (typeof bindData == "undefined") {
                            if (support.funcNames) {
                                bindData = !func.name;
                            }
                            bindData = bindData || !support.funcDecomp;
                            if (!bindData) {
                                var source = fnToString.call(func);
                                if (!support.funcNames) {
                                    bindData = !reFuncName.test(source);
                                }
                                if (!bindData) {
                                    bindData = reThis.test(source);
                                    setBindData(func, bindData);
                                }
                            }
                        }
                        if (bindData === false || bindData !== true && bindData[1] & 1) {
                            return func;
                        }
                        switch (argCount) {
                          case 1:
                            return function(value) {
                                return func.call(thisArg, value);
                            };

                          case 2:
                            return function(a, b) {
                                return func.call(thisArg, a, b);
                            };

                          case 3:
                            return function(value, index, collection) {
                                return func.call(thisArg, value, index, collection);
                            };

                          case 4:
                            return function(accumulator, value, index, collection) {
                                return func.call(thisArg, accumulator, value, index, collection);
                            };
                        }
                        return bind(func, thisArg);
                    }
                    function baseCreateWrapper(bindData) {
                        var func = bindData[0], bitmask = bindData[1], partialArgs = bindData[2], partialRightArgs = bindData[3], thisArg = bindData[4], arity = bindData[5];
                        var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, key = func;
                        function bound() {
                            var thisBinding = isBind ? thisArg : this;
                            if (partialArgs) {
                                var args = slice(partialArgs);
                                push.apply(args, arguments);
                            }
                            if (partialRightArgs || isCurry) {
                                args || (args = slice(arguments));
                                if (partialRightArgs) {
                                    push.apply(args, partialRightArgs);
                                }
                                if (isCurry && args.length < arity) {
                                    bitmask |= 16 & ~32;
                                    return baseCreateWrapper([ func, isCurryBound ? bitmask : bitmask & ~3, args, null, thisArg, arity ]);
                                }
                            }
                            args || (args = arguments);
                            if (isBindKey) {
                                func = thisBinding[key];
                            }
                            if (this instanceof bound) {
                                thisBinding = baseCreate(func.prototype);
                                var result = func.apply(thisBinding, args);
                                return isObject(result) ? result : thisBinding;
                            }
                            return func.apply(thisBinding, args);
                        }
                        setBindData(bound, bindData);
                        return bound;
                    }
                    function baseDifference(array, values) {
                        var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, isLarge = length >= largeArraySize && indexOf === baseIndexOf, result = [];
                        if (isLarge) {
                            var cache = createCache(values);
                            if (cache) {
                                indexOf = cacheIndexOf;
                                values = cache;
                            } else {
                                isLarge = false;
                            }
                        }
                        while (++index < length) {
                            var value = array[index];
                            if (indexOf(values, value) < 0) {
                                result.push(value);
                            }
                        }
                        if (isLarge) {
                            releaseObject(values);
                        }
                        return result;
                    }
                    function baseFlatten(array, isShallow, isStrict, fromIndex) {
                        var index = (fromIndex || 0) - 1, length = array ? array.length : 0, result = [];
                        while (++index < length) {
                            var value = array[index];
                            if (value && typeof value == "object" && typeof value.length == "number" && (isArray(value) || isArguments(value))) {
                                if (!isShallow) {
                                    value = baseFlatten(value, isShallow, isStrict);
                                }
                                var valIndex = -1, valLength = value.length, resIndex = result.length;
                                result.length += valLength;
                                while (++valIndex < valLength) {
                                    result[resIndex++] = value[valIndex];
                                }
                            } else if (!isStrict) {
                                result.push(value);
                            }
                        }
                        return result;
                    }
                    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
                        if (callback) {
                            var result = callback(a, b);
                            if (typeof result != "undefined") {
                                return !!result;
                            }
                        }
                        if (a === b) {
                            return a !== 0 || 1 / a == 1 / b;
                        }
                        var type = typeof a, otherType = typeof b;
                        if (a === a && !(a && objectTypes[type]) && !(b && objectTypes[otherType])) {
                            return false;
                        }
                        if (a == null || b == null) {
                            return a === b;
                        }
                        var className = toString.call(a), otherClass = toString.call(b);
                        if (className == argsClass) {
                            className = objectClass;
                        }
                        if (otherClass == argsClass) {
                            otherClass = objectClass;
                        }
                        if (className != otherClass) {
                            return false;
                        }
                        switch (className) {
                          case boolClass:
                          case dateClass:
                            return +a == +b;

                          case numberClass:
                            return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;

                          case regexpClass:
                          case stringClass:
                            return a == String(b);
                        }
                        var isArr = className == arrayClass;
                        if (!isArr) {
                            var aWrapped = hasOwnProperty.call(a, "__wrapped__"), bWrapped = hasOwnProperty.call(b, "__wrapped__");
                            if (aWrapped || bWrapped) {
                                return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
                            }
                            if (className != objectClass) {
                                return false;
                            }
                            var ctorA = a.constructor, ctorB = b.constructor;
                            if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ("constructor" in a && "constructor" in b)) {
                                return false;
                            }
                        }
                        var initedStack = !stackA;
                        stackA || (stackA = getArray());
                        stackB || (stackB = getArray());
                        var length = stackA.length;
                        while (length--) {
                            if (stackA[length] == a) {
                                return stackB[length] == b;
                            }
                        }
                        var size = 0;
                        result = true;
                        stackA.push(a);
                        stackB.push(b);
                        if (isArr) {
                            length = a.length;
                            size = b.length;
                            result = size == length;
                            if (result || isWhere) {
                                while (size--) {
                                    var index = length, value = b[size];
                                    if (isWhere) {
                                        while (index--) {
                                            if (result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB)) {
                                                break;
                                            }
                                        }
                                    } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
                                        break;
                                    }
                                }
                            }
                        } else {
                            forIn(b, function(value, key, b) {
                                if (hasOwnProperty.call(b, key)) {
                                    size++;
                                    return result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB);
                                }
                            });
                            if (result && !isWhere) {
                                forIn(a, function(value, key, a) {
                                    if (hasOwnProperty.call(a, key)) {
                                        return result = --size > -1;
                                    }
                                });
                            }
                        }
                        stackA.pop();
                        stackB.pop();
                        if (initedStack) {
                            releaseArray(stackA);
                            releaseArray(stackB);
                        }
                        return result;
                    }
                    function baseMerge(object, source, callback, stackA, stackB) {
                        (isArray(source) ? forEach : forOwn)(source, function(source, key) {
                            var found, isArr, result = source, value = object[key];
                            if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                                var stackLength = stackA.length;
                                while (stackLength--) {
                                    if (found = stackA[stackLength] == source) {
                                        value = stackB[stackLength];
                                        break;
                                    }
                                }
                                if (!found) {
                                    var isShallow;
                                    if (callback) {
                                        result = callback(value, source);
                                        if (isShallow = typeof result != "undefined") {
                                            value = result;
                                        }
                                    }
                                    if (!isShallow) {
                                        value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {};
                                    }
                                    stackA.push(source);
                                    stackB.push(value);
                                    if (!isShallow) {
                                        baseMerge(value, source, callback, stackA, stackB);
                                    }
                                }
                            } else {
                                if (callback) {
                                    result = callback(value, source);
                                    if (typeof result == "undefined") {
                                        result = source;
                                    }
                                }
                                if (typeof result != "undefined") {
                                    value = result;
                                }
                            }
                            object[key] = value;
                        });
                    }
                    function baseRandom(min, max) {
                        return min + floor(nativeRandom() * (max - min + 1));
                    }
                    function baseUniq(array, isSorted, callback) {
                        var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [];
                        var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf, seen = callback || isLarge ? getArray() : result;
                        if (isLarge) {
                            var cache = createCache(seen);
                            indexOf = cacheIndexOf;
                            seen = cache;
                        }
                        while (++index < length) {
                            var value = array[index], computed = callback ? callback(value, index, array) : value;
                            if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) {
                                if (callback || isLarge) {
                                    seen.push(computed);
                                }
                                result.push(value);
                            }
                        }
                        if (isLarge) {
                            releaseArray(seen.array);
                            releaseObject(seen);
                        } else if (callback) {
                            releaseArray(seen);
                        }
                        return result;
                    }
                    function createAggregator(setter) {
                        return function(collection, callback, thisArg) {
                            var result = {};
                            callback = lodash.createCallback(callback, thisArg, 3);
                            var index = -1, length = collection ? collection.length : 0;
                            if (typeof length == "number") {
                                while (++index < length) {
                                    var value = collection[index];
                                    setter(result, value, callback(value, index, collection), collection);
                                }
                            } else {
                                forOwn(collection, function(value, key, collection) {
                                    setter(result, value, callback(value, key, collection), collection);
                                });
                            }
                            return result;
                        };
                    }
                    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
                        var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, isPartial = bitmask & 16, isPartialRight = bitmask & 32;
                        if (!isBindKey && !isFunction(func)) {
                            throw new TypeError();
                        }
                        if (isPartial && !partialArgs.length) {
                            bitmask &= ~16;
                            isPartial = partialArgs = false;
                        }
                        if (isPartialRight && !partialRightArgs.length) {
                            bitmask &= ~32;
                            isPartialRight = partialRightArgs = false;
                        }
                        var bindData = func && func.__bindData__;
                        if (bindData && bindData !== true) {
                            bindData = slice(bindData);
                            if (bindData[2]) {
                                bindData[2] = slice(bindData[2]);
                            }
                            if (bindData[3]) {
                                bindData[3] = slice(bindData[3]);
                            }
                            if (isBind && !(bindData[1] & 1)) {
                                bindData[4] = thisArg;
                            }
                            if (!isBind && bindData[1] & 1) {
                                bitmask |= 8;
                            }
                            if (isCurry && !(bindData[1] & 4)) {
                                bindData[5] = arity;
                            }
                            if (isPartial) {
                                push.apply(bindData[2] || (bindData[2] = []), partialArgs);
                            }
                            if (isPartialRight) {
                                unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
                            }
                            bindData[1] |= bitmask;
                            return createWrapper.apply(null, bindData);
                        }
                        var creater = bitmask == 1 || bitmask === 17 ? baseBind : baseCreateWrapper;
                        return creater([ func, bitmask, partialArgs, partialRightArgs, thisArg, arity ]);
                    }
                    function escapeHtmlChar(match) {
                        return htmlEscapes[match];
                    }
                    function getIndexOf() {
                        var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
                        return result;
                    }
                    function isNative(value) {
                        return typeof value == "function" && reNative.test(value);
                    }
                    var setBindData = !defineProperty ? noop : function(func, value) {
                        descriptor.value = value;
                        defineProperty(func, "__bindData__", descriptor);
                    };
                    function shimIsPlainObject(value) {
                        var ctor, result;
                        if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, 
                        isFunction(ctor) && !(ctor instanceof ctor))) {
                            return false;
                        }
                        forIn(value, function(value, key) {
                            result = key;
                        });
                        return typeof result == "undefined" || hasOwnProperty.call(value, result);
                    }
                    function unescapeHtmlChar(match) {
                        return htmlUnescapes[match];
                    }
                    function isArguments(value) {
                        return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == argsClass || false;
                    }
                    var isArray = nativeIsArray || function(value) {
                        return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == arrayClass || false;
                    };
                    var shimKeys = function(object) {
                        var index, iterable = object, result = [];
                        if (!iterable) return result;
                        if (!objectTypes[typeof object]) return result;
                        for (index in iterable) {
                            if (hasOwnProperty.call(iterable, index)) {
                                result.push(index);
                            }
                        }
                        return result;
                    };
                    var keys = !nativeKeys ? shimKeys : function(object) {
                        if (!isObject(object)) {
                            return [];
                        }
                        return nativeKeys(object);
                    };
                    var htmlEscapes = {
                        "&": "&amp;",
                        "<": "&lt;",
                        ">": "&gt;",
                        '"': "&quot;",
                        "'": "&#39;"
                    };
                    var htmlUnescapes = invert(htmlEscapes);
                    var reEscapedHtml = RegExp("(" + keys(htmlUnescapes).join("|") + ")", "g"), reUnescapedHtml = RegExp("[" + keys(htmlEscapes).join("") + "]", "g");
                    var assign = function(object, source, guard) {
                        var index, iterable = object, result = iterable;
                        if (!iterable) return result;
                        var args = arguments, argsIndex = 0, argsLength = typeof guard == "number" ? 2 : args.length;
                        if (argsLength > 3 && typeof args[argsLength - 2] == "function") {
                            var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
                        } else if (argsLength > 2 && typeof args[argsLength - 1] == "function") {
                            callback = args[--argsLength];
                        }
                        while (++argsIndex < argsLength) {
                            iterable = args[argsIndex];
                            if (iterable && objectTypes[typeof iterable]) {
                                var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                                while (++ownIndex < length) {
                                    index = ownProps[ownIndex];
                                    result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
                                }
                            }
                        }
                        return result;
                    };
                    function clone(value, isDeep, callback, thisArg) {
                        if (typeof isDeep != "boolean" && isDeep != null) {
                            thisArg = callback;
                            callback = isDeep;
                            isDeep = false;
                        }
                        return baseClone(value, isDeep, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
                    }
                    function cloneDeep(value, callback, thisArg) {
                        return baseClone(value, true, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
                    }
                    function create(prototype, properties) {
                        var result = baseCreate(prototype);
                        return properties ? assign(result, properties) : result;
                    }
                    var defaults = function(object, source, guard) {
                        var index, iterable = object, result = iterable;
                        if (!iterable) return result;
                        var args = arguments, argsIndex = 0, argsLength = typeof guard == "number" ? 2 : args.length;
                        while (++argsIndex < argsLength) {
                            iterable = args[argsIndex];
                            if (iterable && objectTypes[typeof iterable]) {
                                var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                                while (++ownIndex < length) {
                                    index = ownProps[ownIndex];
                                    if (typeof result[index] == "undefined") result[index] = iterable[index];
                                }
                            }
                        }
                        return result;
                    };
                    function findKey(object, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwn(object, function(value, key, object) {
                            if (callback(value, key, object)) {
                                result = key;
                                return false;
                            }
                        });
                        return result;
                    }
                    function findLastKey(object, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwnRight(object, function(value, key, object) {
                            if (callback(value, key, object)) {
                                result = key;
                                return false;
                            }
                        });
                        return result;
                    }
                    var forIn = function(collection, callback, thisArg) {
                        var index, iterable = collection, result = iterable;
                        if (!iterable) return result;
                        if (!objectTypes[typeof iterable]) return result;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        for (index in iterable) {
                            if (callback(iterable[index], index, collection) === false) return result;
                        }
                        return result;
                    };
                    function forInRight(object, callback, thisArg) {
                        var pairs = [];
                        forIn(object, function(value, key) {
                            pairs.push(key, value);
                        });
                        var length = pairs.length;
                        callback = baseCreateCallback(callback, thisArg, 3);
                        while (length--) {
                            if (callback(pairs[length--], pairs[length], object) === false) {
                                break;
                            }
                        }
                        return object;
                    }
                    var forOwn = function(collection, callback, thisArg) {
                        var index, iterable = collection, result = iterable;
                        if (!iterable) return result;
                        if (!objectTypes[typeof iterable]) return result;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                        while (++ownIndex < length) {
                            index = ownProps[ownIndex];
                            if (callback(iterable[index], index, collection) === false) return result;
                        }
                        return result;
                    };
                    function forOwnRight(object, callback, thisArg) {
                        var props = keys(object), length = props.length;
                        callback = baseCreateCallback(callback, thisArg, 3);
                        while (length--) {
                            var key = props[length];
                            if (callback(object[key], key, object) === false) {
                                break;
                            }
                        }
                        return object;
                    }
                    function functions(object) {
                        var result = [];
                        forIn(object, function(value, key) {
                            if (isFunction(value)) {
                                result.push(key);
                            }
                        });
                        return result.sort();
                    }
                    function has(object, key) {
                        return object ? hasOwnProperty.call(object, key) : false;
                    }
                    function invert(object) {
                        var index = -1, props = keys(object), length = props.length, result = {};
                        while (++index < length) {
                            var key = props[index];
                            result[object[key]] = key;
                        }
                        return result;
                    }
                    function isBoolean(value) {
                        return value === true || value === false || value && typeof value == "object" && toString.call(value) == boolClass || false;
                    }
                    function isDate(value) {
                        return value && typeof value == "object" && toString.call(value) == dateClass || false;
                    }
                    function isElement(value) {
                        return value && value.nodeType === 1 || false;
                    }
                    function isEmpty(value) {
                        var result = true;
                        if (!value) {
                            return result;
                        }
                        var className = toString.call(value), length = value.length;
                        if (className == arrayClass || className == stringClass || className == argsClass || className == objectClass && typeof length == "number" && isFunction(value.splice)) {
                            return !length;
                        }
                        forOwn(value, function() {
                            return result = false;
                        });
                        return result;
                    }
                    function isEqual(a, b, callback, thisArg) {
                        return baseIsEqual(a, b, typeof callback == "function" && baseCreateCallback(callback, thisArg, 2));
                    }
                    function isFinite(value) {
                        return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
                    }
                    function isFunction(value) {
                        return typeof value == "function";
                    }
                    function isObject(value) {
                        return !!(value && objectTypes[typeof value]);
                    }
                    function isNaN(value) {
                        return isNumber(value) && value != +value;
                    }
                    function isNull(value) {
                        return value === null;
                    }
                    function isNumber(value) {
                        return typeof value == "number" || value && typeof value == "object" && toString.call(value) == numberClass || false;
                    }
                    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
                        if (!(value && toString.call(value) == objectClass)) {
                            return false;
                        }
                        var valueOf = value.valueOf, objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
                        return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
                    };
                    function isRegExp(value) {
                        return value && typeof value == "object" && toString.call(value) == regexpClass || false;
                    }
                    function isString(value) {
                        return typeof value == "string" || value && typeof value == "object" && toString.call(value) == stringClass || false;
                    }
                    function isUndefined(value) {
                        return typeof value == "undefined";
                    }
                    function mapValues(object, callback, thisArg) {
                        var result = {};
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwn(object, function(value, key, object) {
                            result[key] = callback(value, key, object);
                        });
                        return result;
                    }
                    function merge(object) {
                        var args = arguments, length = 2;
                        if (!isObject(object)) {
                            return object;
                        }
                        if (typeof args[2] != "number") {
                            length = args.length;
                        }
                        if (length > 3 && typeof args[length - 2] == "function") {
                            var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
                        } else if (length > 2 && typeof args[length - 1] == "function") {
                            callback = args[--length];
                        }
                        var sources = slice(arguments, 1, length), index = -1, stackA = getArray(), stackB = getArray();
                        while (++index < length) {
                            baseMerge(object, sources[index], callback, stackA, stackB);
                        }
                        releaseArray(stackA);
                        releaseArray(stackB);
                        return object;
                    }
                    function omit(object, callback, thisArg) {
                        var result = {};
                        if (typeof callback != "function") {
                            var props = [];
                            forIn(object, function(value, key) {
                                props.push(key);
                            });
                            props = baseDifference(props, baseFlatten(arguments, true, false, 1));
                            var index = -1, length = props.length;
                            while (++index < length) {
                                var key = props[index];
                                result[key] = object[key];
                            }
                        } else {
                            callback = lodash.createCallback(callback, thisArg, 3);
                            forIn(object, function(value, key, object) {
                                if (!callback(value, key, object)) {
                                    result[key] = value;
                                }
                            });
                        }
                        return result;
                    }
                    function pairs(object) {
                        var index = -1, props = keys(object), length = props.length, result = Array(length);
                        while (++index < length) {
                            var key = props[index];
                            result[index] = [ key, object[key] ];
                        }
                        return result;
                    }
                    function pick(object, callback, thisArg) {
                        var result = {};
                        if (typeof callback != "function") {
                            var index = -1, props = baseFlatten(arguments, true, false, 1), length = isObject(object) ? props.length : 0;
                            while (++index < length) {
                                var key = props[index];
                                if (key in object) {
                                    result[key] = object[key];
                                }
                            }
                        } else {
                            callback = lodash.createCallback(callback, thisArg, 3);
                            forIn(object, function(value, key, object) {
                                if (callback(value, key, object)) {
                                    result[key] = value;
                                }
                            });
                        }
                        return result;
                    }
                    function transform(object, callback, accumulator, thisArg) {
                        var isArr = isArray(object);
                        if (accumulator == null) {
                            if (isArr) {
                                accumulator = [];
                            } else {
                                var ctor = object && object.constructor, proto = ctor && ctor.prototype;
                                accumulator = baseCreate(proto);
                            }
                        }
                        if (callback) {
                            callback = lodash.createCallback(callback, thisArg, 4);
                            (isArr ? forEach : forOwn)(object, function(value, index, object) {
                                return callback(accumulator, value, index, object);
                            });
                        }
                        return accumulator;
                    }
                    function values(object) {
                        var index = -1, props = keys(object), length = props.length, result = Array(length);
                        while (++index < length) {
                            result[index] = object[props[index]];
                        }
                        return result;
                    }
                    function at(collection) {
                        var args = arguments, index = -1, props = baseFlatten(args, true, false, 1), length = args[2] && args[2][args[1]] === collection ? 1 : props.length, result = Array(length);
                        while (++index < length) {
                            result[index] = collection[props[index]];
                        }
                        return result;
                    }
                    function contains(collection, target, fromIndex) {
                        var index = -1, indexOf = getIndexOf(), length = collection ? collection.length : 0, result = false;
                        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
                        if (isArray(collection)) {
                            result = indexOf(collection, target, fromIndex) > -1;
                        } else if (typeof length == "number") {
                            result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
                        } else {
                            forOwn(collection, function(value) {
                                if (++index >= fromIndex) {
                                    return !(result = value === target);
                                }
                            });
                        }
                        return result;
                    }
                    var countBy = createAggregator(function(result, value, key) {
                        hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1;
                    });
                    function every(collection, callback, thisArg) {
                        var result = true;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                if (!(result = !!callback(collection[index], index, collection))) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                return result = !!callback(value, index, collection);
                            });
                        }
                        return result;
                    }
                    function filter(collection, callback, thisArg) {
                        var result = [];
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                var value = collection[index];
                                if (callback(value, index, collection)) {
                                    result.push(value);
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                if (callback(value, index, collection)) {
                                    result.push(value);
                                }
                            });
                        }
                        return result;
                    }
                    function find(collection, callback, thisArg) {
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                var value = collection[index];
                                if (callback(value, index, collection)) {
                                    return value;
                                }
                            }
                        } else {
                            var result;
                            forOwn(collection, function(value, index, collection) {
                                if (callback(value, index, collection)) {
                                    result = value;
                                    return false;
                                }
                            });
                            return result;
                        }
                    }
                    function findLast(collection, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forEachRight(collection, function(value, index, collection) {
                            if (callback(value, index, collection)) {
                                result = value;
                                return false;
                            }
                        });
                        return result;
                    }
                    function forEach(collection, callback, thisArg) {
                        var index = -1, length = collection ? collection.length : 0;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        if (typeof length == "number") {
                            while (++index < length) {
                                if (callback(collection[index], index, collection) === false) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, callback);
                        }
                        return collection;
                    }
                    function forEachRight(collection, callback, thisArg) {
                        var length = collection ? collection.length : 0;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        if (typeof length == "number") {
                            while (length--) {
                                if (callback(collection[length], length, collection) === false) {
                                    break;
                                }
                            }
                        } else {
                            var props = keys(collection);
                            length = props.length;
                            forOwn(collection, function(value, key, collection) {
                                key = props ? props[--length] : --length;
                                return callback(collection[key], key, collection);
                            });
                        }
                        return collection;
                    }
                    var groupBy = createAggregator(function(result, value, key) {
                        (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
                    });
                    var indexBy = createAggregator(function(result, value, key) {
                        result[key] = value;
                    });
                    function invoke(collection, methodName) {
                        var args = slice(arguments, 2), index = -1, isFunc = typeof methodName == "function", length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
                        forEach(collection, function(value) {
                            result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
                        });
                        return result;
                    }
                    function map(collection, callback, thisArg) {
                        var index = -1, length = collection ? collection.length : 0;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        if (typeof length == "number") {
                            var result = Array(length);
                            while (++index < length) {
                                result[index] = callback(collection[index], index, collection);
                            }
                        } else {
                            result = [];
                            forOwn(collection, function(value, key, collection) {
                                result[++index] = callback(value, key, collection);
                            });
                        }
                        return result;
                    }
                    function max(collection, callback, thisArg) {
                        var computed = -Infinity, result = computed;
                        if (typeof callback != "function" && thisArg && thisArg[callback] === collection) {
                            callback = null;
                        }
                        if (callback == null && isArray(collection)) {
                            var index = -1, length = collection.length;
                            while (++index < length) {
                                var value = collection[index];
                                if (value > result) {
                                    result = value;
                                }
                            }
                        } else {
                            callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                            forEach(collection, function(value, index, collection) {
                                var current = callback(value, index, collection);
                                if (current > computed) {
                                    computed = current;
                                    result = value;
                                }
                            });
                        }
                        return result;
                    }
                    function min(collection, callback, thisArg) {
                        var computed = Infinity, result = computed;
                        if (typeof callback != "function" && thisArg && thisArg[callback] === collection) {
                            callback = null;
                        }
                        if (callback == null && isArray(collection)) {
                            var index = -1, length = collection.length;
                            while (++index < length) {
                                var value = collection[index];
                                if (value < result) {
                                    result = value;
                                }
                            }
                        } else {
                            callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                            forEach(collection, function(value, index, collection) {
                                var current = callback(value, index, collection);
                                if (current < computed) {
                                    computed = current;
                                    result = value;
                                }
                            });
                        }
                        return result;
                    }
                    var pluck = map;
                    function reduce(collection, callback, accumulator, thisArg) {
                        if (!collection) return accumulator;
                        var noaccum = arguments.length < 3;
                        callback = lodash.createCallback(callback, thisArg, 4);
                        var index = -1, length = collection.length;
                        if (typeof length == "number") {
                            if (noaccum) {
                                accumulator = collection[++index];
                            }
                            while (++index < length) {
                                accumulator = callback(accumulator, collection[index], index, collection);
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
                            });
                        }
                        return accumulator;
                    }
                    function reduceRight(collection, callback, accumulator, thisArg) {
                        var noaccum = arguments.length < 3;
                        callback = lodash.createCallback(callback, thisArg, 4);
                        forEachRight(collection, function(value, index, collection) {
                            accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
                        });
                        return accumulator;
                    }
                    function reject(collection, callback, thisArg) {
                        callback = lodash.createCallback(callback, thisArg, 3);
                        return filter(collection, function(value, index, collection) {
                            return !callback(value, index, collection);
                        });
                    }
                    function sample(collection, n, guard) {
                        if (collection && typeof collection.length != "number") {
                            collection = values(collection);
                        }
                        if (n == null || guard) {
                            return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
                        }
                        var result = shuffle(collection);
                        result.length = nativeMin(nativeMax(0, n), result.length);
                        return result;
                    }
                    function shuffle(collection) {
                        var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
                        forEach(collection, function(value) {
                            var rand = baseRandom(0, ++index);
                            result[index] = result[rand];
                            result[rand] = value;
                        });
                        return result;
                    }
                    function size(collection) {
                        var length = collection ? collection.length : 0;
                        return typeof length == "number" ? length : keys(collection).length;
                    }
                    function some(collection, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                if (result = callback(collection[index], index, collection)) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                return !(result = callback(value, index, collection));
                            });
                        }
                        return !!result;
                    }
                    function sortBy(collection, callback, thisArg) {
                        var index = -1, isArr = isArray(callback), length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
                        if (!isArr) {
                            callback = lodash.createCallback(callback, thisArg, 3);
                        }
                        forEach(collection, function(value, key, collection) {
                            var object = result[++index] = getObject();
                            if (isArr) {
                                object.criteria = map(callback, function(key) {
                                    return value[key];
                                });
                            } else {
                                (object.criteria = getArray())[0] = callback(value, key, collection);
                            }
                            object.index = index;
                            object.value = value;
                        });
                        length = result.length;
                        result.sort(compareAscending);
                        while (length--) {
                            var object = result[length];
                            result[length] = object.value;
                            if (!isArr) {
                                releaseArray(object.criteria);
                            }
                            releaseObject(object);
                        }
                        return result;
                    }
                    function toArray(collection) {
                        if (collection && typeof collection.length == "number") {
                            return slice(collection);
                        }
                        return values(collection);
                    }
                    var where = filter;
                    function compact(array) {
                        var index = -1, length = array ? array.length : 0, result = [];
                        while (++index < length) {
                            var value = array[index];
                            if (value) {
                                result.push(value);
                            }
                        }
                        return result;
                    }
                    function difference(array) {
                        return baseDifference(array, baseFlatten(arguments, true, true, 1));
                    }
                    function findIndex(array, callback, thisArg) {
                        var index = -1, length = array ? array.length : 0;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (++index < length) {
                            if (callback(array[index], index, array)) {
                                return index;
                            }
                        }
                        return -1;
                    }
                    function findLastIndex(array, callback, thisArg) {
                        var length = array ? array.length : 0;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (length--) {
                            if (callback(array[length], length, array)) {
                                return length;
                            }
                        }
                        return -1;
                    }
                    function first(array, callback, thisArg) {
                        var n = 0, length = array ? array.length : 0;
                        if (typeof callback != "number" && callback != null) {
                            var index = -1;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (++index < length && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback;
                            if (n == null || thisArg) {
                                return array ? array[0] : undefined;
                            }
                        }
                        return slice(array, 0, nativeMin(nativeMax(0, n), length));
                    }
                    function flatten(array, isShallow, callback, thisArg) {
                        if (typeof isShallow != "boolean" && isShallow != null) {
                            thisArg = callback;
                            callback = typeof isShallow != "function" && thisArg && thisArg[isShallow] === array ? null : isShallow;
                            isShallow = false;
                        }
                        if (callback != null) {
                            array = map(array, callback, thisArg);
                        }
                        return baseFlatten(array, isShallow);
                    }
                    function indexOf(array, value, fromIndex) {
                        if (typeof fromIndex == "number") {
                            var length = array ? array.length : 0;
                            fromIndex = fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0;
                        } else if (fromIndex) {
                            var index = sortedIndex(array, value);
                            return array[index] === value ? index : -1;
                        }
                        return baseIndexOf(array, value, fromIndex);
                    }
                    function initial(array, callback, thisArg) {
                        var n = 0, length = array ? array.length : 0;
                        if (typeof callback != "number" && callback != null) {
                            var index = length;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (index-- && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback == null || thisArg ? 1 : callback || n;
                        }
                        return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
                    }
                    function intersection() {
                        var args = [], argsIndex = -1, argsLength = arguments.length, caches = getArray(), indexOf = getIndexOf(), trustIndexOf = indexOf === baseIndexOf, seen = getArray();
                        while (++argsIndex < argsLength) {
                            var value = arguments[argsIndex];
                            if (isArray(value) || isArguments(value)) {
                                args.push(value);
                                caches.push(trustIndexOf && value.length >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen));
                            }
                        }
                        var array = args[0], index = -1, length = array ? array.length : 0, result = [];
                        outer: while (++index < length) {
                            var cache = caches[0];
                            value = array[index];
                            if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                                argsIndex = argsLength;
                                (cache || seen).push(value);
                                while (--argsIndex) {
                                    cache = caches[argsIndex];
                                    if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                                        continue outer;
                                    }
                                }
                                result.push(value);
                            }
                        }
                        while (argsLength--) {
                            cache = caches[argsLength];
                            if (cache) {
                                releaseObject(cache);
                            }
                        }
                        releaseArray(caches);
                        releaseArray(seen);
                        return result;
                    }
                    function last(array, callback, thisArg) {
                        var n = 0, length = array ? array.length : 0;
                        if (typeof callback != "number" && callback != null) {
                            var index = length;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (index-- && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback;
                            if (n == null || thisArg) {
                                return array ? array[length - 1] : undefined;
                            }
                        }
                        return slice(array, nativeMax(0, length - n));
                    }
                    function lastIndexOf(array, value, fromIndex) {
                        var index = array ? array.length : 0;
                        if (typeof fromIndex == "number") {
                            index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
                        }
                        while (index--) {
                            if (array[index] === value) {
                                return index;
                            }
                        }
                        return -1;
                    }
                    function pull(array) {
                        var args = arguments, argsIndex = 0, argsLength = args.length, length = array ? array.length : 0;
                        while (++argsIndex < argsLength) {
                            var index = -1, value = args[argsIndex];
                            while (++index < length) {
                                if (array[index] === value) {
                                    splice.call(array, index--, 1);
                                    length--;
                                }
                            }
                        }
                        return array;
                    }
                    function range(start, end, step) {
                        start = +start || 0;
                        step = typeof step == "number" ? step : +step || 1;
                        if (end == null) {
                            end = start;
                            start = 0;
                        }
                        var index = -1, length = nativeMax(0, ceil((end - start) / (step || 1))), result = Array(length);
                        while (++index < length) {
                            result[index] = start;
                            start += step;
                        }
                        return result;
                    }
                    function remove(array, callback, thisArg) {
                        var index = -1, length = array ? array.length : 0, result = [];
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (++index < length) {
                            var value = array[index];
                            if (callback(value, index, array)) {
                                result.push(value);
                                splice.call(array, index--, 1);
                                length--;
                            }
                        }
                        return result;
                    }
                    function rest(array, callback, thisArg) {
                        if (typeof callback != "number" && callback != null) {
                            var n = 0, index = -1, length = array ? array.length : 0;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (++index < length && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback == null || thisArg ? 1 : nativeMax(0, callback);
                        }
                        return slice(array, n);
                    }
                    function sortedIndex(array, value, callback, thisArg) {
                        var low = 0, high = array ? array.length : low;
                        callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
                        value = callback(value);
                        while (low < high) {
                            var mid = low + high >>> 1;
                            callback(array[mid]) < value ? low = mid + 1 : high = mid;
                        }
                        return low;
                    }
                    function union() {
                        return baseUniq(baseFlatten(arguments, true, true));
                    }
                    function uniq(array, isSorted, callback, thisArg) {
                        if (typeof isSorted != "boolean" && isSorted != null) {
                            thisArg = callback;
                            callback = typeof isSorted != "function" && thisArg && thisArg[isSorted] === array ? null : isSorted;
                            isSorted = false;
                        }
                        if (callback != null) {
                            callback = lodash.createCallback(callback, thisArg, 3);
                        }
                        return baseUniq(array, isSorted, callback);
                    }
                    function without(array) {
                        return baseDifference(array, slice(arguments, 1));
                    }
                    function xor() {
                        var index = -1, length = arguments.length;
                        while (++index < length) {
                            var array = arguments[index];
                            if (isArray(array) || isArguments(array)) {
                                var result = result ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result))) : array;
                            }
                        }
                        return result || [];
                    }
                    function zip() {
                        var array = arguments.length > 1 ? arguments : arguments[0], index = -1, length = array ? max(pluck(array, "length")) : 0, result = Array(length < 0 ? 0 : length);
                        while (++index < length) {
                            result[index] = pluck(array, index);
                        }
                        return result;
                    }
                    function zipObject(keys, values) {
                        var index = -1, length = keys ? keys.length : 0, result = {};
                        if (!values && length && !isArray(keys[0])) {
                            values = [];
                        }
                        while (++index < length) {
                            var key = keys[index];
                            if (values) {
                                result[key] = values[index];
                            } else if (key) {
                                result[key[0]] = key[1];
                            }
                        }
                        return result;
                    }
                    function after(n, func) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        return function() {
                            if (--n < 1) {
                                return func.apply(this, arguments);
                            }
                        };
                    }
                    function bind(func, thisArg) {
                        return arguments.length > 2 ? createWrapper(func, 17, slice(arguments, 2), null, thisArg) : createWrapper(func, 1, null, null, thisArg);
                    }
                    function bindAll(object) {
                        var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object), index = -1, length = funcs.length;
                        while (++index < length) {
                            var key = funcs[index];
                            object[key] = createWrapper(object[key], 1, null, null, object);
                        }
                        return object;
                    }
                    function bindKey(object, key) {
                        return arguments.length > 2 ? createWrapper(key, 19, slice(arguments, 2), null, object) : createWrapper(key, 3, null, null, object);
                    }
                    function compose() {
                        var funcs = arguments, length = funcs.length;
                        while (length--) {
                            if (!isFunction(funcs[length])) {
                                throw new TypeError();
                            }
                        }
                        return function() {
                            var args = arguments, length = funcs.length;
                            while (length--) {
                                args = [ funcs[length].apply(this, args) ];
                            }
                            return args[0];
                        };
                    }
                    function curry(func, arity) {
                        arity = typeof arity == "number" ? arity : +arity || func.length;
                        return createWrapper(func, 4, null, null, null, arity);
                    }
                    function debounce(func, wait, options) {
                        var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = false, trailing = true;
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        wait = nativeMax(0, wait) || 0;
                        if (options === true) {
                            var leading = true;
                            trailing = false;
                        } else if (isObject(options)) {
                            leading = options.leading;
                            maxWait = "maxWait" in options && (nativeMax(wait, options.maxWait) || 0);
                            trailing = "trailing" in options ? options.trailing : trailing;
                        }
                        var delayed = function() {
                            var remaining = wait - (now() - stamp);
                            if (remaining <= 0) {
                                if (maxTimeoutId) {
                                    clearTimeout(maxTimeoutId);
                                }
                                var isCalled = trailingCall;
                                maxTimeoutId = timeoutId = trailingCall = undefined;
                                if (isCalled) {
                                    lastCalled = now();
                                    result = func.apply(thisArg, args);
                                    if (!timeoutId && !maxTimeoutId) {
                                        args = thisArg = null;
                                    }
                                }
                            } else {
                                timeoutId = setTimeout(delayed, remaining);
                            }
                        };
                        var maxDelayed = function() {
                            if (timeoutId) {
                                clearTimeout(timeoutId);
                            }
                            maxTimeoutId = timeoutId = trailingCall = undefined;
                            if (trailing || maxWait !== wait) {
                                lastCalled = now();
                                result = func.apply(thisArg, args);
                                if (!timeoutId && !maxTimeoutId) {
                                    args = thisArg = null;
                                }
                            }
                        };
                        return function() {
                            args = arguments;
                            stamp = now();
                            thisArg = this;
                            trailingCall = trailing && (timeoutId || !leading);
                            if (maxWait === false) {
                                var leadingCall = leading && !timeoutId;
                            } else {
                                if (!maxTimeoutId && !leading) {
                                    lastCalled = stamp;
                                }
                                var remaining = maxWait - (stamp - lastCalled), isCalled = remaining <= 0;
                                if (isCalled) {
                                    if (maxTimeoutId) {
                                        maxTimeoutId = clearTimeout(maxTimeoutId);
                                    }
                                    lastCalled = stamp;
                                    result = func.apply(thisArg, args);
                                } else if (!maxTimeoutId) {
                                    maxTimeoutId = setTimeout(maxDelayed, remaining);
                                }
                            }
                            if (isCalled && timeoutId) {
                                timeoutId = clearTimeout(timeoutId);
                            } else if (!timeoutId && wait !== maxWait) {
                                timeoutId = setTimeout(delayed, wait);
                            }
                            if (leadingCall) {
                                isCalled = true;
                                result = func.apply(thisArg, args);
                            }
                            if (isCalled && !timeoutId && !maxTimeoutId) {
                                args = thisArg = null;
                            }
                            return result;
                        };
                    }
                    function defer(func) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        var args = slice(arguments, 1);
                        return setTimeout(function() {
                            func.apply(undefined, args);
                        }, 1);
                    }
                    function delay(func, wait) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        var args = slice(arguments, 2);
                        return setTimeout(function() {
                            func.apply(undefined, args);
                        }, wait);
                    }
                    function memoize(func, resolver) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        var memoized = function() {
                            var cache = memoized.cache, key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
                            return hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = func.apply(this, arguments);
                        };
                        memoized.cache = {};
                        return memoized;
                    }
                    function once(func) {
                        var ran, result;
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        return function() {
                            if (ran) {
                                return result;
                            }
                            ran = true;
                            result = func.apply(this, arguments);
                            func = null;
                            return result;
                        };
                    }
                    function partial(func) {
                        return createWrapper(func, 16, slice(arguments, 1));
                    }
                    function partialRight(func) {
                        return createWrapper(func, 32, null, slice(arguments, 1));
                    }
                    function throttle(func, wait, options) {
                        var leading = true, trailing = true;
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        if (options === false) {
                            leading = false;
                        } else if (isObject(options)) {
                            leading = "leading" in options ? options.leading : leading;
                            trailing = "trailing" in options ? options.trailing : trailing;
                        }
                        debounceOptions.leading = leading;
                        debounceOptions.maxWait = wait;
                        debounceOptions.trailing = trailing;
                        return debounce(func, wait, debounceOptions);
                    }
                    function wrap(value, wrapper) {
                        return createWrapper(wrapper, 16, [ value ]);
                    }
                    function constant(value) {
                        return function() {
                            return value;
                        };
                    }
                    function createCallback(func, thisArg, argCount) {
                        var type = typeof func;
                        if (func == null || type == "function") {
                            return baseCreateCallback(func, thisArg, argCount);
                        }
                        if (type != "object") {
                            return property(func);
                        }
                        var props = keys(func), key = props[0], a = func[key];
                        if (props.length == 1 && a === a && !isObject(a)) {
                            return function(object) {
                                var b = object[key];
                                return a === b && (a !== 0 || 1 / a == 1 / b);
                            };
                        }
                        return function(object) {
                            var length = props.length, result = false;
                            while (length--) {
                                if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
                                    break;
                                }
                            }
                            return result;
                        };
                    }
                    function escape(string) {
                        return string == null ? "" : String(string).replace(reUnescapedHtml, escapeHtmlChar);
                    }
                    function identity(value) {
                        return value;
                    }
                    function mixin(object, source, options) {
                        var chain = true, methodNames = source && functions(source);
                        if (!source || !options && !methodNames.length) {
                            if (options == null) {
                                options = source;
                            }
                            ctor = lodashWrapper;
                            source = object;
                            object = lodash;
                            methodNames = functions(source);
                        }
                        if (options === false) {
                            chain = false;
                        } else if (isObject(options) && "chain" in options) {
                            chain = options.chain;
                        }
                        var ctor = object, isFunc = isFunction(ctor);
                        forEach(methodNames, function(methodName) {
                            var func = object[methodName] = source[methodName];
                            if (isFunc) {
                                ctor.prototype[methodName] = function() {
                                    var chainAll = this.__chain__, value = this.__wrapped__, args = [ value ];
                                    push.apply(args, arguments);
                                    var result = func.apply(object, args);
                                    if (chain || chainAll) {
                                        if (value === result && isObject(result)) {
                                            return this;
                                        }
                                        result = new ctor(result);
                                        result.__chain__ = chainAll;
                                    }
                                    return result;
                                };
                            }
                        });
                    }
                    function noConflict() {
                        context._ = oldDash;
                        return this;
                    }
                    function noop() {}
                    var now = isNative(now = Date.now) && now || function() {
                        return new Date().getTime();
                    };
                    var parseInt = nativeParseInt(whitespace + "08") == 8 ? nativeParseInt : function(value, radix) {
                        return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, "") : value, radix || 0);
                    };
                    function property(key) {
                        return function(object) {
                            return object[key];
                        };
                    }
                    function random(min, max, floating) {
                        var noMin = min == null, noMax = max == null;
                        if (floating == null) {
                            if (typeof min == "boolean" && noMax) {
                                floating = min;
                                min = 1;
                            } else if (!noMax && typeof max == "boolean") {
                                floating = max;
                                noMax = true;
                            }
                        }
                        if (noMin && noMax) {
                            max = 1;
                        }
                        min = +min || 0;
                        if (noMax) {
                            max = min;
                            min = 0;
                        } else {
                            max = +max || 0;
                        }
                        if (floating || min % 1 || max % 1) {
                            var rand = nativeRandom();
                            return nativeMin(min + rand * (max - min + parseFloat("1e-" + ((rand + "").length - 1))), max);
                        }
                        return baseRandom(min, max);
                    }
                    function result(object, key) {
                        if (object) {
                            var value = object[key];
                            return isFunction(value) ? object[key]() : value;
                        }
                    }
                    function template(text, data, options) {
                        var settings = lodash.templateSettings;
                        text = String(text || "");
                        options = defaults({}, options, settings);
                        var imports = defaults({}, options.imports, settings.imports), importsKeys = keys(imports), importsValues = values(imports);
                        var isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
                        var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
                        text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                            interpolateValue || (interpolateValue = esTemplateValue);
                            source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                            if (escapeValue) {
                                source += "' +\n__e(" + escapeValue + ") +\n'";
                            }
                            if (evaluateValue) {
                                isEvaluating = true;
                                source += "';\n" + evaluateValue + ";\n__p += '";
                            }
                            if (interpolateValue) {
                                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                            }
                            index = offset + match.length;
                            return match;
                        });
                        source += "';\n";
                        var variable = options.variable, hasVariable = variable;
                        if (!hasVariable) {
                            variable = "obj";
                            source = "with (" + variable + ") {\n" + source + "\n}\n";
                        }
                        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
                        source = "function(" + variable + ") {\n" + (hasVariable ? "" : variable + " || (" + variable + " = {});\n") + "var __t, __p = '', __e = _.escape" + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                        var sourceURL = "\n/*\n//# sourceURL=" + (options.sourceURL || "/lodash/template/source[" + templateCounter++ + "]") + "\n*/";
                        try {
                            var result = Function(importsKeys, "return " + source + sourceURL).apply(undefined, importsValues);
                        } catch (e) {
                            e.source = source;
                            throw e;
                        }
                        if (data) {
                            return result(data);
                        }
                        result.source = source;
                        return result;
                    }
                    function times(n, callback, thisArg) {
                        n = (n = +n) > -1 ? n : 0;
                        var index = -1, result = Array(n);
                        callback = baseCreateCallback(callback, thisArg, 1);
                        while (++index < n) {
                            result[index] = callback(index);
                        }
                        return result;
                    }
                    function unescape(string) {
                        return string == null ? "" : String(string).replace(reEscapedHtml, unescapeHtmlChar);
                    }
                    function uniqueId(prefix) {
                        var id = ++idCounter;
                        return String(prefix == null ? "" : prefix) + id;
                    }
                    function chain(value) {
                        value = new lodashWrapper(value);
                        value.__chain__ = true;
                        return value;
                    }
                    function tap(value, interceptor) {
                        interceptor(value);
                        return value;
                    }
                    function wrapperChain() {
                        this.__chain__ = true;
                        return this;
                    }
                    function wrapperToString() {
                        return String(this.__wrapped__);
                    }
                    function wrapperValueOf() {
                        return this.__wrapped__;
                    }
                    lodash.after = after;
                    lodash.assign = assign;
                    lodash.at = at;
                    lodash.bind = bind;
                    lodash.bindAll = bindAll;
                    lodash.bindKey = bindKey;
                    lodash.chain = chain;
                    lodash.compact = compact;
                    lodash.compose = compose;
                    lodash.constant = constant;
                    lodash.countBy = countBy;
                    lodash.create = create;
                    lodash.createCallback = createCallback;
                    lodash.curry = curry;
                    lodash.debounce = debounce;
                    lodash.defaults = defaults;
                    lodash.defer = defer;
                    lodash.delay = delay;
                    lodash.difference = difference;
                    lodash.filter = filter;
                    lodash.flatten = flatten;
                    lodash.forEach = forEach;
                    lodash.forEachRight = forEachRight;
                    lodash.forIn = forIn;
                    lodash.forInRight = forInRight;
                    lodash.forOwn = forOwn;
                    lodash.forOwnRight = forOwnRight;
                    lodash.functions = functions;
                    lodash.groupBy = groupBy;
                    lodash.indexBy = indexBy;
                    lodash.initial = initial;
                    lodash.intersection = intersection;
                    lodash.invert = invert;
                    lodash.invoke = invoke;
                    lodash.keys = keys;
                    lodash.map = map;
                    lodash.mapValues = mapValues;
                    lodash.max = max;
                    lodash.memoize = memoize;
                    lodash.merge = merge;
                    lodash.min = min;
                    lodash.omit = omit;
                    lodash.once = once;
                    lodash.pairs = pairs;
                    lodash.partial = partial;
                    lodash.partialRight = partialRight;
                    lodash.pick = pick;
                    lodash.pluck = pluck;
                    lodash.property = property;
                    lodash.pull = pull;
                    lodash.range = range;
                    lodash.reject = reject;
                    lodash.remove = remove;
                    lodash.rest = rest;
                    lodash.shuffle = shuffle;
                    lodash.sortBy = sortBy;
                    lodash.tap = tap;
                    lodash.throttle = throttle;
                    lodash.times = times;
                    lodash.toArray = toArray;
                    lodash.transform = transform;
                    lodash.union = union;
                    lodash.uniq = uniq;
                    lodash.values = values;
                    lodash.where = where;
                    lodash.without = without;
                    lodash.wrap = wrap;
                    lodash.xor = xor;
                    lodash.zip = zip;
                    lodash.zipObject = zipObject;
                    lodash.collect = map;
                    lodash.drop = rest;
                    lodash.each = forEach;
                    lodash.eachRight = forEachRight;
                    lodash.extend = assign;
                    lodash.methods = functions;
                    lodash.object = zipObject;
                    lodash.select = filter;
                    lodash.tail = rest;
                    lodash.unique = uniq;
                    lodash.unzip = zip;
                    mixin(lodash);
                    lodash.clone = clone;
                    lodash.cloneDeep = cloneDeep;
                    lodash.contains = contains;
                    lodash.escape = escape;
                    lodash.every = every;
                    lodash.find = find;
                    lodash.findIndex = findIndex;
                    lodash.findKey = findKey;
                    lodash.findLast = findLast;
                    lodash.findLastIndex = findLastIndex;
                    lodash.findLastKey = findLastKey;
                    lodash.has = has;
                    lodash.identity = identity;
                    lodash.indexOf = indexOf;
                    lodash.isArguments = isArguments;
                    lodash.isArray = isArray;
                    lodash.isBoolean = isBoolean;
                    lodash.isDate = isDate;
                    lodash.isElement = isElement;
                    lodash.isEmpty = isEmpty;
                    lodash.isEqual = isEqual;
                    lodash.isFinite = isFinite;
                    lodash.isFunction = isFunction;
                    lodash.isNaN = isNaN;
                    lodash.isNull = isNull;
                    lodash.isNumber = isNumber;
                    lodash.isObject = isObject;
                    lodash.isPlainObject = isPlainObject;
                    lodash.isRegExp = isRegExp;
                    lodash.isString = isString;
                    lodash.isUndefined = isUndefined;
                    lodash.lastIndexOf = lastIndexOf;
                    lodash.mixin = mixin;
                    lodash.noConflict = noConflict;
                    lodash.noop = noop;
                    lodash.now = now;
                    lodash.parseInt = parseInt;
                    lodash.random = random;
                    lodash.reduce = reduce;
                    lodash.reduceRight = reduceRight;
                    lodash.result = result;
                    lodash.runInContext = runInContext;
                    lodash.size = size;
                    lodash.some = some;
                    lodash.sortedIndex = sortedIndex;
                    lodash.template = template;
                    lodash.unescape = unescape;
                    lodash.uniqueId = uniqueId;
                    lodash.all = every;
                    lodash.any = some;
                    lodash.detect = find;
                    lodash.findWhere = find;
                    lodash.foldl = reduce;
                    lodash.foldr = reduceRight;
                    lodash.include = contains;
                    lodash.inject = reduce;
                    mixin(function() {
                        var source = {};
                        forOwn(lodash, function(func, methodName) {
                            if (!lodash.prototype[methodName]) {
                                source[methodName] = func;
                            }
                        });
                        return source;
                    }(), false);
                    lodash.first = first;
                    lodash.last = last;
                    lodash.sample = sample;
                    lodash.take = first;
                    lodash.head = first;
                    forOwn(lodash, function(func, methodName) {
                        var callbackable = methodName !== "sample";
                        if (!lodash.prototype[methodName]) {
                            lodash.prototype[methodName] = function(n, guard) {
                                var chainAll = this.__chain__, result = func(this.__wrapped__, n, guard);
                                return !chainAll && (n == null || guard && !(callbackable && typeof n == "function")) ? result : new lodashWrapper(result, chainAll);
                            };
                        }
                    });
                    lodash.VERSION = "2.4.1";
                    lodash.prototype.chain = wrapperChain;
                    lodash.prototype.toString = wrapperToString;
                    lodash.prototype.value = wrapperValueOf;
                    lodash.prototype.valueOf = wrapperValueOf;
                    forEach([ "join", "pop", "shift" ], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            var chainAll = this.__chain__, result = func.apply(this.__wrapped__, arguments);
                            return chainAll ? new lodashWrapper(result, chainAll) : result;
                        };
                    });
                    forEach([ "push", "reverse", "sort", "unshift" ], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            func.apply(this.__wrapped__, arguments);
                            return this;
                        };
                    });
                    forEach([ "concat", "slice", "splice" ], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
                        };
                    });
                    return lodash;
                }
                var _ = runInContext();
                if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
                    root._ = _;
                    define(function() {
                        return _;
                    });
                } else if (freeExports && freeModule) {
                    if (moduleExports) {
                        (freeModule.exports = _)._ = _;
                    } else {
                        freeExports._ = _;
                    }
                } else {
                    root._ = _;
                }
            }).call(this);
        }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {} ],
    2: [ function(require, module, exports) {
        module.exports = function(element, callback) {
            function addResizeListener(element, callback) {
                if (window.OverflowEvent) {
                    element.addEventListener("overflowchanged", function(e) {
                        callback.call(this, e);
                    });
                } else {
                    element.addEventListener("overflow", function(e) {
                        callback.call(this, e);
                    });
                    element.addEventListener("underflow", function(e) {
                        callback.call(this, e);
                    });
                }
            }
            function EventQueue() {
                this.q = [];
                this.add = function(ev) {
                    this.q.push(ev);
                };
                var i, j;
                this.call = function() {
                    for (i = 0, j = this.q.length; i < j; i++) {
                        this.q[i].call();
                    }
                };
            }
            function getComputedStyle(element, prop) {
                if (element.currentStyle) {
                    return element.currentStyle[prop];
                } else if (window.getComputedStyle) {
                    return window.getComputedStyle(element, null).getPropertyValue(prop);
                } else {
                    return element.style[prop];
                }
            }
            function attachResizeEvent(element, resized) {
                if (!element.resizedAttached) {
                    element.resizedAttached = new EventQueue();
                    element.resizedAttached.add(resized);
                } else if (element.resizedAttached) {
                    element.resizedAttached.add(resized);
                    return;
                }
                var myResized = function() {
                    if (setupSensor()) {
                        element.resizedAttached.call();
                    }
                };
                element.resizeSensor = document.createElement("div");
                element.resizeSensor.className = "resize-sensor";
                var style = "position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1;";
                element.resizeSensor.style.cssText = style;
                element.resizeSensor.innerHTML = '<div class="resize-sensor-overflow" style="' + style + '">' + "<div></div>" + "</div>" + '<div class="resize-sensor-underflow" style="' + style + '">' + "<div></div>" + "</div>";
                element.appendChild(element.resizeSensor);
                if ("absolute" !== getComputedStyle(element, "position")) {
                    element.style.position = "relative";
                }
                var x = -1, y = -1, firstStyle = element.resizeSensor.firstElementChild.firstChild.style, lastStyle = element.resizeSensor.lastElementChild.firstChild.style;
                function setupSensor() {
                    var change = false, width = element.resizeSensor.offsetWidth, height = element.resizeSensor.offsetHeight;
                    if (x != width) {
                        firstStyle.width = width - 1 + "px";
                        lastStyle.width = width + 1 + "px";
                        change = true;
                        x = width;
                    }
                    if (y != height) {
                        firstStyle.height = height - 1 + "px";
                        lastStyle.height = height + 1 + "px";
                        change = true;
                        y = height;
                    }
                    return change;
                }
                setupSensor();
                addResizeListener(element.resizeSensor, myResized);
                addResizeListener(element.resizeSensor.firstElementChild, myResized);
                addResizeListener(element.resizeSensor.lastElementChild, myResized);
            }
            if ("array" === typeof element || "undefined" !== typeof jQuery && element instanceof jQuery || "undefined" !== typeof Elements && element instanceof Elements) {
                var i = 0, j = element.length;
                for (;i < j; i++) {
                    attachResizeEvent(element[i], callback);
                }
            } else {
                attachResizeEvent(element, callback);
            }
        };
    }, {} ],
    3: [ function(require, module, exports) {
        var ResizeSensor, _;
        _ = require("lodash");
        ResizeSensor = require("./ResizeSensor");
        Polymer("ui-grid-tiler", {
            resize: function() {
                var children, visible;
                if (this.selector || this.children) {
                    children = this.querySelectorAll(this.selector);
                }
                visible = 0;
                _.each(children, function(tile) {
                    if (tile.clientWidth > 0 && tile.clientHeight > 0) {
                        return visible += 1;
                    }
                });
                return _.each(children, function(tile) {
                    _.each(tile.classList, function(check) {
                        if (check.slice(0, 5) === "tile-") {
                            return tile.classList.remove(check);
                        }
                    });
                    return tile.classList.add("tile-" + visible);
                });
            },
            childrenMutated: function() {
                this.resize();
                return this.onMutation(this, function(_this) {
                    return function() {
                        return _this.childrenMutated();
                    };
                }(this));
            },
            created: function() {},
            ready: function() {},
            attached: function() {
                this.sensor = new ResizeSensor(this, function(_this) {
                    return function() {
                        return _this.resize();
                    };
                }(this));
                window.addEventListener("resize", function(_this) {
                    return function() {
                        return _this.resize();
                    };
                }(this));
                this.resize();
                return this.onMutation(this, function(_this) {
                    return function() {
                        return _this.childrenMutated();
                    };
                }(this));
            },
            domReady: function() {},
            detached: function() {}
        });
    }, {
        "./ResizeSensor": 2,
        lodash: 1
    } ]
}, {}, [ 3 ]);</script>
</polymer-element>

<polymer-element name="ui-progress" attributes="percentage">
<template>
  <style>.hide {
  display: none !important;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(0, 0, 0, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease;
  -webkit-transition: opacity 0.2s ease;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease, opacity 0.2s ease;
  -webkit-transition: height 0.2s ease, opacity 0.2s ease;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
.sheen {
  background-image: linear-gradient(rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.1));
}
:host {
  display: inline-block;
}
#bar {
  display: block;
  position: fixed;
  z-index: 999999;
  top: 0;
  left: 0;
  right: 0;
  height: 2px;
  background-color: transparent;
}
#fill {
  display: inline-block;
  position: absolute;
  left: 0;
  top: 0;
  height: 100%;
  background: #ef272d;
  transition: 0.2s ease;
  -webkit-transition: 0.2s ease;
}
#leader {
  display: inline-block;
  position: absolute;
  min-width: 10px;
  width: 1%;
  right: 0;
  height: 100%;
  background: #ef272d;
  box-shadow: 0 0 10px #ef272d;
}
</style>
  <section id="bar">
    <section id="fill" fadeout=""><section id="leader"></section></section>
  </section>
  <content></content>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-progress/src/ui-progress.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        var TRICKLE_RATE, TRICKLE_TIMER;
        TRICKLE_TIMER = 800;
        TRICKLE_RATE = 2;
        Polymer("ui-progress", {
            percentageChanged: function() {
                this.$.fill.style.width = "" + this.percentage + "%";
                if (Number(this.percentage) >= 100 || Number(this.percentage) <= 0) {
                    this.$.fill.setAttribute("hide", "");
                    return setTimeout(function(_this) {
                        return function() {
                            return _this.percentage = 0;
                        };
                    }(this), TRICKLE_TIMER);
                } else {
                    this.$.fill.removeAttribute("hide");
                    return setTimeout(function(_this) {
                        return function() {
                            return _this.percentage = Number(_this.percentage) + Math.random() * TRICKLE_RATE;
                        };
                    }(this), TRICKLE_TIMER);
                }
            },
            start: function(percentage) {
                return this.percentage = percentage || 1;
            },
            stop: function(percentage) {
                return this.percentage = 100;
            },
            created: function() {},
            ready: function() {},
            attached: function() {},
            domReady: function() {},
            detached: function() {}
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>

<polymer-element name="ui-modal" attributes="" on-click="{{hide}}" on-transitionend="{{displayAnimation}}" on-webkittransitionend="{{displayAnimation}}" offscreen="" hide="">
<template>
  <style>.hide {
  display: none !important;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(0, 0, 0, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease;
  -webkit-transition: opacity 0.2s ease;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease, opacity 0.2s ease;
  -webkit-transition: height 0.2s ease, opacity 0.2s ease;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
.sheen {
  background-image: linear-gradient(rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.1));
}
:host {
  position: fixed;
  display: flex;
  align-items: center;
  justify-content: center;
  top: 0;
  left: 0;
  right: 0;
  height: 100%;
  z-index: 999999;
  background-color: rgba(0, 0, 0, 0.85);
  opacity: 1.0;
  transition: opacity 0.2s ease;
  -webkit-transition: opacity 0.2s ease;
}
:host([hide]) {
  opacity: 0;
}
:host([offscreen]) {
  height: 0;
}
#display {
  max-width: 50%;
  max-height: 50%;
  background-color: #ffffff;
  padding: 1em;
  box-shadow: 0px 0px 3px 3px #333333, 0px 0px 1px 1px #333333 inset;
  -webkit-box-shadow: 0px 0px 3px 3px #333333, 0px 0px 1px 1px #333333 inset;
  opacity: 1.0;
  transition: 0.2s ease;
  -webkit-transition: 0.2s ease;
  transform: scale(1, 1);
  -webkit-transform: scale(1, 1);
}
#display[hide] {
  opacity: 0 !important;
  transform: scale(0.5, 0.5);
  -webkit-transform: scale(0.5, 0.5);
}
</style>
  <section id="display" hide="">
    <content></content>
  </section>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-modal/src/ui-modal.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        Polymer("ui-modal", {
            show: function() {
                this.removeAttribute("offscreen");
                this.removeAttribute("hide");
                return this.showing = true;
            },
            hide: function(evt) {
                this.$.display.setAttribute("hide", "");
                this.hiding = true;
                return evt != null ? evt.stopPropagation() : void 0;
            },
            displayAnimation: function(evt) {
                if (this.showing) {
                    this.$.display.removeAttribute("hide");
                    this.showing = false;
                    this.fire("shown");
                }
                if (this.hiding && !this.hasAttribute("hide")) {
                    this.setAttribute("hide", "");
                    setTimeout(function(_this) {
                        return function() {
                            return _this.setAttribute("offscreen", "");
                        };
                    }(this), 400);
                    this.hiding = false;
                    return this.fire("hidden");
                }
            },
            created: function() {},
            ready: function() {},
            attached: function() {},
            domReady: function() {},
            detached: function() {}
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>

<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<!--
@group Polymer Core Elements

The `core-ajax` element exposes `XMLHttpRequest` functionality.

    <core-ajax
        auto
        url="http://gdata.youtube.com/feeds/api/videos/"
        params='{"alt":"json", "q":"chrome"}'
        handleAs="json"
        on-core-response="{{handleResponse}}"></core-ajax>
 
With `auto` set to `true`, the element performs a request whenever
its `url` or `params` properties are changed.

Note: The `params` attribute must be double quoted JSON.

You can trigger a request explicitly by calling `go` on the
element.

@element core-ajax
@status beta
@homepage github.io
-->
<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<!--
/**
 * @group Polymer Core Elements
 *
 * core-xhr can be used to perform XMLHttpRequests.
 *
 *     <core-xhr id="xhr"></core-xhr>
 *     ...
 *     this.$.xhr.request({url: url, params: params, callback: callback});
 *
 * @element core-xhr
 */
-->



<polymer-element name="core-xhr" hidden>

  <script>

    Polymer('core-xhr', {

      /**
       * Sends a HTTP request to the server and returns the XHR object.
       *
       * @method request
       * @param {Object} inOptions
       *    @param {String} inOptions.url The url to which the request is sent.
       *    @param {String} inOptions.method The HTTP method to use, default is GET.
       *    @param {boolean} inOptions.sync By default, all requests are sent asynchronously. To send synchronous requests, set to true.
       *    @param {Object} inOptions.params Data to be sent to the server.
       *    @param {Object} inOptions.body The content for the request body for POST method.
       *    @param {Object} inOptions.headers HTTP request headers.
       *    @param {String} inOptions.responseType The response type. Default is 'text'.
       *    @param {boolean} inOptions.withCredentials Whether or not to send credentials on the request. Default is false.
       *    @param {Object} inOptions.callback Called when request is completed.
       * @returns {Object} XHR object.
       */
      request: function(options) {
        var xhr = new XMLHttpRequest();
        var url = options.url;
        var method = options.method || 'GET';
        var async = !options.sync;
        //
        var params = this.toQueryString(options.params);
        if (params && method == 'GET') {
          url += (url.indexOf('?') > 0 ? '&' : '?') + params;
        }
        var xhrParams = this.isBodyMethod(method) ? (options.body || params) : null;
        //
        xhr.open(method, url, async);
        if (options.responseType) {
          xhr.responseType = options.responseType;
        }
        if (options.withCredentials) {
          xhr.withCredentials = true;
        }
        this.makeReadyStateHandler(xhr, options.callback);
        this.setRequestHeaders(xhr, options.headers);
        xhr.send(xhrParams);
        if (!async) {
          xhr.onreadystatechange(xhr);
        }
        return xhr;
      },
    
      toQueryString: function(params) {
        var r = [];
        for (var n in params) {
          var v = params[n];
          n = encodeURIComponent(n);
          r.push(v == null ? n : (n + '=' + encodeURIComponent(v)));
        }
        return r.join('&');
      },

      isBodyMethod: function(method) {
        return this.bodyMethods[(method || '').toUpperCase()];
      },
      
      bodyMethods: {
        POST: 1,
        PUT: 1,
        DELETE: 1
      },

      makeReadyStateHandler: function(xhr, callback) {
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            callback && callback.call(null, xhr.response, xhr);
          }
        };
      },

      setRequestHeaders: function(xhr, headers) {
        if (headers) {
          for (var name in headers) {
            xhr.setRequestHeader(name, headers[name]);
          }
        }
      }

    });

  </script>
  
</polymer-element>

<polymer-element name="core-ajax" attributes="url handleAs auto params response method headers body contentType withCredentials">
  <script>

    Polymer('core-ajax', {
      /**
       * Fired when a response is received.
       * 
       * @event core-response
       */
 
      /**
       * Fired when an error is received.
       * 
       * @event core-error
       */
 
      /**
       * Fired whenever a response or an error is received.
       *
       * @event core-complete
       */

      /**
       * The URL target of the request.
       * 
       * @attribute url
       * @type string
       * @default ''
       */
      url: '',

      /**
       * Specifies what data to store in the `response` property, and
       * to deliver as `event.response` in `response` events.
       * 
       * One of:
       * 
       *    `text`: uses `XHR.responseText`.
       *    
       *    `xml`: uses `XHR.responseXML`.
       *    
       *    `json`: uses `XHR.responseText` parsed as JSON.
       *
       *    `arraybuffer`: uses `XHR.response`.
       *
       *    `blob`: uses `XHR.response`.
       *
       *    `document`: uses `XHR.response`.
       *  
       * @attribute handleAs
       * @type string
       * @default 'text'
       */
      handleAs: '',

      /**
       * If true, automatically performs an Ajax request when either `url` or `params` changes.
       *
       * @attribute auto
       * @type boolean
       * @default false
       */
      auto: false,

      /**
       * Parameters to send to the specified URL, as JSON.
       *  
       * @attribute params
       * @type string (JSON)
       * @default ''
       */
      params: '',

      /**
       * Returns the response object.
       *
       * @attribute response
       * @type Object
       * @default null
       */
      response: null,

      /**
       * The HTTP method to use such as 'GET', 'POST', 'PUT', or 'DELETE'.
       * Default is 'GET'.
       *
       * @attribute method
       * @type string
       * @default ''
       */
      method: '',

      /**
       * HTTP request headers to send.
       *
       * Example:
       *
       *     <core-ajax 
       *         auto
       *         url="http://somesite.com"
       *         headers='{"X-Requested-With": "XMLHttpRequest"}'
       *         handleAs="json"
       *         on-core-response="{{handleResponse}}"></core-ajax>
       *  
       * @attribute headers
       * @type Object
       * @default null
       */
      headers: null,

      /**
       * Optional raw body content to send when method === "POST".
       *
       * Example:
       *
       *     <core-ajax method="POST" auto url="http://somesite.com"
       *         body='{"foo":1, "bar":2}'>
       *     </core-ajax>
       *  
       * @attribute body
       * @type Object
       * @default null
       */
      body: null,

      /**
       * Content type to use when sending data.
       *
       * @attribute contentType
       * @type string
       * @default 'application/x-www-form-urlencoded'
       */
      contentType: 'application/x-www-form-urlencoded',

      /**
       * Set the withCredentials flag on the request.
       * 
       * @attribute withCredentials
       * @type boolean
       * @default false
       */
      withCredentials: false,
      
      ready: function() {
        this.xhr = document.createElement('core-xhr');
      },

      receive: function(response, xhr) {
        if (this.isSuccess(xhr)) {
          this.processResponse(xhr);
        } else {
          this.error(xhr);
        }
        this.complete(xhr);
      },

      isSuccess: function(xhr) {
        var status = xhr.status || 0;
        return !status || (status >= 200 && status < 300);
      },

      processResponse: function(xhr) {
        var response = this.evalResponse(xhr);
        this.response = response;
        this.fire('core-response', {response: response, xhr: xhr});
      },

      error: function(xhr) {
        var response = xhr.status + ': ' + xhr.responseText;
        this.fire('core-error', {response: response, xhr: xhr});
      },

      complete: function(xhr) {
        this.fire('core-complete', {response: xhr.status, xhr: xhr});
      },

      evalResponse: function(xhr) {
        return this[(this.handleAs || 'text') + 'Handler'](xhr);
      },

      xmlHandler: function(xhr) {
        return xhr.responseXML;
      },

      textHandler: function(xhr) {
        return xhr.responseText;
      },

      jsonHandler: function(xhr) {
        var r = xhr.responseText;
        try {
          return JSON.parse(r);
        } catch (x) {
          return r;
        }
      },

      documentHandler: function(xhr) {
        return xhr.response;
      },

      blobHandler: function(xhr) {
        return xhr.response;
      },

      arraybufferHandler: function(xhr) {
        return xhr.response;
      },

      urlChanged: function() {
        if (!this.handleAs) {
          var ext = String(this.url).split('.').pop();
          switch (ext) {
            case 'json':
              this.handleAs = 'json';
              break;
          }
        }
        this.autoGo();
      },

      paramsChanged: function() {
        this.autoGo();
      },

      autoChanged: function() {
        this.autoGo();
      },

      // TODO(sorvell): multiple side-effects could call autoGo 
      // during one micro-task, use a job to have only one action 
      // occur
      autoGo: function() {
        if (this.auto) {
          this.goJob = this.job(this.goJob, this.go, 0);
        }
      },

      /**
       * Performs an Ajax request to the specified URL.
       *
       * @method go
       */
      go: function() {
        var args = this.xhrArgs || {};
        // TODO(sjmiles): we may want XHR to default to POST if body is set
        args.body = this.body || args.body;
        args.params = this.params || args.params;
        if (args.params && typeof(args.params) == 'string') {
          args.params = JSON.parse(args.params);
        }
        args.headers = this.headers || args.headers || {};
        if (args.headers && typeof(args.headers) == 'string') {
          args.headers = JSON.parse(args.headers);
        }
        if (this.contentType) {
          args.headers['content-type'] = this.contentType;
        }
        if (this.handleAs === 'arraybuffer' || this.handleAs === 'blob' ||
            this.handleAs === 'document') {
          args.responseType = this.handleAs;
        }
        args.withCredentials = this.withCredentials;
        args.callback = this.receive.bind(this);
        args.url = this.url;
        args.method = this.method;
        return args.url && this.xhr.request(args);
      }

    });

  </script>
</polymer-element>

